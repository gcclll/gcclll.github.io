<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>//blog/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Vue next 源码之 reactivity</title>
    <url>//blog/vuejs-next-code-reactive.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>reactivity</code> 是 vue next 里面通过 <code>proxy</code> + <code>reflect</code> 实现的响应式模块。</p>
<p>源码路径： <code>packages/reactivity</code></p>
<p>入口文件：<code>packages/reactivity/src/index.ts</code></p>
<p>疑问点解答：</p>
<ol>
<li><p><code>shallowReactive</code> 相当于浅复制，只针对对象的一级 reactive，嵌套的对象不会 reactive</p>
<p>参考：测试代码 reactive.spec.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'should keep reactive properties reactive'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> props: <span class="built_in">any</span> = shallowReactive(&#123; n: reactive(&#123; foo: <span class="number">1</span> &#125;) &#125;)</span><br><span class="line">      props.n = reactive(&#123; foo: <span class="number">2</span> &#125;)</span><br><span class="line">      expect(isReactive(props.n)).toBe(<span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="阶段代码链接"><a href="#阶段代码链接" class="headerlink" title="阶段代码链接"></a>阶段代码链接</h2><ol>
<li><a href="#code1">测试用例 <code>reactive.spec.ts</code> 通过后的代码链接</a></li>
<li><a href="#code2">测试用例 <code>effect.spec.ts</code>通过后的代码链接</a></li>
</ol>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ol>
<li><strong><font color="green">DONE</font></strong> <code>ownKeys</code> 代理收集的依赖不能被触发。</li>
</ol>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2020-05-21-21-19-07-git-pull"><a href="#2020-05-21-21-19-07-git-pull" class="headerlink" title="2020-05-21 21:19:07 git pull"></a>2020-05-21 21:19:07 git pull</h3><h1 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h1><ol>
<li><code>__tests__/</code> 测试代码目录</li>
<li><code>src/</code> 主要代码目录</li>
</ol>
<p><code>src</code> 目录下的文件：</p>
<ol>
<li><code>baseHandler.ts</code> 传入给代理的对象，代理 <code>Object/Array</code> 时使用的 Handlers。</li>
<li><code>collectionHandlers.ts</code> 传入给代理的对象，代理 <code>[Week]Set/Map</code>类型时使用的 Handlers。</li>
<li><code>computed.ts</code> 计算属性代码</li>
<li><code>effect.ts</code></li>
<li><code>operations.ts</code> 操作类型枚举</li>
<li><code>reactive.ts</code> 主要代码</li>
<li><code>ref.ts</code> </li>
</ol>
<h1 id="Proxy-和-Reflect-回顾"><a href="#Proxy-和-Reflect-回顾" class="headerlink" title="Proxy 和 Reflect 回顾"></a>Proxy 和 Reflect 回顾</h1><p>将 reactive -&gt; createReactiveObject 简化合并：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target, toProxy, toRaw, baseHandlers, collectionHandlers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... 必须是对象 return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 已经设置过代理了</span></span><br><span class="line">  <span class="keyword">let</span> observed = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 本身就是代理</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 白名单检测</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... handlers</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// new 代理</span></span><br><span class="line">  <span class="keyword">let</span> handlers = baseHandlers || collectionHandlers || &#123;&#125; <span class="comment">// ...</span></span><br><span class="line">  observed = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handlers)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存代理设置结果到 toProxy, toRaw</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加一个 reactive 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  name: <span class="string">'vuejs'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observed = reactive(target, <span class="literal">null</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, prop, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, prop, receiver === observed, <span class="string">'get'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target, observed)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>{name: “vuejs”} Proxy {name: “vuejs”}</p>
<p>=&gt; original.name<br>“vuejs”<br>=&gt; observed.name<br>index.js:28 true “name” true “get”<br>undefined<br>=&gt; observed === original<br>false</p>
</blockquote>
<p>访问 target, observed 的属性 name 结果如上，<code>observed</code> 是被代理之后的对象。</p>
<ol>
<li>Observed.name 输出结果是 handler.get 执行之后的结果，因为没任何返回所以是 <code>undefined</code></li>
<li><code>get(target, prop, receiver)</code> 有三个参数，分别代表<ul>
<li>target: 被代理的对象，即原始的那个 target 对象</li>
<li>prop: 要获取对象的属性值的 key</li>
<li>receiver: 代理之后的对象，即 <code>observed</code></li>
</ul>
</li>
</ol>
<p><strong>其他主要几个代理方法</strong>：</p>
<ol>
<li><code>set</code> 赋值的时候触发，对应 <code>Reflect.set(target, prop, value)</code></li>
<li><code>get</code> 取值的时候触发，对应 <code>Reflect.get(target, prop, reciver)</code></li>
<li><code>ownKeys</code> 使用 <code>for...in</code> 时触发，对应 <code>Reflect.ownKeys(target)</code></li>
<li><code>has</code> 使用 <code>prop in obj</code> 时触发，对应语法 ： <code>... in ...</code></li>
<li><code>deleteProperty</code> 使用 <code>delete obj.name</code> 触发，对应 <code>delete obj.name</code></li>
<li><code>apply</code> 被代理对象是函数的时候，通过 <code>fn.apply()</code> 时触发，handler 里对应 <code>fn()</code></li>
<li><code>construct</code> 构造器，<code>new target()</code> 时触发</li>
<li><code>getPrototypeOf</code> 调用 <code>Object.getPrototypeOf(target)</code> 触发，返回对象 或 null</li>
<li><code>setPrototypeOf</code> 设置对象原型时触发，如： <code>obj.prototype = xxx</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> original = &#123;</span><br><span class="line">  name: <span class="string">'vuejs'</span>,</span><br><span class="line">  foo: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">original = test</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observed = reactive(original, <span class="literal">null</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, prop, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target === original, prop, receiver === observed, <span class="string">'get'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (target, prop, value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop, value, <span class="string">'set'</span>)</span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, prop, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  ownKeys: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get own keys...'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(target)</span><br><span class="line">  &#125;,</span><br><span class="line">  has: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'has proxy handler...'</span>)</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">'deleted from '</span>, target)</span><br><span class="line">    <span class="keyword">delete</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 适用于被代理对象是函数类型的</span></span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params">target, thisArg, argList</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'apply...'</span>, argList)</span><br><span class="line">    target(...argList)</span><br><span class="line">  &#125;,</span><br><span class="line">  construct(target, args) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'proxy construct ... '</span>, args)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> target(...args)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 必须返回一个对象或者 null，代理 Object.getPrototypeOf 取对象原型</span></span><br><span class="line">  getPrototypeOf(target) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'proxy getPrototypeOf...'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setPrototypeOf(target, proto) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'proxy setPrototypeOf...'</span>, proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(observed.name) <span class="comment">// -&gt; true "name" true "get"</span></span><br><span class="line">observed.name = <span class="string">'xxx'</span> <span class="comment">// -&gt; name xxx set</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> observed) &#123;</span><br><span class="line">&#125; <span class="comment">// -&gt; get own keys...</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> observed <span class="comment">// -&gt; has proxy handler</span></span><br><span class="line"><span class="keyword">delete</span> observed.foo <span class="comment">// foo deleted from &#123; name: 'xxx', foo: 1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'test apply'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observed.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// apply... (3) [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 注意点：proxy-construct 的第二个参数是传入构造函数时的参数列表</span></span><br><span class="line"><span class="comment">// 就算是以下面方式一个个传递的</span></span><br><span class="line"><span class="keyword">new</span> observed(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// proxy construct ...  (3) [1, 2, 3]</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(observed) <span class="comment">// proxy getPrototypeOf...</span></span><br><span class="line">observed.prototype = &#123;</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prototype &#123;bar: 2&#125; set</span></span><br><span class="line"><span class="comment">// index.js:31 true "prototype" true "get"</span></span><br><span class="line"><span class="comment">// index.js:90 &#123;bar: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(observed.prototype)</span><br></pre></td></tr></table></figure>

<p>需要注意的点：</p>
<ol>
<li><code>construct</code> 的代理 <code>handler</code> 中的第二个参数是一个参数列表数组。</li>
<li><code>getPrototypeOf</code> 代理里面返回一个正常的对象 或 <code>null</code>表示失败。 </li>
</ol>
<h1 id="reactive-函数"><a href="#reactive-函数" class="headerlink" title="reactive 函数"></a>reactive 函数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target: object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">// 这里对只读的对象进行判断，因为只读的对象不允许修改值</span></span><br><span class="line">  <span class="comment">// 只要曾经被代理过的就会被存到 readonlyToRaw 这个 WeakMap 里面</span></span><br><span class="line">  <span class="comment">// 直接返回只读版本</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyToRaw.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    rawToReactive,</span><br><span class="line">    reactiveToRaw,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入一个 <code>target</code> 返回代理对象。</p>
<h1 id="createReactiveObject"><a href="#createReactiveObject" class="headerlink" title="createReactiveObject"></a>createReactiveObject</h1><p>真正执行代理的是这个函数里面。</p>
<h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><ol>
<li><code>target</code> 被代理的对象</li>
<li><code>toProxy</code> 一个 <code>WeakMap</code> 里面存储了 <code>target -&gt; observed</code> </li>
<li><code>toRaw</code> 和 <code>toProxy</code> 刚好相反的一个 <code>WeakMap</code> 存储了 <code>observed -&gt; target</code></li>
<li><code>baseHandlers</code> 代理时传递给 <code>Proxy</code> 的第二个参数</li>
<li><code>collectionHandlers</code> 代理时传递给 <code>Proxy</code> 的第二个参数(一个包含四种集合类型的 <code>Set</code>)</li>
</ol>
<h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>下面是将 <code>reactive</code> 和 <code>createReactiveObject</code> 进行合并的代码。</p>
<p>事先声明的变量列表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合类型的构造函数，用来检测 target 是使用 baseHandlers</span></span><br><span class="line"><span class="comment">// 还是 collectionHandlers</span></span><br><span class="line"><span class="keyword">const</span> collectionTypes = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="built_in">Set</span>, <span class="built_in">Map</span>, <span class="built_in">WeakMap</span>, <span class="built_in">WeakSet</span>])</span><br><span class="line"><span class="comment">// 只读对象的 map，只读对象代理时候直接返回原始对象</span></span><br><span class="line"><span class="keyword">const</span> readonlyToRaw = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="comment">// 存储一些只读或无法代理的值</span></span><br><span class="line"><span class="keyword">const</span> rawValues = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br></pre></td></tr></table></figure>

<p>合并后的 <code>reactive(target, toProxy, toRaw, basehandlers, collectionHandlers)</code> 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target, toProxy, toRaw, baseHandlers, collectionHandlers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只读的对象</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyToRaw.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 必须是对象 return</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; <span class="keyword">typeof</span> target !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'不是对象，不能被代理。。。'</span>)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// toProxy 是一个 WeakMap ，存储了 observed -&gt; target</span></span><br><span class="line">  <span class="comment">// 因此这里检测是不是已经代理过了避免重复代理情况</span></span><br><span class="line">  <span class="keyword">let</span> observed = toProxy.get(target)</span><br><span class="line">  <span class="keyword">if</span> (observed !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'target 已经设置过代理了'</span>)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 本身就是代理</span></span><br><span class="line">  <span class="comment">// toRaw 也是一个 WeakMap 存储了 target -&gt; observed</span></span><br><span class="line">  <span class="comment">// 这里判断这个，可能是为了防止，将曾经被代理之后的 observed 传进来再代理的情况</span></span><br><span class="line">  <span class="keyword">if</span> (toRaw.has(target)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'target 本身已经是代理'</span>)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...... 这里省略非法对象的判断，放在后面展示 ......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 target 类型决定使用哪个 handlers</span></span><br><span class="line">  <span class="comment">// `Set, Map, WeakSet, SeakMap` 四种类型使用 collectionHandlers 集合类型的 handlers</span></span><br><span class="line">  <span class="comment">// `Object, Array` 使用 basehandlers</span></span><br><span class="line">  <span class="keyword">const</span> handlers = collectionTypes.has(target.constructor)</span><br><span class="line">    ? collectionHandlers</span><br><span class="line">    : baseHandlers</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new 代理</span></span><br><span class="line">  observed = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handlers)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存代理设置结果到 toProxy, toRaw</span></span><br><span class="line">  toProxy.set(observed, target)</span><br><span class="line">  toRaw.set(target, observed)</span><br><span class="line">  <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>readonlyToRaw.has(target)</code> 检测是否是只读对象，直接返回该对象</p>
</li>
<li><p>检测 <code>target</code>是引用类型还是普通类型，只有引用类型才能被代理</p>
</li>
<li><p><code>toProxy</code> 中存储了 <code>target-&gt;observed</code> 内容，检测 <code>target</code> 是不是已经有代理了</p>
</li>
<li><p><code>toRaw</code> 中存储了 <code>observed-&gt;target</code> 检测是否已经是代理了</p>
</li>
<li><p>五种不合法的对象类型，不能作为代理源</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 白名单检测，源码中调用的是 `canObserve` 这里一个个拆分来检测</span></span><br><span class="line">  <span class="comment">// 1. Vue 实例本身不能被代理</span></span><br><span class="line">  <span class="keyword">if</span> (target._isVue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'target 是 vue 实例，不能被代理'</span>)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. Vue 的虚拟节点，其实就是一堆包含模板字符串的对象解构</span></span><br><span class="line">  <span class="comment">// 这个是用来生成 render 构建 DOM 的，不能用来被代理</span></span><br><span class="line">  <span class="keyword">if</span> (target._isVNode) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'target 是虚拟节点，不能被代理'</span>)</span><br><span class="line">    <span class="keyword">return</span> targtet</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 限定了只能被代理的一些对象： 'Object, Array, Map, Set, WeakMap, WeakSet`</span></span><br><span class="line">  <span class="comment">// Object.prototype.toString.call(target) =&gt; [object Object] 取 (-1, 8)</span></span><br><span class="line">  <span class="comment">// 其实 `Object` 构造函数字符串</span></span><br><span class="line">  <span class="keyword">const</span> toRawType = <span class="function">(<span class="params">target</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, <span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    ![<span class="string">'Object'</span>, <span class="string">'Array'</span>, <span class="string">'Map'</span>, <span class="string">'Set'</span>, <span class="string">'WeakMap'</span>, <span class="string">'WeakSet'</span>].includes(</span><br><span class="line">      toRawType(target)</span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`target 不是可代理范围对象('Object', 'Array', 'Map', 'Set', 'WeakMap', 'WeakSet')`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 那些被标记为只读或者非响应式的WeakSets的值</span></span><br><span class="line">  <span class="keyword">if</span> (rawValues.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 被冻结的对象，是不允许任何修改操作的，不可用作响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.isFrozen(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 target 的类型检测采用哪种类型的 <code>handlers</code>，集合类型使用 <code>collectionhandlers</code>，对象类型采用 <code>baseHandlers</code></p>
</li>
<li><p>创建代理 <code>new Proxy(target, handlers)</code></p>
</li>
<li><p>缓存代理源及代理结果到 <code>toProxy, toRaw</code> 避免出现重复代理的情况</p>
</li>
<li><p>返回代理对象 <code>observed</code>。</p>
</li>
</ol>
<h2 id="使用-reactive"><a href="#使用-reactive" class="headerlink" title="使用 reactive"></a>使用 <code>reactive</code></h2><p>为了区分两种代理类型(集合类型，普通对象(对象和数组))，这里使用两个对象(<code>setTarget</code>, <code>objTarget</code>)，创建两个代理(<code>setObserved</code>, <code>objObserved</code>)，分别传入不同的代理 <code>handlers</code>，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toProxy = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">const</span> toRaw = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setTarget = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">const</span> objTarget = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setObserved = reactive(setTarget, toProxy, toRaw, <span class="literal">null</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop, <span class="string">'set get...'</span>)</span><br><span class="line">    <span class="comment">// return Reflect.get(target, prop, receiver)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// set/map 集合类型</span></span><br><span class="line">  has(target, prop) &#123;</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="built_in">Reflect</span>.has(target, prop)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(ret, target, prop, <span class="string">'set has...'</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> objObserved = reactive(</span><br><span class="line">  objTarget,</span><br><span class="line">  toProxy,</span><br><span class="line">  toRaw,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// object/arary, 普通类型</span></span><br><span class="line">    <span class="keyword">get</span>(target, prop, receiver) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(prop, <span class="string">'object/array get...'</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>输出代理的结果对象如下：<code>console.log(setObserved, objObserved)</code></p>
<p>结果：<code>Proxy {1, 2, 3} Proxy {foo: 1, bar: 2}</code></p>
<p>然后出现了错误，当我试图调用 <code>setObserved.has(1)</code> 的时候报错了：</p>
<p><img src="http://qiniu.ii6g.com/1589614203.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>获取 <code>setObserved.size</code> 属性报错，不同的是 <code>set proxy handler</code> 有被调用，这里应该是调用 <code>Reflect.get()</code> 时候报错了：</p>
<p><img src="http://qiniu.ii6g.com/1589614685.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p><a href="https://medium.com/the-non-traditional-developer/safely-extending-the-javascript-set-object-using-proxies-3ce25702b8c3" target="_blank" rel="noopener">google 之后这里有篇文章里给出了问题原因和解决方案</a></p>
<p>解决方法，在 <code>get proxy handler</code> 里面加上判断，如果是函数就使用 <code>target</code>去调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setObserved = reactive(setTarget, toProxy, toRaw, <span class="literal">null</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop, receiver) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (prop) &#123;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="comment">// 如果是函数，经过代理之后会丢失作用域问题，所以要</span></span><br><span class="line">        <span class="comment">// 重新给他绑定下作用域</span></span><br><span class="line">        <span class="built_in">console</span>.log(prop, <span class="string">'get...'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> target[prop] === <span class="string">'function'</span></span><br><span class="line">          ? target[prop].bind(target)</span><br><span class="line">          : target[prop]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>Proxy {1, 2, 3} Proxy {foo: 1, bar: 2}<br>-&gt; setObserved.has(1)<br> has get…<br>true</p>
</blockquote>
<h1 id="handlers"><a href="#handlers" class="headerlink" title="handlers"></a>handlers</h1><p>这个模块出现了几个 handlers 是需要弄清楚的，比如：</p>
<p><code>baseHandlers.ts</code> 里面和 <strong>Array</strong>, <strong>Object</strong> 有关的四个：</p>
<ol>
<li><code>mutableHandlers</code></li>
<li><code>readonlyHandlers</code></li>
<li><code>shallowReactiveHandlers</code>, </li>
<li><code>shallowReadonlyHandlers</code></li>
</ol>
<p><code>collectionHandlers.ts</code> 里和集合相关的两个：</p>
<ol>
<li><code>mutableCollectionHandlers</code></li>
<li><code>readonlyCollectionHandlers</code></li>
</ol>
<p>在上一节讲过 <code>createReactiveObject</code> 需要给出两个 handlers 作为参数，一个是针对数组和普通对象的，另一个是针对集合类型的。</p>
<p>下面分别来看看两个文件中分别都干了什么？？？</p>
<h2 id="baseHandlers-ts"><a href="#baseHandlers-ts" class="headerlink" title="baseHandlers.ts"></a>baseHandlers.ts</h2><h3 id="列出文件中相关的函数和属性："><a href="#列出文件中相关的函数和属性：" class="headerlink" title="列出文件中相关的函数和属性："></a>列出文件中相关的函数和属性：</h3><p>属性:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 符号集合</span></span><br><span class="line"><span class="keyword">const</span> builtInSymbols = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="comment">/* ... */</span>);</span><br><span class="line"><span class="comment">// 四个通过 createGetter 生成的 get 函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = /*#__PURE__*/ createGetter()</span><br><span class="line">const shallowGet = /*#__PURE__*/ createGetter(false, true)</span><br><span class="line">const readonlyGet = /*#__PURE__*/ createGetter(true)</span><br><span class="line">const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)</span><br><span class="line"></span><br><span class="line">// 三个数组函数 'includes', 'indexOf', 'lastIndexOf'</span><br><span class="line">const arrayInstrumentations: Record&lt;string, Function&gt; = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setter</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = /*#__PURE__*/ createSetter()</span><br><span class="line">const shallowSet = /*#__PURE__*/ createSetter(true)</span><br></pre></td></tr></table></figure>

<p>函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 getter 函数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 setter 函数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete obj.name 原子操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteProperty</span>(<span class="params">target: object, key: <span class="built_in">string</span> | symbol</span>): <span class="title">boolean</span> </span>&#123; 	<span class="comment">/*...*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作 key in obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">has</span>(<span class="params">target: object, key: <span class="built_in">string</span> | symbol</span>): <span class="title">boolean</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys(target) 操作，取对象 key</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ownKeys</span>(<span class="params">target: object</span>): (<span class="params"><span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span>)[]  </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure>



<p>四个要被导出的 <code>handlers</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutableHandlers: ProxyHandler&lt;object&gt; = &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> readonlyHandlers: ProxyHandler&lt;object&gt; = &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReactiveHandlers: ProxyHandler&lt;object&gt; = &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReadonlyHandlers: ProxyHandler&lt;object&gt; = &#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>接下来一个个来分析分析，看看每个都有什么作用？？？</p>
<p>先从 <code>createGetter</code> 说起吧 -&gt; </p>
<p>为了下面方便调试，对上面的 <code>reactive()</code> 进行了简化，只保留了与 handlers 有关的部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> collectionTypes = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="built_in">Set</span>, <span class="built_in">Map</span>, <span class="built_in">WeakMap</span>, <span class="built_in">WeakSet</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target, toProxy, toRaw, baseHandlers, collectionHandlers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 简化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span>) <span class="keyword">return</span> target</span><br><span class="line"></span><br><span class="line">  <span class="comment">//... isVue, VNode...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> observed = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handlers = collectionTypes.has(target.constructor)</span><br><span class="line">    ? collectionHandlers</span><br><span class="line">    : baseHandlers</span><br><span class="line"></span><br><span class="line">  observed = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handlers)</span><br><span class="line">  toProxy.set(target, observed)</span><br><span class="line">  toRaw.set(observed, target)</span><br><span class="line">  <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toProxy = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">  toRaw = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br></pre></td></tr></table></figure>

<h3 id="createGetter-isReadonly-false-shallow-false"><a href="#createGetter-isReadonly-false-shallow-false" class="headerlink" title="createGetter(isReadonly = false, shallow = false)"></a>createGetter(isReadonly = false, shallow = false)</h3><p>参数： </p>
<ol>
<li><code>isReadonly = false</code></li>
<li><code>shallow = false</code></li>
</ol>
<p>简化之后的 <code>createGetter</code>，先用它来创建一个 <code>get</code> 然后创建一个 <code>baseHandler: mutableHandlers</code> 可变的 <code>handlers</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 很明显这个 proxy handler get, 简化之后...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(...arguments)</span><br><span class="line">    <span class="comment">// ... 省略1，如果是数组，且是 includes, indexOf, lastIndexOf 操作</span></span><br><span class="line">    <span class="comment">// 直接返回它对应的 res</span></span><br><span class="line">    <span class="comment">// ... 省略2，如果是符号属性，直接返回 res</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略3, 浅 reactive，不支持嵌套</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略4，isRef 类型，判断是数组还是对象，数组执行 track(...), 对象返回 res.value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非只读属性，执行 track()，收集依赖</span></span><br><span class="line">    !isReadonly &amp;&amp; track(target, <span class="string">'get'</span>, key)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(res, key, <span class="string">'get...'</span>)</span><br><span class="line">    <span class="comment">// return res</span></span><br><span class="line">    <span class="comment">// 非对象直接返回原结果，如果是对象区分只读与否</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> &amp;&amp; res !== <span class="literal">null</span></span><br><span class="line">      ? isReadonly</span><br><span class="line">        ? <span class="comment">// need to lazy access readonly and reactive here to avoid</span></span><br><span class="line">          <span class="comment">// circular dependency</span></span><br><span class="line">          res <span class="comment">// ... readonly(res)</span></span><br><span class="line">        : reactive(res, toProxy, toRaw, mutableHandlers)</span><br><span class="line">      : res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们省略了暂时不关心的是哪个部分：</p>
<ol>
<li>数组类型且 key 是 <code>[&#39;includes&#39;, &#39;indexOf&#39;, &#39;lastIndexOf&#39;]</code> 其中任一一个</li>
<li>符号属性处理</li>
<li><code>ref</code> 类型处理</li>
</ol>
<p>目前我们只关心如何创建 <code>get</code> 和一个最简单的 <code>basehandler: mutableHandler</code></p>
<p>使用 <code>createGetter: get</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例 1</span></span><br><span class="line"><span class="keyword">const</span> objTarget = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: &#123; </span><br><span class="line">    name: <span class="string">'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 createGetter 生成的 get -&gt; mutableHandlers 传入 reactive</span></span><br><span class="line"><span class="keyword">const</span> objObserved = reactive(objTarget, toProxy, toRaw, mutableHandlers)</span><br></pre></td></tr></table></figure>

<p>这里 <code>get</code> 我认为只有两个目的：</p>
<h4 id="递归-reactive，就在最后返回的时候检测-res-结果时候"><a href="#递归-reactive，就在最后返回的时候检测-res-结果时候" class="headerlink" title="递归 reactive，就在最后返回的时候检测 res 结果时候"></a>递归 <code>reactive</code>，就在最后返回的时候检测 <code>res</code> 结果时候</h4><p>这里我们首先来验证下递归 <code>reactive</code> 问题，即当我们访问对象中嵌套对象里面的属性时候，实际上是不会触发 <code>get</code> 的，我们在 <code>createGetter</code> 的 <code>return</code> 前面加上一句 <code>return res</code> 。</p>
<p>也就是说不检测结果是不是对象，而直接返回当前取值的结果：</p>
<blockquote>
<p>=&gt; objObserved.foo<br>“foo” “get…”<br>1<br>=&gt; objObserved.bar<br>{name: “bar”} “bar” “get…”<br>{name: “bar”}<br>{name: “bar”} “bar” “get…”<br>=&gt; objObserved.bar.name<br>{name: “bar”} “bar” “get…”<br>“bar”<br>=&gt; const bar = objObserved.bar<br>{name: “bar”} “bar” “get…”<br>undefined<br>=&gt; bar.name<br>“bar”</p>
</blockquote>
<p>分析上面的测试结果：</p>
<ul>
<li><code>objObserved.foo</code> 直接取对象的成员值，触发了 <code>proxy get</code></li>
<li><code>objObserved.bar</code> 取对象的对象成员，触发了 <code>proxy get</code></li>
</ul>
<ul>
<li><code>objObserved.bar.name</code> 取嵌套对象的成员，触发了 <code>proxy get</code>但请注意实际上触发 <code>get</code> 的是 <code>objObserved.bar</code> 得取值过程，因为输出的 <code>res</code> 是 <code>{name: &quot;bar&quot;}</code>，也就是说取 <code>bar.name</code> 的<code>name</code>时候实际并没有触发 <code>proxy get</code>，这说明 <code>proxy get</code> 只能代理一级。</li>
</ul>
<ul>
<li>为了证明代理只能代理一级，下面通过 <code>bar = objObserved.bar</code> 再去取 <code>bar.name</code> 就很明显并没有触发 <code>proxy get</code></li>
</ul>
<p>通过上面的分析，这也就是为什么要在 <code>return</code> 的时候去检测是不是对象，如果是对象需要进行递归 <code>reactive</code>的动作。</p>
<p>那么，我们将 <code>return res</code> 注释掉再来看看结果如何：</p>
<blockquote>
<p>=&gt; objObserved.foo<br>1 “foo” “get…”<br>1<br>=&gt; objObserved.bar<br>{name: “bar”} “bar” “get…”<br>Proxy {name: “bar”}<br>=&gt; objObserved.bar.name<br>{name: “bar”} “bar” “get…”<br>bar name get…<br>“bar”<br>=&gt; const bar = objObserved.bar<br>{name: “bar”} “bar” “get…”<br>bar.name<br>=&gt; bar name get…<br>“bar”</p>
</blockquote>
<p>看到差异没，首先从 <code>objObserved.bar.name</code> 就可看出差异了，这里首先触发的实际是 <code>objObserved.bar</code> 的 <code>proxy get</code>，此时 <code>return</code> 的时候发现结果是个对象，因此将 <code>bar</code> 传入 <code>reactive(bar)</code> 进一步代理，完成之后取 <code>bar.name</code> 的时候 <code>bar</code> 已经是 reactive 对象了，因此就在 <strong>{name: “bar”} “bar” “get…”</strong> 后面紧跟着出现了<strong>bar name get…</strong> 输出。</p>
<p>此时，无论后面是赋值到变量 <code>bar</code> 再取 <code>bar.name</code> 结果一样会触发对应的 <code>proxy get</code>，毕竟对象是引用类型，类似指针一样，新增了一个变量指向它，它依旧在哪里。</p>
<p>到此，最基本的 <code>proxy get</code> 响应式也完成了，并且能做到嵌套对象的 reactive 化，感觉相比 vue3 之前的通过 <code>defineProperty</code> 实现更加清晰容易理解。</p>
<h4 id="收集依赖-track"><a href="#收集依赖-track" class="headerlink" title="收集依赖(track)"></a>收集依赖(<code>track</code>)</h4><p>既然有了响应式数据，那么接下来的重点就是如果利用其特性为我们做点事情，但是它又如何知道为我们做什么的，这个时候就有了所谓的“收集依赖”。</p>
<p>“收集依赖”就是在 <code>get</code> 取值期间发生的，也就是 <code>createGetter</code> 中的 <code>track()</code> 调用时触发了依赖收集动作。</p>
<p><code>track()</code> 相关的代码在 <code>effect.ts</code> 中：</p>
<p>函数定义： </p>
<p><code>export function track(target: object, type: TrackOpTypes, key: unknown){}</code></p>
<p>有三个参数：</p>
<ol>
<li>target：proxy get 时候传递给 proxy 的那个对象</li>
<li>type: 要 track 的类型，有三种： <code>get</code>, <code>has</code>,<code>iterate</code>，分别是取值，检测属性存在性，以及迭代时。</li>
<li>Key: 针对 target 对象里面的属性，收集依赖到 <code>targetMap -&gt; depsMap -&gt; dep:Set</code> 中</li>
</ol>
<p>简化 <code>track(target, type)</code>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// trackType -&gt; get, has, iterate</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, type, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略1 检测 shouldTrack 和 activeEffect 标记</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取 target 自己的依赖 map ，如果没有说明是首次，需要给它创建一个</span></span><br><span class="line">  <span class="comment">// 空的集合，这里使用 Map 而不是 WeakMap，为的是强引用，它涉及到</span></span><br><span class="line">  <span class="comment">// 数据的更新触发 UI 渲染，因此不该使用 WeakMap，否则可能会导致依赖丢失问题</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下来对 key 取其依赖</span></span><br><span class="line">  <span class="comment">// 如果属性的依赖不存在，说明该对象是首次使用，需要创建其依赖库</span></span><br><span class="line">  <span class="comment">// 且这里使用了 `Set` 是为了避免重复注册依赖情况，避免数据的更新导致重复触发</span></span><br><span class="line">  <span class="comment">// 同一个 update 情况</span></span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册实际的 update: activeEffect 操作</span></span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现主要有三个过程：</p>
<ol>
<li>检测全局的 <code>targetMap</code> 中是不是有 <code>target</code> 自己的依赖仓库(<code>Map</code>)</li>
<li>检测 <code>depsMap = targetMap.get(target)</code> 中是不是有取值 <code>key</code> 对应的依赖集合 <code>dep</code></li>
<li>注册 <code>activeEffect</code>对象，然后将当前 target-key-dep 注册到 activeEffect，然后发现每个 <code>activeEffect</code>会有自己的 <code>deps</code> 保存了所有对象 <code>key</code> 的依赖。 </li>
</ol>
<p>收集依赖的过程如图：，执行取值 <code>activeEffect.deps</code> 中就会新增一个 <code>Set</code></p>
<p><img src="http://qiniu.ii6g.com/1589694976.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>到这里，依赖收集算是完成，但并不是很明白 <code>activeEffect</code> 具体是做什么的???</p>
<p>既然依赖收集，要搞明白 <code>activeEffect</code> 是做什么的，估计的从 <code>set</code> 入手了，下面来实现 <code>set</code> 从而完成一个完整的 <code>get -&gt; dep -&gt; set -&gt; update</code> 的过程。</p>
<p>go on…</p>
<h3 id="createSetter-shallow-false"><a href="#createSetter-shallow-false" class="headerlink" title="createSetter(shallow = false)"></a>createSetter(shallow = false)</h3><p>源码简化版：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetter</span>(<span class="params">shallow = false</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 标准的 proxy set</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 取旧值</span></span><br><span class="line">    <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先不管 shallow mode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还记得 reactive 里面的 toRaw啊，对象这里就是取出</span></span><br><span class="line">    <span class="comment">// value 的原始对象 target，前提是它有 reactive() 过</span></span><br><span class="line">    <span class="comment">// 才会被存入到 toRaw: observed -&gt; target 中</span></span><br><span class="line">    <span class="comment">// 暂时简化成： toRaw.get(value)</span></span><br><span class="line">    value = toRaw.get(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略，ref 检测</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hadKey = hasOwn(target, key)</span><br><span class="line">    <span class="comment">// 先执行设置原子操作</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有对象是它自身的时候，才触发 dep-update(排除原型链)</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="comment">// 新增属性操作</span></span><br><span class="line">        trigger(target, <span class="string">'add'</span>, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        <span class="comment">// 值改变操作,排除 NaN !== NaN 情况</span></span><br><span class="line">        trigger(target, <span class="string">'set'</span>, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要有几个操作：</p>
<ol>
<li>shallow mode 检测，已省略。</li>
<li><code>value = toRaw(value)</code> 如果 value 是 observed，那么可以通过 toRaw 取出被代理之前的对象 target，还记得 <code>reactive()</code> 里面的那个 toRaw, toProxy 缓存操作吧。</li>
<li>调用 <code>Reflect.set()</code> 先将值设置下去，然后再考虑是否触发依赖</li>
<li>检测对象原型链，只有当对象是自身的时候才触发依赖</li>
<li>触发的行为只有两种要么是新增属性(<code>add</code>)，要么是更改值(<code>set</code>, 值不变的情况不触发)</li>
</ol>
<p>这里有个与 <code>createGetter</code> 里面收集依赖 (<code>track()</code>)对应的触发依赖函数： <code>trigger</code>。</p>
<p>接下来就是要看看 <code>trigger()</code> 里面都做了啥。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, type, key, newValue, oldValue, oldTarget</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// step1: 检测是否被 track 过，没有根本就没有依赖</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// step2: 将 dep 加入到 effects</span></span><br><span class="line">  <span class="comment">// 创建两个 effects, 一个普通的，一个计算属性</span></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">const</span> computedRunners = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="comment">// 根据 effect 的选项 computed 决定是添加到那个 Set 中</span></span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd</span>) =&gt;</span></span><br><span class="line">    effectsToAdd.forEach(</span><br><span class="line">      (effect) =&gt;</span><br><span class="line">        (effect !== activeEffect || !shouldTrack) &amp;&amp;</span><br><span class="line">        (effect.options.computed</span><br><span class="line">          ? computedRunners.push(effect)</span><br><span class="line">          : effects.push(effect))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if ... clear</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO 清空动作，触发所有依赖</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数组长度变化</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO 触发更长度变化有关的所有依赖</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 例如： SET | ADD | DELETE 操作</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isAddOrDelete =</span><br><span class="line">      type === <span class="string">'add'</span> || (type === <span class="string">'delete'</span> &amp;&amp; !<span class="built_in">Array</span>.isArray(target))</span><br><span class="line">    <span class="keyword">if</span> (isAddOrDelete || (type === <span class="string">'set'</span> &amp;&amp; target <span class="keyword">instanceof</span> <span class="built_in">Map</span>)) &#123;</span><br><span class="line">      <span class="comment">// 删除或添加操作，或者 map 的设置操作</span></span><br><span class="line">      add(depsMap.get(<span class="built_in">Array</span>.isArray(target) ? <span class="string">'length'</span> : ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map 的添加或删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (isAddOrDelete &amp;&amp; target <span class="keyword">instanceof</span> <span class="built_in">Map</span>) &#123;</span><br><span class="line">      add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// step3: 执行 effects 中所有的 dep</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 选项提供了自己的调度器，执行自己的</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发应该触发的依赖</span></span><br><span class="line">  computedRunners.forEach(run)</span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要有三个步骤：</p>
<ul>
<li>step1: 检测是否收集过依赖，如果没有说明可能没有被用过，没什么可触发的</li>
<li>step2: 主要是过滤收集到依赖，针对当前更改操作的所有依赖触发(add)</li>
<li>step2: 经过第二步的依赖过滤之后，触发所有的依赖(run)</li>
</ul>
<p>这里面有两个重要的属性(<code>effects</code>,<code>computedRunners</code>)和两个函数(<code>add</code>,<code>run</code>)</p>
<p><em>add: 过滤，run: 执行。</em></p>
<p>很明显，到这里，我们还是没有解决，依赖对应的 <code>update</code> 是如何收集的问题，因为 <code>set</code> 也只是将已经收集好 <code>dep</code> 执行而已。</p>
<h1 id="effect-ts"><a href="#effect-ts" class="headerlink" title="effect.ts"></a>effect.ts</h1><p>该文件中主要包含三个重要函数:</p>
<ol>
<li><code>trigger(target, type, key?, newValue?, oldValue?, oldTarget?)</code> 触发依赖函数</li>
<li><code>effect-&gt;createReactiveEffect(fn, options)</code> 转换依赖函数成ReactiveEffect类型，并且立即执行它。</li>
<li><code>track(target, type, key)</code></li>
</ol>
<p>以及一些辅助函数：</p>
<ol>
<li><p><code>isEffect()</code> 检测是不是 <code>ReactiveEffect</code> 类型<br><code>isEffect = fn =&gt; fn?._isEffect === true</code></p>
</li>
<li><p><code>stop(effect: ReactiveEffect)</code><br>停止 effect ，如果选项中提供了 onStop 监听该动作，执行它，重置 effect.active。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span>(<span class="params">effect: ReactiveEffect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (effect.active) &#123;</span><br><span class="line">    cleanup(effect)</span><br><span class="line">    <span class="keyword">if</span> (effect.options.onStop) &#123;</span><br><span class="line">      effect.options.onStop()</span><br><span class="line">    &#125;</span><br><span class="line">    effect.active = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><code>cleanup(effect: ReactiveEffect)</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 track 的时候，加入 effect 时，对其做一次清理工作</span></span><br><span class="line"><span class="comment">// 保证 effect.deps 干净</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params">effect: ReactiveEffect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deps &#125; = effect</span><br><span class="line">  <span class="keyword">if</span> (deps.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">      deps[i].delete(effect)</span><br><span class="line">    &#125;</span><br><span class="line">    deps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p><code>pauseTracking()</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停 track 动作</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pauseTracking</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  trackStack.push(shouldTrack)</span><br><span class="line">  shouldTrack = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>enableTracking()</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 恢复 track 动作</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enableTracking</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  trackStack.push(shouldTrack)</span><br><span class="line">  shouldTrack = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>resetTracking()</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重置 track，可能 fn 执行失败了，try ... finally ... 丢弃 fn:effect 时候调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetTracking</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> last = trackStack.pop()</span><br><span class="line">  shouldTrack = last === <span class="literal">undefined</span> ? <span class="literal">true</span> : last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>包含的属性变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存着 target 对象的所有依赖的 Map &lt;target, dep&lt;Set&gt;&gt;</span></span><br><span class="line"><span class="comment">// target -&gt; Map&lt;key, dep[]&gt;</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> WeakMap&lt;<span class="built_in">any</span>, KeyToDepMap&gt;()</span><br><span class="line"><span class="comment">// effect 栈，保存所有的 fn-&gt;effect</span></span><br><span class="line"><span class="keyword">const</span> effectStack: ReactiveEffect[] = []</span><br><span class="line"><span class="comment">// 当前激活状态的 effect</span></span><br><span class="line"><span class="keyword">let</span> activeEffect: ReactiveEffect | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ITERATE_KEY = Symbol(__DEV__ ? <span class="string">'iterate'</span> : <span class="string">''</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? <span class="string">'Map key iterate'</span> : <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 effect 时，uid++，即每个 effect 都会有自己的唯一的 uid</span></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录当前 effect 的状态，</span></span><br><span class="line"><span class="keyword">let</span> shouldTrack = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 当前 effect -&gt; shouldTack</span></span><br><span class="line"><span class="comment">// 每增加一个 effect 记录 shouldTrack = true, push 到 trackStack</span></span><br><span class="line"><span class="comment">// 如果 effect.raw&lt;fn&gt; 执行异常会 pop 掉，还原 shouldTrack -&gt; last, </span></span><br><span class="line"><span class="comment">// pop trackStack</span></span><br><span class="line"><span class="keyword">const</span> trackStack: <span class="built_in">boolean</span>[] = []</span><br></pre></td></tr></table></figure>

<p>一直到这里我们基本完成了 <code>reactive-&gt;get-&gt;set-&gt;track-&gt;trigger-&gt;effect</code> 一系列动作，</p>
<p>也该我们测试的时候了，按正常应该会有我们想要的结果，响应式-&gt;注册fn:update-&gt;取值收集依赖-&gt; 设置触发 fn:udpate 调用 </p>
<p>=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> r = <span class="function">(<span class="params">target</span>) =&gt;</span> reactive(target, toProxy, toRaw, mutableHandlers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'effect fn'</span>)</span><br><span class="line"><span class="keyword">let</span> res = effect(fn, &#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(res), <span class="string">'after effect'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dummy</span><br><span class="line"><span class="keyword">const</span> counter = r(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;)</span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = counter.num))</span><br><span class="line"><span class="built_in">console</span>.log(dummy, <span class="string">'before'</span>)</span><br><span class="line">counter.num = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(dummy, <span class="string">'after'</span>)</span><br></pre></td></tr></table></figure>

<p>上面的例子运行之后，并没有得到我们想要的结果！！！</p>
<blockquote>
<p>effect fn<br>[“id”, “_isEffect”, “active”, “raw”, “deps”, “options”] “after effect”<br>0 “num” “get…”<br>0 “before”<br>0 “after”</p>
</blockquote>
<p>按照我们的实现，理论上 after 的结果应该是 7 才对，但结果显示依然是 0，这说明了我们调用 <code>effect(fn)</code> 并没有与上面的 <code>r({ num: 0 })</code> 发生任何联系，即 fn 并没有被收集到 <code>counter.num</code> 的依赖 deps 中去，那这是为什么呢？？？</p>
<hr>
<p>我们来回顾分析下之前所作工作的整个过程(<code>reactive-&gt;get-&gt;set-&gt;track-&gt;trigger-&gt;effect</code>):</p>
<ul>
<li><code>reactive</code> 将数据通过 <code>proxy</code> 转成响应式</li>
<li><code>get-&gt;track</code> 收集依赖，相关属性：targetMap, depsMap, dep, activeEffect, activeEffect.deps。</li>
<li><code>set-&gt;trigger</code> 触发依赖 update 函数，涉及到的 targetMap, depsMap,  add, run</li>
<li><code>effect</code> 将 update 函数，转换成 ReactiveEffect 类型</li>
</ul>
<p>纵观这整个过程，尤其是 <code>get-&gt;track</code> ， <code>set-&gt;trigger -&gt; effect</code> 收集，触发和 effect 三个过程，唯一有可能让他们发生联系的应该就是这个 <code>activeEffect</code> 模块域里的变量，标识着当前处于激活状态的 effect，它的使用几乎贯穿了整个过程(track-&gt;trigger-&gt;effect，这三个函数也都在 <em>effect.ts</em> 中实现)。</p>
<p>那么接下来……</p>
<p>前面都是简化之后的，现在看看完整的这三个函数实现：</p>
<h2 id="track-target-type-key"><a href="#track-target-type-key" class="headerlink" title="track(target, type, key)"></a>track(target, type, key)</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target: object, <span class="keyword">type</span>: TrackOpTypes, key: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> Map()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> Set()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        effect: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="trigger-…"><a href="#trigger-…" class="headerlink" title="trigger(…)"></a>trigger(…)</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: object,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  newValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// never been tracked</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> Set&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="keyword">const</span> computedRunners = <span class="keyword">new</span> Set&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd: Set&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect || !shouldTrack) &#123;</span><br><span class="line">          <span class="keyword">if</span> (effect.options.computed) &#123;</span><br><span class="line">            computedRunners.add(effect)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            effects.add(effect)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// the effect mutated its own dependency during its execution.</span></span><br><span class="line">          <span class="comment">// this can be caused by operations like foo.value++</span></span><br><span class="line">          <span class="comment">// do not trigger or we end in an infinite loop</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    depsMap.forEach(add)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'length'</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    depsMap.forEach(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'length'</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;</span><br><span class="line">        add(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="keyword">const</span> isAddOrDelete =</span><br><span class="line">      <span class="keyword">type</span> === TriggerOpTypes.ADD ||</span><br><span class="line">      (<span class="keyword">type</span> === TriggerOpTypes.DELETE &amp;&amp; !isArray(target))</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isAddOrDelete ||</span><br><span class="line">      (<span class="keyword">type</span> === TriggerOpTypes.SET &amp;&amp; target <span class="keyword">instanceof</span> Map)</span><br><span class="line">    ) &#123;</span><br><span class="line">      add(depsMap.get(isArray(target) ? <span class="string">'length'</span> : ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAddOrDelete &amp;&amp; target <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect: ReactiveEffect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.options.onTrigger) &#123;</span><br><span class="line">      effect.options.onTrigger(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Important: computed effects must be run first so that computed getters</span></span><br><span class="line">  <span class="comment">// can be invalidated before any normal effects that depend on them are run.</span></span><br><span class="line">  computedRunners.forEach(run)</span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="effect-fn-options"><a href="#effect-fn-options" class="headerlink" title="effect(fn, options)"></a>effect(fn, options)</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions = EMPTY_OBJ</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isEffect(fn)) &#123;</span><br><span class="line">    fn = fn.raw</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> effect = createReactiveEffect(fn, options)</span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveEffect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: (...args: <span class="built_in">any</span>[]) =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params">...args: unknown[]</span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">      <span class="keyword">return</span> options.scheduler ? <span class="literal">undefined</span> : fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(effect)) &#123;</span><br><span class="line">      cleanup(effect)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        enableTracking()</span><br><span class="line">        effectStack.push(effect)</span><br><span class="line">        activeEffect = effect</span><br><span class="line">        <span class="keyword">return</span> fn(...args)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        effectStack.pop()</span><br><span class="line">        resetTracking()</span><br><span class="line">        activeEffect = effectStack[effectStack.length - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> ReactiveEffect</span><br><span class="line">  effect.id = uid++</span><br><span class="line">  effect._isEffect = <span class="literal">true</span></span><br><span class="line">  effect.active = <span class="literal">true</span></span><br><span class="line">  effect.raw = fn</span><br><span class="line">  effect.deps = []</span><br><span class="line">  effect.options = options</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对比三个函数"><a href="#对比三个函数" class="headerlink" title="对比三个函数"></a>对比三个函数</h2><table>
<thead>
<tr>
<th>过程</th>
<th>shouldTrack/activeEffect</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>track</code></td>
<td><font color="blue">if (!shouldTrack || activeEffect === undefined) return</font></td>
<td></td>
</tr>
<tr>
<td><code>trigger</code></td>
<td>add 里面有个判断：<font color="blue">if (!shouldTrack || effect !== activeEffect)`</font>才会继续往下执行添加操作</td>
<td></td>
</tr>
<tr>
<td><code>effect</code></td>
<td><code>effectStack.push(effect)</code><br /><code>activeEffect = effect</code><br />// enable tracking<br /><code>trackStack.push(shouldTrack)</code><br /><code>shouldTrack = true</code></td>
<td></td>
</tr>
</tbody></table>
<p>对下面测试代码逐行分析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dummy</span><br><span class="line"><span class="keyword">const</span> counter = r(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;)</span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = counter.num))</span><br><span class="line"><span class="built_in">console</span>.log(dummy, counter, <span class="string">'before'</span>)</span><br><span class="line">counter.num = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(dummy, <span class="string">'after'</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>const counter = r({sum: 0})</code><br>这里将 { sum: 0 } reactive 代理之后赋值给了  <code>counter</code> 也就是说这个 <code>counter</code> 是个 <code>Proxy</code>：<img src="http://qiniu.ii6g.com/1589705626.png?imageMogr2/thumbnail/!100p" alt=""></p>
</li>
<li><p><code>effect(() =&gt; (dummy = counter.num))</code><br>在这里调用 <code>effect(fn)</code> 注册了一个 updater，里面用到了 <code>counter.num</code> 那么就会触发 <code>counter.num</code> 的 <code>proxy get</code>，然后会触发 <code>track()</code> 收集依赖:<br><img src="http://qiniu.ii6g.com/1589705890.png?imageMogr2/thumbnail/!100p" alt=""><br>并且我们从图中结果可知， fn 实际被立即执行了一次，这是 <code>effect</code> 函数里面的操作。<br>按预期，这里的 fn 应该会被收集到 counter.num 的 deps 中。<br>我们在 <code>track()</code> 最后加上打印</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect?.deps?.push(dep)</span><br><span class="line">    <span class="built_in">console</span>.log(dep, activeEffect.deps)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>结果：<img src="http://qiniu.ii6g.com/1589706174.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>即，activeEffect.deps 以及收集到了 <code>counter.num</code> 的依赖: <code>Map(1) {&quot;num&quot; =&gt; Set(1)}</code>。<br><img src="http://qiniu.ii6g.com/1589706408.png?imageMogr2/thumbnail/!100p" alt=""></p>
</li>
<li><p><code>console.log(dummy, counter, &#39;before&#39;)</code><br>经过上面的结果分析，在第2步的时候，确实已经收集到了 counter.num 的 fn:updater，且存放到了 <code>targetMap -&gt; despMap -&gt; num:Set(1)</code> 中。<br>因此这里的输出内容是： <strong>0 “num” “get…”</strong> 没什么毛病，那继续往下，问题或许处在设置的时候???</p>
</li>
<li><p><code>counter.num = 7</code><br>最后发现问题所在，原始是个超级低级的问题(捂脸<del>，没脸见人</del>)。<br>没有创建 <code>set handler</code> 并添加到 mutableHandlers 里面。<br>只要添加两句：<br><code>const set = createSetter()</code><br>然后：<br><code>const mutableHandlers = { get, set }</code><br>就能得到我们想要的结果。</p>
</li>
<li><p><code>console.log(dummy, &#39;after&#39;)</code><br>最后看下最终输出：<img src="http://qiniu.ii6g.com/1589707939.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>1 <code>effect(() =&gt; (dummy = counter.num))</code>取值时 proxy get 里面的输出</p>
<p>2： 设置值为 7 之前的输出</p>
<p>3： 设置值当中的输出<br>4： 最后一个log取值 proxy get 的输出<br>5： 最后 log 的输出内容</p>
</li>
</ol>
<p>虽然犯了个非常低级的错误，但也正因为这个低级错误，促使自己一步步的去跟踪 <code>get-&gt;track</code>, <code>set-&gt;trigger</code>, <code>effect</code> 整个过程，从而了解了依赖收集，updater 触发原理。</p>
<h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结 1"></a>小结 1</h1><p>到此一个比较完整的响应式代码也算告一段落，这里贴一下简化后可运行的完整代码(<a href="https://github.com/gcclll/vue-next-code-read/blob/master/packages/reactive.js" target="_blank" rel="noopener">reactive.js</a>)如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hasChanged = <span class="function">(<span class="params">value, oldValue</span>) =&gt;</span></span><br><span class="line">  value !== oldValue &amp;&amp; (value === value || oldValue === oldValue)</span><br><span class="line"><span class="keyword">const</span> __DEV__ = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> shouldTrack = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> ITERATE_KEY = <span class="built_in">Symbol</span>(__DEV__ ? <span class="string">'iterate'</span> : <span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> MAP_KEY_ITERATE_KEY = <span class="built_in">Symbol</span>(__DEV__ ? <span class="string">'Map key iterate'</span> : <span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> effectStack = []</span><br><span class="line"><span class="keyword">const</span> trackStack = []</span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> reactiveToRaw = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">const</span> rawToReactive = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// baseHandlers.ts start</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = createGetter()</span><br><span class="line">const <span class="keyword">set</span> = createSetter()</span><br><span class="line"></span><br><span class="line">// 存放目标依赖的 map： target -&gt; depsMap</span><br><span class="line">// 一个目标，有自己的一个 map 存放依赖</span><br><span class="line">const targetMap = new WeakMap()</span><br><span class="line">let activeEffect = &#123;</span><br><span class="line">  _isEffect: <span class="literal">true</span>,</span><br><span class="line">  id: <span class="number">0</span>,</span><br><span class="line">  active: <span class="literal">false</span>,</span><br><span class="line">  raw: <span class="literal">null</span>,</span><br><span class="line">  deps: [],</span><br><span class="line">  options: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toRaw</span>(<span class="params">observed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> reactiveToRaw.get(observed) || observed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是个 activeEffect 类型，那么其执行函数应该是 fn.raw</span></span><br><span class="line">  <span class="keyword">if</span> (fn?._isEffect === <span class="literal">true</span>) &#123;</span><br><span class="line">    fn = fn.raw</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下来要创建一个 effect</span></span><br><span class="line">  <span class="keyword">const</span> _effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_effect.active) &#123;</span><br><span class="line">      <span class="comment">// 非激活状态</span></span><br><span class="line">      <span class="keyword">return</span> options.scheduler ? <span class="literal">undefined</span> : fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(_effect)) &#123;</span><br><span class="line">      <span class="comment">// 如果栈中不包含当前的 effect，即没有注册过该 effect</span></span><br><span class="line">      <span class="comment">// 注册过就不需要重复注册了</span></span><br><span class="line">      <span class="comment">// 添加前先执行清理工作 cleanup -&gt; effect.deps[i].delete(effect)</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        shouldTrack = <span class="literal">true</span></span><br><span class="line">        effectStack.push(_effect)</span><br><span class="line">        activeEffect = _effect</span><br><span class="line">        <span class="keyword">return</span> fn(...args)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// fn 执行异常了，移除对应的 effect</span></span><br><span class="line">        effectStack.pop()</span><br><span class="line">        <span class="keyword">const</span> last = trackStack.pop()</span><br><span class="line">        <span class="comment">// 还原状态值</span></span><br><span class="line">        shouldTrack = last === <span class="literal">undefined</span> ? <span class="literal">true</span> : last</span><br><span class="line">        <span class="comment">// 还原当前激活的 effect</span></span><br><span class="line">        activeEffect = effectStack[effectStack.length - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _effect.id = uid++</span><br><span class="line">  _effect._isEffect = <span class="literal">true</span></span><br><span class="line">  _effect.active = <span class="literal">true</span></span><br><span class="line">  _effect.raw = fn</span><br><span class="line">  _effect.deps = []</span><br><span class="line">  _effect.options = options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    _effect()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _effect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, type, key, newValue, oldValue, oldTarget</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// step1: 检测是否被 track 过，没有根本就没有依赖</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// step2: 将 dep 加入到 effects</span></span><br><span class="line">  <span class="comment">// 创建两个 effects, 一个普通的，一个计算属性</span></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">const</span> computedRunners = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="comment">// 根据 effect 的选项 computed 决定是添加到那个 Set 中</span></span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd</span>) =&gt;</span> &#123;</span><br><span class="line">    effectsToAdd?.forEach(</span><br><span class="line">      (effect) =&gt;</span><br><span class="line">        (effect !== activeEffect || !shouldTrack) &amp;&amp;</span><br><span class="line">        (effect.options.computed</span><br><span class="line">          ? computedRunners.add(effect)</span><br><span class="line">          : effects.add(effect))</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if ... clear</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO 清空动作，触发所有依赖</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数组长度变化</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO 触发更长度变化有关的所有依赖</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 例如： SET | ADD | DELETE 操作</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isAddOrDelete =</span><br><span class="line">      type === <span class="string">'add'</span> || (type === <span class="string">'delete'</span> &amp;&amp; !<span class="built_in">Array</span>.isArray(target))</span><br><span class="line">    <span class="keyword">if</span> (isAddOrDelete || (type === <span class="string">'set'</span> &amp;&amp; target <span class="keyword">instanceof</span> <span class="built_in">Map</span>)) &#123;</span><br><span class="line">      <span class="comment">// 删除或添加操作，或者 map 的设置操作</span></span><br><span class="line">      add(depsMap.get(<span class="built_in">Array</span>.isArray(target) ? <span class="string">'length'</span> : ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map 的添加或删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (isAddOrDelete &amp;&amp; target <span class="keyword">instanceof</span> <span class="built_in">Map</span>) &#123;</span><br><span class="line">      add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// step3: 执行 effects 中所有的 dep</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 选项提供了自己的调度器，执行自己的</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发应该触发的依赖</span></span><br><span class="line">  computedRunners.forEach(run)</span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trackType -&gt; get, has, iterate</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, type, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// ...省略1 检测 shouldTrack 和 activeEffect 标记</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取 target 自己的依赖 map ，如果没有说明是首次，需要给它创建一个</span></span><br><span class="line">  <span class="comment">// 空的集合，这里使用 Map 而不是 WeakMap，为的是强引用，它涉及到</span></span><br><span class="line">  <span class="comment">// 数据的更新触发 UI 渲染，因此不该使用 WeakMap，否则可能会导致依赖丢失问题</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下来对 key 取其依赖</span></span><br><span class="line">  <span class="comment">// 如果属性的依赖不存在，说明该对象是首次使用，需要创建其依赖库</span></span><br><span class="line">  <span class="comment">// 且这里使用了 `Set` 是为了避免重复注册依赖情况，避免数据的更新导致重复触发</span></span><br><span class="line">  <span class="comment">// 同一个 update 情况</span></span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册实际的 update: activeEffect 操作</span></span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect?.deps?.push(dep)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGetter</span>(<span class="params">isReadonly = false, shallow = false</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 很明显这个 proxy handler get, 简化之后...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(...arguments)</span><br><span class="line">    <span class="comment">// ... 省略1，如果是数组，且是 includes, indexOf, lastIndexOf 操作</span></span><br><span class="line">    <span class="comment">// 直接返回它对应的 res</span></span><br><span class="line">    <span class="comment">// ... 省略2，如果是符号属性，直接返回 res</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略3, 浅 reactive，不支持嵌套</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略4，isRef 类型，判断是数组还是对象，数组执行 track(...), 对象返回 res.value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非只读属性，执行 track()，收集依赖</span></span><br><span class="line">    !isReadonly &amp;&amp; track(target, <span class="string">'get'</span>, key)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(res, key, <span class="string">'get...'</span>)</span><br><span class="line">    <span class="comment">// return res</span></span><br><span class="line">    <span class="comment">// 非对象直接返回原结果，如果是对象区分只读与否</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> &amp;&amp; res !== <span class="literal">null</span></span><br><span class="line">      ? isReadonly</span><br><span class="line">        ? <span class="comment">// need to lazy access readonly and reactive here to avoid</span></span><br><span class="line">          <span class="comment">// circular dependency</span></span><br><span class="line">          res <span class="comment">// ... readonly(res)</span></span><br><span class="line">        : reactive(res, toProxy, toRaw, mutableHandlers)</span><br><span class="line">      : res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetter</span>(<span class="params">shallow = false</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 标准的 proxy set</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 取旧值</span></span><br><span class="line">    <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先不管 shallow mode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还记得 reactive 里面的 toRaw啊，对象这里就是取出</span></span><br><span class="line">    <span class="comment">// value 的原始对象 target，前提是它有 reactive() 过</span></span><br><span class="line">    <span class="comment">// 才会被存入到 toRaw: observed -&gt; target 中</span></span><br><span class="line">    <span class="comment">// 暂时简化成： toRaw.get(value)</span></span><br><span class="line">    value = toRaw(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略，ref 检测</span></span><br><span class="line">    <span class="built_in">console</span>.log(target, key, value, reactiveToRaw, <span class="string">'set'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hadKey = <span class="built_in">Object</span>.hasOwnProperty(target, key)</span><br><span class="line">    <span class="comment">// 先执行设置原子操作</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有对象是它自身的时候，才触发 dep-update(排除原型链)</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="comment">// 新增属性操作</span></span><br><span class="line">        trigger(target, <span class="string">'add'</span>, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        <span class="comment">// 值改变操作,排除 NaN !== NaN 情况</span></span><br><span class="line">        trigger(target, <span class="string">'set'</span>, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">  <span class="keyword">get</span>,</span><br><span class="line">  <span class="keyword">set</span></span><br><span class="line">&#125;</span><br><span class="line">// baseHandlers.ts end</span><br><span class="line"></span><br><span class="line">const collectionTypes = new Set([Set, Map, WeakMap, WeakSet])</span><br><span class="line"></span><br><span class="line">function reactive(target, toProxy, toRaw, baseHandlers, collectionHandlers) &#123;</span><br><span class="line">  <span class="comment">// 简化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span>) <span class="keyword">return</span> target</span><br><span class="line"></span><br><span class="line">  <span class="comment">//... isVue, VNode...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> observed = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handlers = collectionTypes.has(target.constructor)</span><br><span class="line">    ? collectionHandlers</span><br><span class="line">    : baseHandlers</span><br><span class="line"></span><br><span class="line">  observed = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handlers)</span><br><span class="line">  toProxy.set(target, observed)</span><br><span class="line">  toRaw.set(observed, target)</span><br><span class="line">  <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = <span class="function">(<span class="params">target</span>) =&gt;</span></span><br><span class="line">  reactive(target, rawToReactive, reactiveToRaw, mutableHandlers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'effect fn'</span>)</span><br><span class="line"><span class="keyword">let</span> res = effect(fn, &#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(res), <span class="string">'after effect'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">let</span> dummy</span><br><span class="line"><span class="keyword">const</span> counter = r(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;)</span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = counter.num))</span><br><span class="line"><span class="built_in">console</span>.log(dummy, counter, <span class="string">'before'</span>)</span><br><span class="line">counter.num = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(dummy, counter, <span class="string">'after'</span>)</span><br></pre></td></tr></table></figure>

<p>核心函数：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>createGetter-&gt;get</code></td>
<td>创建 proxy 的 get handler，里面会调用 track 收集依赖</td>
</tr>
<tr>
<td><code>createSetter-&gt;set</code></td>
<td>创建 proxy 的 set handler，里面会调用 trigger 触发 targetMap&gt;depsMap&gt;dep:Set依赖执行</td>
</tr>
<tr>
<td><code>track(target, type, key)</code></td>
<td>收集 target 对象或 target[key] 属性的依赖</td>
</tr>
<tr>
<td><code>trigger(target, type, key?, newValue?, oldValue?, oldTarget?)</code></td>
<td>触发 target 对象的依赖调用</td>
</tr>
<tr>
<td><code>effect(fn, options)</code></td>
<td>注册reactive属性的updater</td>
</tr>
</tbody></table>
<p>涉及到的核心属性：</p>
<p>ReactiveEffect 类型定义：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ReactiveEffect&lt;T = any&gt; &#123;</span><br><span class="line">  (...args: <span class="built_in">any</span>[]): T</span><br><span class="line">  _isEffect: <span class="literal">true</span></span><br><span class="line">  id: <span class="built_in">number</span></span><br><span class="line">  active: <span class="built_in">boolean</span></span><br><span class="line">  raw: <span class="function"><span class="params">()</span> =&gt;</span> T</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;</span><br><span class="line">  options: ReactiveEffectOptions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>activeEffect</code></td>
<td><code>ReactiveEffect</code></td>
<td>记录当前的 effect，在 <code>effect()</code>注册updater的时候置为当前的 RE，在 <code>get-&gt;track</code> 里面添加到 targetMap-&gt;depsMap-&gt;dep 中，且同时更新自己的 <code>activeEffect.deps.push(dep)</code></td>
</tr>
<tr>
<td><code>effectStack</code></td>
<td><code>Array&lt;ReactiveEffect&gt;</code></td>
<td>存放所有的 <code>ReactiveEffect</code> 的数组，也就是说页面中所有的 <code>updater&lt;ReactiveEffect&gt;</code> 都是存在这里面。但是每个 updater 执行完之后就会被移出 <code>effectStack</code>，因为 <code>efffect()</code>调用里面有个 <code>try...finally</code> 无论结果如何都会被 pop 掉。</td>
</tr>
<tr>
<td><code>shouldTrack</code></td>
<td><code>Boolean</code></td>
<td>用来追踪当前 effect-&gt;activeEffect 的状态</td>
</tr>
<tr>
<td><code>trackStack</code></td>
<td><code>Array&lt;Boolean&gt;</code></td>
<td>用来存放当前 effect 的 shouldTrack 状态值</td>
</tr>
<tr>
<td><code>targetMap</code></td>
<td><code>WeakMap</code></td>
<td>存放被 reactive 对象依赖的 Map，即：每个 target 在 targetMap 里面有自己的一个 depsMap，里面以 target =&gt; &lt;key, Set&gt; 形式存在，key 表示 target 上的一个属性键，Set 存放了该 key 的所有依赖 dep。<img src="http://qiniu.ii6g.com/1589709260.png?imageMogr2/thumbnail/!100p" alt="">层级关系：targetMap:WeakMap -&gt; depsMap:Map -&gt; dep:Set</td>
</tr>
<tr>
<td><code>depsMap</code></td>
<td><code>Map</code></td>
<td>target 对象里所有属性和其依赖对应的关系集合，如：counter.num 的依赖： <code>{ &quot;num&quot; =&gt; Set(1) }</code></td>
</tr>
<tr>
<td><code>reactiveToRaw</code></td>
<td><code>WeakMap</code></td>
<td>作为 reactive 的第三个参数 toRaw，保存了 observed-&gt;target 关系的 WeakMap。</td>
</tr>
<tr>
<td><code>rawToReactive</code></td>
<td><code>WeakMap</code></td>
<td>作为 reactive 的第二个参数 toProxy，保存了 target-&gt;observed 关系的 WeakMap，和 <code>reactiveToRaw</code> 刚好相反。</td>
</tr>
<tr>
<td><code>uid</code></td>
<td><code>Number</code></td>
<td>每个 effect 都有一个唯一的 id，一直递增。</td>
</tr>
</tbody></table>
<h1 id="支持数组-reactive"><a href="#支持数组-reactive" class="headerlink" title="支持数组 reactive"></a>支持数组 reactive</h1><p>在这之前都是在对象基础上做的测试，并没有增加数组的支持，比如：jest(所有测试用例都来自官方仓库) -&gt;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'嵌套的 reactives'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> original = &#123;</span><br><span class="line">      nested: &#123;</span><br><span class="line">        foo: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      array: [&#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> observed = reactive(original)</span><br><span class="line">    expect(isReactive(observed.nested)).toBe(<span class="literal">true</span>)</span><br><span class="line">    expect(isReactive(observed.array)).toBe(<span class="literal">true</span>)</span><br><span class="line">    expect(isReactive(observed.array[<span class="number">0</span>])).toBe(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="http://qiniu.ii6g.com/1589852337.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>也就是说做到现在，并不支持数组的 reactive，这也是这节将要完善的点。</p>
<ol>
<li><p>数组三个方法(<code>includes, indexOf, lastIndexOf</code>)的依赖收集：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组三个方法的处理</span></span><br><span class="line"><span class="keyword">const</span> arrayInstrumentations = &#123;&#125;</span><br><span class="line"><span class="comment">// 兼容数组三个索引方法，收集他们相关的依赖</span></span><br><span class="line">;[<span class="string">'includes'</span>, <span class="string">'indexOf'</span>, <span class="string">'lastIndexOf'</span>].forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  arrayInstrumentations[key] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arra = toRaw(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">      track(arr, <span class="string">'get'</span>, i + <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原始方法执行一次(有可能是 reactive 的)</span></span><br><span class="line">    <span class="keyword">const</span> res = arr[key](...args)</span><br><span class="line">    <span class="keyword">if</span> (res === <span class="number">-1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果结果失败，使用原始方法再执行一次</span></span><br><span class="line">      <span class="keyword">return</span> arr[key](...args.map(toRaw))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>createGetter -&gt; get</code> 的时候增加数组支持：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGetter</span>(<span class="params">isReadonly = false, shallow = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> targetIsArray = <span class="built_in">Array</span>.isArray(target)</span><br><span class="line">    <span class="keyword">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经可以正常收集到数组的依赖了，测试代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123; reactive, effect, targetMap &#125; <span class="keyword">from</span> <span class="string">'./packages/reactive.js'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> n</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> arr = [<span class="string">'vue'</span>, <span class="string">'reactive'</span>]</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> observed = reactive(arr)</span></span><br><span class="line"><span class="javascript">    effect(<span class="function"><span class="params">()</span> =&gt;</span> (n = observed[<span class="number">0</span>]))</span></span><br><span class="line"><span class="actionscript">  	<span class="comment">// 这里还可以添加多个依赖，比如：effect(() =&gt; (m = observed[0]))</span></span></span><br><span class="line"><span class="actionscript">  	<span class="comment">// 这样，targetMap&gt;depsMap:arr&gt;dep 里面就会有两个了 [f, f]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(&#123;n, targetMap&#125;)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>![image-20200519095740412](/Users/simon/Library/Application Support/typora-user-images/image-20200519095740412.png)</p>
<ul>
<li><code>effect(() =&gt; (n = observed[0]))</code>会执行一次 <code>fn</code> ，即取了一次数组的 <code>0</code> 下标值，触发了 <code>get</code></li>
<li>检测到是数组进入数组依赖收集程序<code>arrayInstrumentations</code> ，触发 <code>track</code> 收集依赖</li>
</ul>
<p>🙆‍♂️，依赖咱收集到了，第三步就是如何去触发它们了 &gt;&gt;&gt;&gt;</p>
</li>
<li><p>数组的 set-&gt;trigger 实际上已经支持了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 触发 updater</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, type, key, newValue, oldValue, oldTarget</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'clear'</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'length'</span> &amp;&amp; <span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是数组，传入 key 是索引值，会进入这个 if 进行依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 对象属性 deps</span></span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以下面的示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123; reactive, effect, targetMap &#125; <span class="keyword">from</span> <span class="string">'./packages/reactive.js'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> n, m</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> arr = [<span class="string">'vue'</span>, <span class="string">'reactive'</span>]</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> observed = reactive(arr)</span></span><br><span class="line"><span class="javascript">    effect(<span class="function"><span class="params">()</span> =&gt;</span> (n = observed[<span class="number">0</span>]))</span></span><br><span class="line"><span class="javascript">    effect(<span class="function"><span class="params">()</span> =&gt;</span> (m = observed[<span class="number">0</span>]))</span></span><br><span class="line"><span class="actionscript">    observed[<span class="number">0</span>] = <span class="string">'setter n'</span></span></span><br><span class="line"><span class="actionscript">    observed[<span class="number">1</span>] = <span class="string">'setter m'</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(&#123;n, m, targetMap&#125;)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果(set 数组元素值的时候出发了 dep 更新 n, m 的值)：</p>
</li>
</ol>
<p><img src="http://qiniu.ii6g.com/1589858380.png?imageMogr2/thumbnail/!100p" alt=""></p>
<ol start="4">
<li><p>最后 jest 测试结果(失败…):<br>原因是之前的 <code>createGetter</code>代码又有个问题，返回的时候检测结果的时候，递归 reactive 传递了 target，应该是 res 才对：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> res &amp;&amp; <span class="keyword">typeof</span> res === <span class="string">'object'</span></span><br><span class="line">      ? isReadonly</span><br><span class="line">        ? readonly(target) <span class="comment">// 修正：target -&gt; res</span></span><br><span class="line">        : reactive(target) <span class="comment">// 修正：target -&gt; res</span></span><br><span class="line">      : res</span><br></pre></td></tr></table></figure>

<p>修正之后 jest 结果(:perfect)：</p>
<blockquote>
<p>☁  vue-next-code-read [master] ⚡  jest<br>PASS  packages/<strong>tests</strong>/reactive/reactive.spec.js<br> reactivity/reactive<br>   ✓ Object (4 ms)<br>   ✓ 嵌套的 reactives (1 ms)</p>
<p>Test Suites: 1 passed, 1 total<br>Tests:       2 passed, 2 total<br>Snapshots:   0 total<br>Time:        7.547 s<br>Ran all test suites.<br>☁  vue-next-code-read [master] ⚡</p>
</blockquote>
</li>
</ol>
<p>OK，数组的 reactive 完成。</p>
<hr>
<h2 id="jest-测试："><a href="#jest-测试：" class="headerlink" title="jest 测试："></a>jest 测试：</h2><blockquote>
<p>☁  vue-next-code-read [master] ⚡  jest<br>FAIL  packages/<strong>tests</strong>/reactive/reactive.spec.js<br> reactivity/reactive<br>   ✓ Object (5 ms)<br>   ✓ 嵌套的 reactives (1 ms)<br>   ✓ observed value should proxy mutations to original (Object) (1 ms)<br>   ✓ setting a property with an unobserved value should wrap with reactive (1 ms)<br>   ✕ observing already observed value should return same Proxy (4 ms)<br>   ✕ should not pollute original object with Proxies (2 ms)<br>   ✕ unwrap<br>   ✓ should not unwrap Ref<T><br>   ✓ should unwrap computed refs<br>   ✕ non-observable values (36 ms)<br>   ✕ markRaw<br>   ✕ should not observe frozen objects (1 ms)<br>   shallowReactive<br>     ✕ should not make non-reactive properties reactive<br>     ✕ should keep reactive properties reactive</p>
</blockquote>
<ol>
<li><p><font color="red">✕ observing already observed value should return same Proxy (4 ms)</font><br>这个是因为 <code>createReactiveObject()</code>里面判断的时候判断错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (toRaw.has(observed)) &#123; <span class="comment">// 修正成：target</span></span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后测试通过。</p>
</li>
<li><p><font color="red">✕ should not pollute original object with Proxies (5 ms)</font><br>修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetter</span>(<span class="params">shallow = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 新增判断，如果是递归 reactive 设置的时候取原始值去传递给 reflect</span></span><br><span class="line">    <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">      <span class="comment">// 比如：value 如果是 Observed，那么从 reactiveToRaw 中取 proxy </span></span><br><span class="line">      <span class="comment">// 之前的那个 target 出来，给 reflect</span></span><br><span class="line">      value = toRaw(value)</span><br><span class="line">      <span class="comment">// TODO !shallow is ref</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const res = Reflect.set(...arguments)</span></span><br><span class="line">    <span class="comment">// 这里就不能直接 ...arguments 了，都将最新的 value 传递下去</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后测试通过。</p>
</li>
<li><p><font color="red">✕ unwrap</font><br>是因为没有导出 <code>toRaw</code> 函数导致的，导入下就好了。</p>
</li>
<li><p><font color="red">✕ non-observable values (8 ms)</font><br>需要改些下测试用例：源码里面加了 expect -&gt; toHaveBeenWarnedLast 为了更友好的提示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 修改后：</span></span><br><span class="line">expect(reactive(<span class="number">1</span>)).toBe(<span class="number">1</span>)</span><br><span class="line">expect(reactive(<span class="string">'foo'</span>)).toBe(<span class="string">'foo'</span>)</span><br><span class="line">expect(reactive(<span class="literal">false</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">expect(reactive(<span class="literal">null</span>)).toBe(<span class="literal">null</span>)</span><br><span class="line">expect(reactive(<span class="literal">undefined</span>)).toBe(<span class="literal">undefined</span>)</span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>()</span><br><span class="line">expect(reactive(s)).toBe(s)</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="red"> ✕ markRaw</font><br>在 <code>createReactiveObject()</code> 中增加 <code>canObserve(target)</code> 检测解决，因为检测中就有一项 <code>rawValues.has(value)</code></p>
</li>
<li><p><font color="red">✕ should not observe frozen objects (1 ms)</font><br>在 <code>createReactiveObject()</code> 中增加 <code>canObserve(target)</code> 检测解决。</p>
</li>
<li><p><font color="red">✕ should not make non-reactive properties reactive</font><br>没导出 <code>shallowReactive</code>。</p>
</li>
<li><p><font color="red">✕ should keep reactive properties reactive</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 粗心的锅，这个写反了</span></span><br><span class="line"><span class="keyword">const</span> shallowSet = createGetter(<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> shallowGet = createSetter(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正：</span></span><br><span class="line"><span class="keyword">const</span> shallowSet = createSetter(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> shallowGet = createSetter(<span class="literal">false</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>修正上述问题之后 jest 结果：</p>
<blockquote>
<p>vue-next-code-read [master] ⚡  jest<br>PASS  packages/<strong>tests</strong>/reactive/reactive.spec.js<br> reactivity/reactive<br>   ✓ Object (6 ms)<br>   ✓ 嵌套的 reactives<br>   ✓ observed value should proxy mutations to original (Object) (1 ms)<br>   ✓ setting a property with an unobserved value should wrap with reactive (1 ms)<br>   ✓ observing already observed value should return same Proxy<br>   ✓ should not pollute original object with Proxies (1 ms)<br>   ✓ unwrap<br>   ✓ should not unwrap Ref<T> (1 ms)<br>   ✓ should unwrap computed refs<br>   ✓ non-observable values (2 ms)<br>   ✓ markRaw (1 ms)<br>   ✓ should not observe frozen objects (1 ms)<br>   shallowReactive<br>     ✓ should not make non-reactive properties reactive<br>     ✓ should keep reactive properties reactive</p>
<p>Test Suites: 1 passed, 1 total<br>Tests:       14 passed, 14 total<br>Snapshots:   0 total<br>Time:        6.436 s<br>Ran all test suites.</p>
</blockquote>
<p><span id="code1">阶段代码链接 <a href="https://github.com/gcclll/vue-next-code-read/blob/master/bakups/reactive_with_array.js" target="_blank" rel="noopener">reactive_with_array.js</a>  代码</span></p>
<h1 id="handlers续-baseHandlers-的-delete-has-ownKeys"><a href="#handlers续-baseHandlers-的-delete-has-ownKeys" class="headerlink" title="handlers续(baseHandlers 的 delete, has, ownKeys)"></a>handlers续(baseHandlers 的 delete, has, ownKeys)</h1><p>前面完成了 <code>proxy-set</code> 和 <code>proxy-get</code>，这节继续完成其他的 <code>proxy</code>，包含：</p>
<ol>
<li><code>deleteProperty(target, key)</code></li>
<li><code>ownKeys(target)</code></li>
<li><code>has(target, key)</code></li>
</ol>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>在之前实现的基础上 <a href="https://github.com/gcclll/vue-next-code-read/blob/master/bakups/reactive_with_array.js" target="_blank" rel="noopener">reactive.js</a> 增加 delete proxy，这之前先来看下现有的功能是否支持 delete 操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> n = reactive(target)</span><br><span class="line"><span class="keyword">let</span> dum</span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'updating...'</span>)</span><br><span class="line">dum = n.bar</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* console.log(targetMap.get(target), dum, 'map') */</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; dum &#125;, <span class="string">'before'</span>)</span><br><span class="line"><span class="keyword">delete</span> n.bar  <span class="comment">// code 1</span></span><br><span class="line"><span class="comment">// n.bar = 3 // code2</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; dum &#125;, <span class="string">'after'</span>)</span><br></pre></td></tr></table></figure>

<p>这里先注册一个 updater，后面通过更新 <code>n.bar</code> 值，来触发 updater，结果：</p>
<blockquote>
<p>updating…<br>{dum: 2} “before”<br>updating…<br>{dum: 3} “after”</p>
</blockquote>
<p>结果如我们所料，然后把 code1 放开，注释掉 code2，理论上也会触发 updater：</p>
<blockquote>
<p>updating…<br>{dum: 2} “before”<br>{dum: 2} “after”</p>
</blockquote>
<p>实际结果非我们所料，因为还没实现……</p>
<p>接下来看下要实现 delete proxy 需要哪些步骤 &gt;&gt;&gt;&gt;&gt;&gt;</p>
<ol>
<li><p>声明  delete proxy handler : <code>deleteProperty</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delete proxy</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteProperty</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hadKey = target.hasOwnProperty(key)</span><br><span class="line">  <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line">  <span class="comment">// 操作先执行下去</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.deleteProperty(target, key)</span><br><span class="line">  <span class="comment">// 如果执行成功且自身存在该属性，排除原型链操作</span></span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) &#123;</span><br><span class="line">    <span class="comment">// 直接触发 updaters</span></span><br><span class="line">    trigger(target, <span class="string">'delete'</span>, key, <span class="literal">undefined</span>, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result <span class="comment">// 不能丢，必须反馈删除结果 boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加入到<code>mutableHandlers</code> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">  <span class="keyword">get</span>,</span><br><span class="line">  <span class="keyword">set</span>,</span><br><span class="line">  deleteProperty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>只要经过上面简单的两步就实现了 <code>delete</code> 操作代理，但执行结果却报错了(明明和源码一样啊，悲催〒▽〒!!!)</p>
<p><img src="http://qiniu.ii6g.com/1590046965.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>从输出可以看到， delete 操作确实触发了 updater，最后 <code>dum: undefined</code> 也证明了这点。</p>
<p>至于报错…，(⊙o⊙)…，(⊙o⊙)…，少了个 <code>return result</code> 将删除操作结果返回。</p>
<h2 id="has"><a href="#has" class="headerlink" title="has"></a>has</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">has</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.has(target, key)</span><br><span class="line">  track(target, <span class="string">'has'</span>, key)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新 mutableHandlers:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">  <span class="keyword">get</span>,</span><br><span class="line">  <span class="keyword">set</span>,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> n = reactive(target)</span><br><span class="line"><span class="keyword">let</span> dum, has</span><br><span class="line"><span class="keyword">const</span> updater = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'updating...'</span>)</span><br><span class="line">  dum = <span class="string">'bar'</span> <span class="keyword">in</span> n</span><br><span class="line">&#125;</span><br><span class="line">effect(updater)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dep = targetMap.get(target).get(<span class="string">'bar'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> dep) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn.raw, fn.raw === updater, <span class="string">'deps'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(&#123; dum &#125;, <span class="string">'before'</span>)</span><br><span class="line">n.bar = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; dum &#125;, <span class="string">'after'</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<ol>
<li><code>&#39;bar&#39; in n</code> 收集依赖 <code>updater</code></li>
<li><code>n.bar = 3</code> 触发 <code>ownKeys</code> 收集到的 <code>updater</code></li>
</ol>
<blockquote>
<p>updating…<br>() =&gt; {<br>       console.log(‘updating…’)<br>       dum = ‘bar’ in n<br>     } true “deps”<br>{dum: true} “before”<br>updating…<br>{dum: true} “after”</p>
</blockquote>
<h2 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ownKeys</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  track(target, <span class="string">'iterate'</span>, ITERATE_KEY)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新 mutableHandlers:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">  <span class="keyword">get</span>,</span><br><span class="line">  <span class="keyword">set</span>,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>ownKeys</code> 的实现里使用到 了一个 Symbol: ITERATE_KEY，开始一直不明白 <code>trigger</code> 里为啥会用到这个去 <code>depsMap.get(ITERRATE_KEY)</code>，这里应该明白是怎么回事了，就是针对对象的迭代器操作的时候，使用到 <code>ownKeys</code>，需要对该操作收集依赖，那么就需要有个唯一的 key 去设置 <code>targetMap, depsMap</code>，这里的 <code>ITERATE_KEY</code> 就是这个作用，用它来收集(track)对象迭代操作的所有依赖，然后通过 trigger 里面查找这个符号值去取所有 updaters。</p>
<p>测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> n = reactive(target)</span><br><span class="line"><span class="keyword">let</span> dum, has</span><br><span class="line"><span class="keyword">const</span> updater = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'updating...'</span>)</span><br><span class="line">  dum = <span class="built_in">Object</span>.keys(n) <span class="comment">// 触发依赖收集</span></span><br><span class="line">&#125;</span><br><span class="line">effect(updater)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dep = targetMap.get(target).get(ITERATE_KEY)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">of</span> dep) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(it.raw, it.raw === updater, <span class="string">'deps'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dum, <span class="string">'before'</span>)</span><br><span class="line">n.bar = <span class="number">3</span> <span class="comment">// 触发 updaters</span></span><br><span class="line"><span class="built_in">console</span>.log(dum, <span class="string">'after'</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>updating…<br>{foo: 1, bar: 2} “own keys”<br>() =&gt; {<br>       console.log(‘updating…’)<br>       dum = Object.keys(n)<br>     } true “deps”<br>(2) [“foo”, “bar”] “before”<br>(2) [“foo”, “bar”] “after”</p>
</blockquote>
<p>但是发现并没有触发 updaters。</p>
<p>trigger 里面加打印结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非数组的删除或添加操作</span></span><br><span class="line"><span class="keyword">const</span> isAddOrDelete =</span><br><span class="line">      type === <span class="string">'add'</span> || (type === <span class="string">'delete'</span> &amp;&amp; !<span class="built_in">Array</span>.isArray(target))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123; type, key &#125;, target <span class="keyword">instanceof</span> <span class="built_in">Map</span>)</span><br><span class="line"><span class="comment">// 对象的属性的新增和删除，或者 Map 类型的 set 操作</span></span><br><span class="line"><span class="keyword">if</span> (isAddOrDelete || (type === <span class="string">'set'</span> &amp;&amp; target <span class="keyword">instanceof</span> <span class="built_in">Map</span>)) &#123;</span><br><span class="line">  add(depsMap.get(<span class="built_in">Array</span>.isArray(target) ? <span class="string">'length'</span> : ITERATE_KEY))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 <code>{type: &quot;set&quot;, key: &quot;foo&quot;} false</code> 说明确实有触发 <code>trigger</code>，但是条件：</p>
<p><code>if (isAddOrDelete || (type === &#39;set&#39; &amp;&amp; target instanceof Map))</code></p>
<p>阻止了它进入 <code>add</code> 收集 <code>ITERATE_KEY</code> 对应的依赖，因为 target 不是 Map 类型。</p>
<p><strong>TODO 为啥会这样？？？？？？？</strong></p>
<h2 id="jest-测试"><a href="#jest-测试" class="headerlink" title="jest 测试"></a>jest 测试</h2><blockquote>
<p>☁  vue-next-code-read [master] ⚡  jest<br>PASS  packages/<strong>tests</strong>/reactive/reactive.spec.js<br>FAIL  packages/<strong>tests</strong>/reactive/effect.spec.js<br> ● reactivity/effect › should observe iteration</p>
<p>   expect(received).toBe(expected) // Object.is equality</p>
<p>   Expected: “Hello World!”<br>   Received: “Hello”</p>
<pre><code>161 |     expect(dummy).toBe(&apos;Hello&apos;)
162 |     list.push(&apos;World!&apos;)</code></pre><blockquote>
<p>163 |     expect(dummy).toBe(‘Hello World!’)<br>         |                   ^<br>     164 |     list.shift()<br>     165 |     expect(dummy).toBe(‘World!’)<br>     166 |   })</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:163:19)</code></pre><p> ● reactivity/effect › should observe implicit array length changes</p>
<p>   expect(received).toBe(expected) // Object.is equality</p>
<p>   Expected: “Hello World!”<br>   Received: “Hello”</p>
<pre><code>173 |     expect(dummy).toBe(&apos;Hello&apos;)
174 |     list[1] = &apos;World!&apos;</code></pre><blockquote>
<p>175 |     expect(dummy).toBe(‘Hello World!’)<br>         |                   ^<br>     176 |     list[3] = ‘Hello!’<br>     177 |     expect(dummy).toBe(‘Hello World!  Hello!’)<br>     178 |   })</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:175:19)</code></pre><p> ● reactivity/effect › should observe enumeration</p>
<p>   expect(received).toBe(expected) // Object.is equality</p>
<p>   Expected: 7<br>   Received: 3</p>
<pre><code>203 |     expect(dummy).toBe(3)
204 |     numbers.num2 = 4</code></pre><blockquote>
<p>205 |     expect(dummy).toBe(7)<br>         |                   ^<br>     206 |     delete numbers.num1<br>     207 |     expect(dummy).toBe(4)<br>     208 |   })</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:205:19)</code></pre><p> ● reactivity/effect › should not observe well-known symbol keyed properties</p>
<p>   expect(received).toBe(expected) // Object.is equality</p>
<p>   Expected: undefined<br>   Received: true</p>
<pre><code>234 |     array[key] = true
235 |     expect(array[key]).toBe(true)</code></pre><blockquote>
<p>236 |     expect(dummy).toBe(undefined)<br>         |                   ^<br>     237 |   })<br>     238 |<br>     239 |   it(‘should observe function valued properties’, () =&gt; {</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:236:19)</code></pre><p> ● reactivity/effect › should observe json methods</p>
<p>   expect(received).toBe(expected) // Object.is equality</p>
<p>   Expected: 1<br>   Received: undefined</p>
<pre><code>523 |     })
524 |     obj.a = 1</code></pre><blockquote>
<p>525 |     expect(dummy.a).toBe(1)<br>         |                     ^<br>     526 |   })<br>     527 |<br>     528 |   it(‘should observe class method invocations’, () =&gt; {</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:525:21)</code></pre><p> ● reactivity/effect › scheduler</p>
<p>   expect(jest.fn()).toHaveBeenCalledTimes(expected)</p>
<p>   Expected number of calls: 1<br>   Received number of calls: 0</p>
<pre><code>573 |     // should be called on first trigger
574 |     obj.foo++</code></pre><blockquote>
<p>575 |     expect(scheduler).toHaveBeenCalledTimes(1)<br>         |                       ^<br>     576 |     // should not run yet<br>     577 |     expect(dummy).toBe(1)<br>     578 |     // manually run</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:575:23)</code></pre><p> ● reactivity/effect › events: onTrack</p>
<p>   expect(jest.fn()).toHaveBeenCalledTimes(expected)</p>
<p>   Expected number of calls: 3<br>   Received number of calls: 0</p>
<pre><code>598 |     )
599 |     expect(dummy).toEqual([&apos;foo&apos;, &apos;bar&apos;])</code></pre><blockquote>
<p>600 |     expect(onTrack).toHaveBeenCalledTimes(3)<br>         |                     ^<br>     601 |     expect(events).toEqual([<br>     602 |       {<br>     603 |         effect: runner,</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:600:21)</code></pre><p> ● reactivity/effect › events: onTrigger</p>
<p>   expect(jest.fn()).toHaveBeenCalledTimes(expected)</p>
<p>   Expected number of calls: 1<br>   Received number of calls: 0</p>
<pre><code>637 |     obj.foo++
638 |     expect(dummy).toBe(2)</code></pre><blockquote>
<p>639 |     expect(onTrigger).toHaveBeenCalledTimes(1)<br>         |                       ^<br>     640 |     expect(events[0]).toEqual({<br>     641 |       effect: runner,<br>     642 |       target: toRaw(obj),</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:639:23)</code></pre><p> ● reactivity/effect › stop</p>
<p>   TypeError: (0 , _reactive2.stop) is not a function</p>
<pre><code>667 |     obj.prop = 2
668 |     expect(dummy).toBe(2)</code></pre><blockquote>
<p>669 |     stop(runner)<br>         |     ^<br>     670 |     obj.prop = 3<br>     671 |     expect(dummy).toBe(2)<br>     672 |</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:669:5)</code></pre><p> ● reactivity/effect › stop with scheduler</p>
<p>   expect(received).toBe(expected) // Object.is equality</p>
<p>   Expected: 1<br>   Received: 2</p>
<pre><code>689 |     )
690 |     obj.prop = 2</code></pre><blockquote>
<p>691 |     expect(dummy).toBe(1)<br>         |                   ^<br>     692 |     expect(queue.length).toBe(1)<br>     693 |     stop(runner)<br>     694 |</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:691:19)</code></pre><p> ● reactivity/effect › events: onStop</p>
<p>   TypeError: (0 , _reactive2.stop) is not a function</p>
<pre><code>704 |     })
705 |</code></pre><blockquote>
<p>706 |     stop(runner)<br>         |     ^<br>     707 |     expect(onStop).toHaveBeenCalled()<br>     708 |   })<br>     709 |</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:706:5)</code></pre><p> ● reactivity/effect › stop: a stopped effect is nested in a normal effect</p>
<p>   TypeError: (0 , _reactive2.stop) is not a function</p>
<pre><code>714 |       dummy = obj.prop
715 |     })</code></pre><blockquote>
<p>716 |     stop(runner)<br>         |     ^<br>     717 |     obj.prop = 2<br>     718 |     expect(dummy).toBe(1)<br>     719 |</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:716:5)</code></pre><p> ● reactivity/effect › should trigger all effects when array length is set 0</p>
<p>   expect(received).toBe(expected) // Object.is equality</p>
<p>   Expected: 3<br>   Received: 1</p>
<pre><code>773 |
774 |     observed.unshift(3)</code></pre><blockquote>
<p>775 |     expect(dummy).toBe(3)<br>         |                   ^<br>     776 |     expect(record).toBe(3)<br>     777 |<br>     778 |     observed.length = 0</p>
</blockquote>
<pre><code>at Object.&lt;anonymous&gt; (packages/__tests__/reactive/effect.spec.js:775:19)</code></pre><p>Test Suites: 1 failed, 1 passed, 2 total<br>Tests:       13 failed, 49 passed, 62 total<br>Snapshots:   0 total<br>Time:        2.917 s, estimated 3 s<br>Ran all test suites.</p>
</blockquote>
<p>全是失败啊！！！</p>
<p>还是老老实实的一个个来解决吧……</p>
<ol>
<li><p><font color="red">● reactivity/effect › should observe iteration</font></p>
<p>数组操作失败，push 的时候没有触发 updater。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = reactive([<span class="string">'Hello'</span>])</span><br><span class="line"><span class="keyword">let</span> dummy</span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'updating....'</span>)</span><br><span class="line">  dummy = list.join(<span class="string">' '</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(targetMap, <span class="string">'dep'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(dummy, <span class="string">'1'</span>)</span><br><span class="line">list[<span class="number">0</span>] = <span class="string">'hello'</span></span><br><span class="line"><span class="comment">/* list.push('World!') */</span></span><br><span class="line"><span class="built_in">console</span>.log(dummy, <span class="string">'2'</span>)</span><br></pre></td></tr></table></figure>

<p>结果(直接索引赋值是生效的，那么为啥 push 没用？？？)：</p>
<blockquote>
<p>updating….<br>test.html:20 WeakMap {Array(1) =&gt; Map(3)} “dep”<br>test.html:21 Hello 1<br>test.html:17 updating….<br>test.html:24 hello 2</p>
</blockquote>
<p>在 <code>list.push(&#39;World!&#39;)</code> 处打个断点：</p>
<p>先触发的是<code>list</code> 的 get push :</p>
<p><img src="http://qiniu.ii6g.com/1590068611.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>然后再是触发的 length get</p>
<p><img src="http://qiniu.ii6g.com/1590068464.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>触发 key: 1 的 updater，但最后没有任何依赖被发现？？？</p>
<p><img src="http://qiniu.ii6g.com/1590068984.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p><img src="http://qiniu.ii6g.com/1590069039.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>看最后的图发现问题，首先，数组就一个元素，长度为1，最大索引为0，在 push 之后，长度为2，最大索引为1，也就是说这个新的索引即新的 key，属于新增属性操作，应该要走到 trigger:add ，但是实际走了 trigger:set 里面去了。</p>
<p>问题就在 <code>if(!target.hasOwnProperty(key))</code> 这一行，它不应该取 <code>Reflect.set(...)</code> 之后的 target 因为这是更新之后的，肯定有 key: 1了。</p>
<p>修改： </p>
<p>在 <code>Reflect.set(...)</code> 之前先 <code>hadKey = target.hasOwnProperty(key)</code> 然后使用缓存的 <code>hadKey</code> 进行判断 <code>if(!hadKey) {...}</code>。</p>
<p>修改之后测试通过：</p>
<blockquote>
<p>☁  vue-next-code-read [master] ⚡  jest<br>PASS  packages/<strong>tests</strong>/reactive/reactive.spec.js<br>PASS  packages/<strong>tests</strong>/reactive/effect.spec.js</p>
<p>Test Suites: 2 passed, 2 total<br>Tests:       26 passed, 26 total<br>Snapshots:   0 total<br>Time:        7.645 s<br>Ran all test suites.</p>
</blockquote>
</li>
<li><p><font color="red">● reactivity/effect › should not observe well-known symbol keyed properties</font></p>
<p>js 内置的符号属性，不能被 observe，这是因为 <code>createGetter</code> 里面还没完成 <code>Symbol</code> 类型的检测，下面加上就OK了。</p>
<p>需要增加以下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 符号类型检测</span></span><br><span class="line"><span class="keyword">const</span> isSymbol = <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="keyword">typeof</span> val === <span class="string">'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Symbol 上的所有符号属性</span></span><br><span class="line"><span class="keyword">const</span> builtInSymbols = <span class="keyword">new</span> <span class="built_in">Set</span>(</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Symbol</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">key</span> =&gt;</span> (<span class="built_in">Symbol</span>)[key])</span><br><span class="line">    .filter(isSymbol)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. createGetter中增加判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGetter</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isSymbol(key) &amp;&amp; builtInSymbols.has(key) || key === <span class="string">'__proto__'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重测 jest 通过。</p>
</li>
<li><p><font color="red">● reactivity/effect › scheduler</font><br>真怀疑当时自己是故意的，尽是些地级错误（捂脸，🤦‍♀️，(<em>/ω＼</em>)）！！！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前：</span></span><br><span class="line"><span class="comment">// if (effect.options &amp;&amp; effect.options.shecduler) &#123;</span></span><br><span class="line"><span class="comment">// 修改后：</span></span><br><span class="line"><span class="keyword">if</span> (effect.options &amp;&amp; effect.options.scheduler) &#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="red">● reactivity/effect › events: onTrack</font></p>
</li>
<li><p><font color="red">● reactivity/effect › events: onTrigger</font></p>
<p>两个是在 <strong>DEV</strong> 模式下才会执行的，没有完成，现在给加上去吧。</p>
<p>Track 里面，在 if dep.has 最后面增加统计事件 onTrack：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, type, key</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        effect: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        type,</span><br><span class="line">        key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Trigger 里面，在执行 updaters 的开头增加 onTrigger 事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, type, key, newValue, oldValue, oldTarget</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> hasOpt = !!effect.options</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; hasOpt &amp;&amp; effect.options.onTrigger) &#123;</span><br><span class="line">      effect.options.onTrigger(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        type,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加完，jest 通过。</p>
</li>
<li><p><font color="red">● stop</font><br>增加 stop 函数，停止 effect 行为，主要通过 effect.active，清理 effect.deps 来控制，阻止触发 deps。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stop</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (effect.active) &#123;</span><br><span class="line">    cleanup(effect)</span><br><span class="line">    <span class="keyword">if</span> (effect.options &amp;&amp; effect.options.onStop) &#123;</span><br><span class="line">      effect.options.onStop()</span><br><span class="line">    &#125;</span><br><span class="line">    effect.active = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>到此 <code>effect.spec.ts</code> 中除了 <code>ref</code> 有关的测试用例全部测试通过，</p>
<p><img src="http://qiniu.ii6g.com/1590139513.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>下面来逐个分析 &gt;&gt;&gt; go go go…</p>
<h3 id="逐个分析用例"><a href="#逐个分析用例" class="headerlink" title="逐个分析用例"></a>逐个分析用例</h3><p>通过运行 <code>jest --verbose</code> 将所有用例测试结果列出：</p>
<ul>
<li><p><font color="green">✓ should run the passed function once (wrapped by a effect) (4 ms)</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should run the passed function once (wrapped by a effect)'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fnSpy = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    effect(fnSpy) <span class="comment">// effect() 实现里面，如果没有传 options.lazy 就会立即执行一次</span></span><br><span class="line">    expect(fnSpy).toHaveBeenCalledTimes(<span class="number">1</span>) <span class="comment">// 因此这里 fnSpy 会被调用一次</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="green">✓ should observe basic properties (1 ms)</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should observe basic properties'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dummy</span><br><span class="line">    <span class="keyword">const</span> counter = reactive(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    <span class="comment">// updater: dummy = counter.num</span></span><br><span class="line">    <span class="comment">// 被立即调用， dummy = 0</span></span><br><span class="line">    <span class="comment">// 由于 counter.num 触发 trigger:get ，收集dep: 'num'-&gt;Set(1): updater</span></span><br><span class="line">    effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = counter.num)) </span><br><span class="line"></span><br><span class="line">    expect(dummy).toBe(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">    counter.num = <span class="number">7</span> <span class="comment">// 赋值，trigger: set 触发 updater，赋值 dummy</span></span><br><span class="line">    expect(dummy).toBe(<span class="number">7</span>) <span class="comment">// true</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="green">✓ should observe multiple properties</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should observe multiple properties'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dummy</span><br><span class="line">    <span class="comment">// obj =&#123;num1: 0, num2: 0&#125;</span></span><br><span class="line">    <span class="keyword">const</span> counter = reactive(&#123; <span class="attr">num1</span>: <span class="number">0</span>, <span class="attr">num2</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    <span class="comment">// updater: ...</span></span><br><span class="line">    <span class="comment">// updater 被立即调用，counter 的 num1, num2 被访问，分别触发他们的 trigger:get</span></span><br><span class="line">    <span class="comment">// 收集依赖，三次访问，三次收集同一个 updater</span></span><br><span class="line">    <span class="comment">// 由于 targetMap -&gt; depsMap -&gt; dep: new Set() 是个集合类型</span></span><br><span class="line">    <span class="comment">// 因此虽然是三次访问，但收集的都是 updater，因此每个 dep 里面保存的是同一个 updater</span></span><br><span class="line">    effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = counter.num1 + counter.num1 + counter.num2))</span><br><span class="line"></span><br><span class="line">    expect(dummy).toBe(<span class="number">0</span>) <span class="comment">// 首次调用 updater 时候赋值了 0 + 0 + 0 = 0</span></span><br><span class="line">  	<span class="comment">// 这里先后赋值了 num1, num2，触发了两次 updater</span></span><br><span class="line">  	<span class="comment">// first: 0 + 0 + 7</span></span><br><span class="line">  	<span class="comment">// second: 7 + 7 + 7 = 21</span></span><br><span class="line">  	<span class="comment">// 测试如下面的示例代码</span></span><br><span class="line">    counter.num1 = counter.num2 = <span class="number">7</span> </span><br><span class="line">    expect(dummy).toBe(<span class="number">21</span>) <span class="comment">// true</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dummy,</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> counter = reactive(&#123; <span class="attr">num1</span>: <span class="number">0</span>, <span class="attr">num2</span>: <span class="number">0</span> &#125;)</span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> (n++, (dummy = counter.num1 + counter.num1 + counter.num2)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123; dummy, n &#125;, <span class="number">1</span>)</span><br><span class="line">counter.num1 = counter.num2 = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; dummy, n &#125;, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>结果图示：</p>
<p><img src="http://qiniu.ii6g.com/1590139770.png?imageMogr2/thumbnail/!100p" alt=""></p>
<ol>
<li>depsMap 有两个 map，分别是 num1, num2，</li>
<li>trigger: set 触发了两次，且 num2 先触发 num1 紧随其后，因为赋值操作是从右到左的顺序进行。    </li>
</ol>
</li>
<li><p><font color="green">✓ should handle multiple effects (1 ms)</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should handle multiple effects'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> dummy1, dummy2</span><br><span class="line">  <span class="keyword">const</span> counter = reactive(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy1 = counter.num)) <span class="comment">// 收集 updater1，执行一次，dummy1  = 0</span></span><br><span class="line">  effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy2 = counter.num)) <span class="comment">// 收集 updater2, 执行一次，dummy2 = 0</span></span><br><span class="line"></span><br><span class="line">  expect(dummy1).toBe(<span class="number">0</span>) <span class="comment">// true </span></span><br><span class="line">  expect(dummy2).toBe(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// trigger:set 取出 targetMap-depsMap-num:dep:Set(2) 即 updater1, updater2</span></span><br><span class="line">  <span class="comment">// 执行 updaters 之后，重新复制dummy1, dummy2 = 1</span></span><br><span class="line">  counter.num++ </span><br><span class="line">  expect(dummy1).toBe(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">  expect(dummy2).toBe(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="green"> ✓ should observe nested properties (1 ms) </font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should observe nested properties'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> dummy</span><br><span class="line">  <span class="comment">// 嵌套的 reactive 是在 createReativeObject 里面完成的</span></span><br><span class="line">  <span class="comment">// 在最后 return 结果的时候检测了是否是 isObject ，如果是进一步检测</span></span><br><span class="line">  <span class="comment">// isReadonly 与否，非只读返回 reactive(res) 对结果递归调用一次</span></span><br><span class="line">  <span class="comment">// 前提是没有设置shallow 标志，该标识表明只对目前的对象只做浅reactive</span></span><br><span class="line">  <span class="comment">// 即只做对象的一级响应式，里面嵌套的对象原样返回。</span></span><br><span class="line">  <span class="comment">// 这里调用的是 reactive 显然是递归 reactive 的。</span></span><br><span class="line">  <span class="comment">// obj = &#123; nested: &#123;num: 0 &#125;&#125;</span></span><br><span class="line">  <span class="keyword">const</span> counter = reactive(&#123; <span class="attr">nested</span>: &#123; <span class="attr">num</span>: <span class="number">0</span> &#125; &#125;)</span><br><span class="line">  <span class="comment">// 这里会触发两次 getter，一次是 counter.nested，一次是 nested.num</span></span><br><span class="line">  <span class="comment">// targetMap&#123; obj -&gt; map, nested -&gt; map &#125; 存放了两个对象的映射</span></span><br><span class="line">  <span class="comment">// obj:map -&gt; 'nested':Set(1), nested:map -&gt; 'num':Set(1)</span></span><br><span class="line">  <span class="comment">// Set(1) 都是下面的 updater</span></span><br><span class="line">  effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = counter.nested.num)) </span><br><span class="line"></span><br><span class="line">  expect(dummy).toBe(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">  counter.nested.num = <span class="number">8</span> <span class="comment">// 只会触发 'num':Set(1)</span></span><br><span class="line">  expect(dummy).toBe(<span class="number">8</span>) <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>转测试代码结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dummy</span><br><span class="line"><span class="keyword">const</span> counter = reactive(&#123; <span class="attr">nested</span>: &#123; <span class="attr">num</span>: <span class="number">0</span> &#125; &#125;)</span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = counter.nested.num))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123; dummy &#125;, <span class="number">1</span>)</span><br><span class="line">counter.nested.num = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; dummy &#125;, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  <img src="http://qiniu.ii6g.com/1590118132.png?imageMogr2/thumbnail/!100p" alt=""></p>
<pre><code>1. Loc1 : 访问 `counter.nested` 收集的 `{counter:{nested:{num:0}}} -&gt; Map{&apos;nested&apos; -&gt; Set(1)}` 依赖。
  2. Loc2: 访问 `nested.num` 收集的 `{num:7}-&gt;Map{&apos;num&apos;-&gt;Set(1)}` 依赖。
  3. Loc2: 注意看这里，当给 `counter.nested.num = 7` 赋值的时候只会触发 `&apos;num&apos; -&gt; Set(1)`。</code></pre><ul>
<li><p><font color="green"> ✓ should observe delete operations (1 ms)</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should observe delete operations'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> dummy</span><br><span class="line">  <span class="keyword">const</span> obj = reactive(&#123; <span class="attr">prop</span>: <span class="string">'value'</span> &#125;)</span><br><span class="line">  effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = obj.prop)) <span class="comment">// 收集依赖 updater</span></span><br><span class="line"></span><br><span class="line">  expect(dummy).toBe(<span class="string">'value'</span>) <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 对象属性的删除操作，只会触发 trigger 里面的 if (key !== void 0) 收集依赖进 effects: []</span></span><br><span class="line">  <span class="keyword">delete</span> obj.prop <span class="comment">// 触发 updater 重新复制 dummy: undefined</span></span><br><span class="line">  expect(dummy).toBe(<span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="green"> ✓ should observe has operations (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should observe properties on the prototype chain (9 ms)</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">t(<span class="string">'should observe properties on the prototype chain'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dummy</span><br><span class="line">    <span class="keyword">const</span> counter = reactive(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> parentCounter = reactive(&#123; <span class="attr">num</span>: <span class="number">2</span> &#125;)</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(counter, parentCounter)</span><br><span class="line">    effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = counter.num))<span class="comment">// 收集 updater</span></span><br><span class="line"></span><br><span class="line">    expect(dummy).toBe(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">  	<span class="comment">// 这里删除操作触发 deleteProperty proxy handler</span></span><br><span class="line">  	<span class="comment">// trigger: delete -&gt; run deps -&gt; 触发 updater</span></span><br><span class="line">  	<span class="comment">// 由于 updater 里面访问了 counter.num ，而 counter 自身的 num 在这时候已经被删除了</span></span><br><span class="line">  	<span class="comment">// 注意：deletePropery 里面是先执行了 Reflect.deleteProperty(...) </span></span><br><span class="line">  	<span class="comment">// 然后再触发的 trigger:delete的，因此在 updater 执行的时候 counter.num 已经不存在</span></span><br><span class="line">  	<span class="comment">// 但是根据对象属性的访问原理，会去检查原型链上父级对象的，最后会找到 parentCounter.num</span></span><br><span class="line">  	<span class="comment">// 然后取出它的值：num: 2 赋值给 dummy，所以下面 dummy toBe(2) 为 true</span></span><br><span class="line">    <span class="keyword">delete</span> counter.num</span><br><span class="line">    expect(dummy).toBe(<span class="number">2</span>)</span><br><span class="line">  	<span class="comment">// 这里改变 parent num 时候也会触发 updater</span></span><br><span class="line">  	<span class="comment">// 是因为上面的 delete 操作导致去检查了原型链，访问了 parentCounter.num ，这个时候</span></span><br><span class="line">  	<span class="comment">// 也相当于触发了  parentCounter.num 的 get ，收集了 updater</span></span><br><span class="line">    parentCounter.num = <span class="number">4</span></span><br><span class="line">    expect(dummy).toBe(<span class="number">4</span>) <span class="comment">// true</span></span><br><span class="line">  	<span class="comment">// 这里重新复制，触发 counter.num 的 set(createSetter)，</span></span><br><span class="line">  	<span class="comment">// 检测到自身没有该属性(在Reflect.set()之前)</span></span><br><span class="line">  	<span class="comment">// 然后触发 trigger:add 增加属性的操作</span></span><br><span class="line">  	<span class="comment">// 在 trigger 里面，触发之前收集到的 updater</span></span><br><span class="line">    <span class="comment">// (注意：counter.num 的 dep 这个时候并没有被移除的)</span></span><br><span class="line">    counter.num = <span class="number">3</span></span><br><span class="line">    expect(dummy).toBe(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="green">✓ should observe has operations on the prototype chain</font></p>
</li>
<li><p><font color="green">✓ should observe inherited property accessors (2 ms)</font></p>
<p>访问器属性也是一样的道理。</p>
</li>
<li><p><font color="green">✓ should observe function call chains (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should observe iteration (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should observe implicit array length changes</font></p>
</li>
<li><p><font color="green">✓ should observe sparse array mutations (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should observe enumeration (2 ms)</font></p>
</li>
<li><p><font color="green">✓ should observe symbol keyed properties (2 ms)</font></p>
</li>
<li><p><font color="green">✓ should not observe well-known symbol keyed properties (2 ms)</font></p>
<p>已知的符号属性，在 <code>createReactiveObject</code> 里面就被过滤掉了</p>
<p><code>if (isSymbol(res) &amp;&amp; builtInSymbols.has(res) || res === &#39;__proto__&#39;)</code>。</p>
</li>
<li><p><font color="green">✓ should observe function valued properties (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should observe chained getters relying on this (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should observe methods relying on this (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should not observe set operations without a value change (1 ms)</font></p>
<p>值没发生变化的时候不会重复触发 udpaters，<code>createSetter</code> 里面就已经有了判断：</p>
<p><code>if (value !== oldValue &amp;&amp; (value === value || oldValue === oldValue))</code></p>
<p>值没变不会 trigger: set，后面的是为了过滤掉 <code>NaN</code> 的情况。</p>
</li>
<li><p><font color="green">✓ should not observe raw mutations (1 ms)</font></p>
<p><code>toRaw</code> 就是将 <code>observed</code> 转成原始的那个对象，就不再是响应式的了，当然不会有啥作用。</p>
</li>
<li><p><font color="green">✓ should not be triggered by raw mutations</font></p>
<p>同上。</p>
</li>
<li><p><font color="green">✓ should not be triggered by inherited raw setters (1 ms)</font></p>
<p>同上。</p>
</li>
<li><p><font color="green">✓ should avoid implicit infinite recursive loops with itself (1 ms)</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = reactive(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> counterSpy = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  n++</span><br><span class="line">  counter.num++</span><br><span class="line">&#125;</span><br><span class="line">effect(counterSpy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter, n, <span class="string">'1'</span>)</span><br><span class="line">counter.num = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(counter, n, <span class="string">'2'</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>// 这里是 updater 里面的 counter.num++ 触发的get</p>
<p>{num: 0} {type: “get”, key: “num”, shouldTrack: true, activeEffect: ƒ} “track”</p>
<p>// 因为 counter.num++ 触发的 set</p>
<p>Map(1) {“num” =&gt; Set(1)} {type: “set”, key: “num”, newValue: 1, oldValue: 0} “trigger”<br>Proxy {num: 1} 1 “1” // log</p>
<p>// 赋值操作引发的 trigger:set</p>
<p>Map(1) {“num” =&gt; Set(1)} {type: “set”, key: “num”, newValue: 4, oldValue: 1} “trigger”</p>
<p>// set 触发了updater -&gt; trigger:get </p>
<p>{num: 4} {type: “get”, key: “num”, shouldTrack: true, activeEffect: ƒ} “track”</p>
<p>// counter.num++ -&gt; trigger:set</p>
<p>Map(1) {“num” =&gt; Set(1)} {type: “set”, key: “num”, newValue: 5, oldValue: 4} “trigger”<br>Proxy {num: 5} 2 “2”</p>
</blockquote>
<p>好像没发现哪里拦截了，但是通过下面的例子，确实又会死循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dummy</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = &#123;</span><br><span class="line">  num: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ob</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ob.num = ob.num + 1</span></span><br><span class="line">  dummy = ob.num++</span><br><span class="line">  <span class="built_in">console</span>.log(&#123; dummy &#125;, ob)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ob = <span class="keyword">new</span> <span class="built_in">Proxy</span>(counter, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(...arguments)</span><br><span class="line">    update()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(target, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ob.num = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>node 运行之后：</p>
<blockquote>
<p>/Users/simon/github/vuejs/vue-next-code-read/test/test.js:10<br> dummy = ob.num++</p>
<pre><code>^</code></pre><p>RangeError: Maximum call stack size exceeded</p>
</blockquote>
<p>所以肯定还是有哪里做了处理，防止死循环。</p>
<p>经过一通 <code>console.log</code> 之后发现关键点就在 <code>trigger</code> 的 <code>add</code> 函数里面，它在查找依赖添加到将要执行的 <code>effects</code> 集合中的时候有两个前提条件：</p>
<ol>
<li><code>!shouldTrack</code></li>
<li><code>effect !== activeEffect</code></li>
</ol>
<p><img src="http://qiniu.ii6g.com/1590131447.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>图中输出的主要关键点在<font color="red" size="5">红色</font> 部分，这里检测到正在 <code>add</code> 的 <code>effect</code> 与当前激活状态的 <code>activeEffect</code> 是同一个所以结束触发 <code>trigger:set</code>，但是为什么 <code>shouldTrack = true</code> 且 <code>effect === activeEffect</code>呢？？？</p>
<p>那么就要回头去看 <code>effect()</code> 的具体实现了，重点在 <code>try...finally</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  enableTracking()</span><br><span class="line">  effectStack.push(_effect)</span><br><span class="line">  activeEffect = _effect <span class="comment">// 这里的 _effect 就是在 trigger 里用来与 activeEffect 比较的</span></span><br><span class="line">  <span class="built_in">console</span>.log(&#123; ..._effect &#125;, <span class="string">'effect 1'</span>)</span><br><span class="line">  <span class="keyword">return</span> fn(...args) <span class="comment">// trigger set 检测 shouldTrack 和 activeEffect</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  effectStack.pop()</span><br><span class="line">  <span class="comment">// 而 shouldTrck 和 activeEffect 重置工作在这里，因此阻止了 fn 里面 ++ 操作引起的死循环</span></span><br><span class="line">  <span class="comment">// 因为 trigger -&gt; add 需要检测 if (!shouldTrack || effect !== activeEffect)</span></span><br><span class="line">  <span class="comment">// 才会将找到的 dep:updater 加入到 run 要执行的 effects: [] 中去</span></span><br><span class="line">  resetTracking() </span><br><span class="line">  activeEffect = effectStack[effectStack.length - <span class="number">1</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(&#123; ..._effect &#125;, <span class="string">'effect 2'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码含义如下：</p>
<ol>
<li><p>当执行 <code>effect(updater)</code> 时，执行上面的一段代码。</p>
</li>
<li><p><code>enableTracking()</code>  只要知道它是将 <code>shouldTrack = true</code> 了。</p>
</li>
<li><p>接下来缓存，赋值 effect</p>
</li>
<li><p>重点来了，执行 updater，这里执行的 updater里面是 <code>counter.num++</code> 会依次触发 <code>get</code> -&gt; <code>set</code></p>
<p>Get 就是收集依赖，同一个 updater 只会有一个 (<code>Set(1)</code>)。</p>
<p>Set 这里会触发 trigger:set 那么这里会检测 shouldTrack 和 activeEffect，但是这个时候两者的值并没有重置，也就是说告诉 trigger， <code>effect(updater)</code> 我还没执行完呢，你不能重复 trigger:set，但是我什么时候才能继续 trigger呢？？？这就是下面第5条该做的事情了。</p>
</li>
<li><p>finally 在 udpater 首次执行完成之后恢复shouldTrack 和activeEffect的值，从而继续完成 <code>effect(updater)</code> 的任务直到 <code>finally</code> 的代码执行完毕。</p>
</li>
</ol>
<p>即这个问题的关键点在于 4和5，正是这里的逻辑防止了 updater 里面导致 set 死循环。</p>
</li>
<li><p><font color="green">✓ should allow explicitly recursive raw function loops (1 ms)</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should allow explicitly recursive raw function loops'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> counter = reactive(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> numSpy = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      counter.num++</span><br><span class="line">      <span class="keyword">if</span> (counter.num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        numSpy()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    effect(numSpy)</span><br><span class="line">    expect(counter.num).toEqual(<span class="number">10</span>)</span><br><span class="line">    expect(numSpy).toHaveBeenCalledTimes(<span class="number">10</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>有了前面一个测试用例的分析，这里的原理就一目了然了。</p>
<p>首先 <code>counter.num++</code> 还是会因为 <code>effect(updater)</code> 没有完全结束而中断，只会执行一次 +1 操作。</p>
<p>紧跟着的 <code>if</code> 相当于在 <code>try { return fn(...args) } }</code> 返回结果之前又调用了下自己，也就是说 num+1 会执行知道 <code>num = 10</code> ，所以最后结果是 <code>num=10</code>, updater 被调用了 10，才进入了 <code>effect -&gt; finally</code> 结束当前的 <code>effect()</code>。</p>
</li>
<li><p><font color="green">✓ should avoid infinite loops with other effects (1 ms)</font></p>
<p>原理如上上。</p>
</li>
<li><p><font color="green">✓ should return a new reactive version of the function (1 ms)</font></p>
<p>因为 <code>effect(fn)</code> 最终都会被封装成 <code>ReactiveEffect</code> 类型的对象，所以肯定不相等了。</p>
</li>
<li><p><font color="green">✓ should discover new branches while running automatically (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should discover new branches when running manually (1 ms)</font></p>
<p>这两个原理都一样，在于 <code>?:</code> 执行的时候根据条件的真假是否有触发 <code>get</code>。</p>
</li>
<li><p><font color="green">✓ should not be triggered by mutating a property, which is used in an inactive branch (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should not double wrap if the passed function is a effect (1 ms)</font></p>
<p><code>function effect(fn)</code> 的第一句就是为了防止这种情况发生，检测是不是 <code>_isEffect</code> ，是的话会将 <code>fn = fn.raw</code> 提取出来。 </p>
</li>
<li><p><font color="green">✓ should not run multiple times for a single mutation (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should allow nested effects (4 ms)</font></p>
<p>不管嵌套不嵌套只要 <code>effect</code> 完整执行完成，就能顺利的进行下一个 <code>effect()</code>。</p>
</li>
<li><p><font color="green">✓ should observe json methods</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dummy = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> obj = reactive(&#123;&#125;)</span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  dummy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(targetMap, dummy, <span class="string">'before'</span>)</span><br><span class="line"><span class="comment">/* obj.a = 1 */</span></span><br><span class="line"><span class="comment">/* console.log(targetMap, dummy, 'after') */</span></span><br></pre></td></tr></table></figure>

<p>注释最后两行，看输出</p>
<p><img src="http://qiniu.ii6g.com/1590134578.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>注意这里的一个迭代器为 key 的 dep，也就是 <code>JSON.stringify(obj)</code> 的时候说明有对 obj 进行遍历(迭代器操作，触发了 <code>ownKeys</code> proxy handler)。</p>
<p>去看下 <a href="https://tc39.es/ecma262/" target="_blank" rel="noopener">https://tc39.es/ecma262/</a> <code>JSON.stringify</code> 实现原理：</p>
<blockquote>
<p>最后一步： Return ? <a href="https://tc39.es/ecma262/#sec-serializejsonproperty" target="_blank" rel="noopener">SerializeJSONProperty</a>(state, the empty String, wrapper). 进入到 SerializeJSONProperty</p>
<p>Step2: 检测到是对象会去取它 的 <code>toJson</code> 值，这也就是为什么 最后收集到的依赖 depsMap 里面会有一个 key 为 <code>toJSON</code> 的项了：</p>
<p><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">Type</a>(value) is Object or BigInt, then</p>
<ol>
<li>Let toJSON be ? <a href="https://tc39.es/ecma262/#sec-getv" target="_blank" rel="noopener">GetV</a>(value, “toJSON”).</li>
</ol>
<p>然后检测到是对象会进入：SerializeJSONObject ( state, value )</p>
<ol>
<li><p>let partial be a new empty <a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type" target="_blank" rel="noopener">List</a>.</p>
</li>
<li><p>For each elemen P of K , do </p>
<p>// 这里会有一个迭代器操作，遍历对象属性，触发 ITERATE_KEY 依赖收集</p>
<ol>
<li>Let strP be ? <a href="https://tc39.es/ecma262/#sec-serializejsonproperty" target="_blank" rel="noopener">SerializeJSONProperty</a>(state, P, value).</li>
</ol>
</li>
</ol>
</blockquote>
<p>结果就是说 <code>JSON.stringify</code> 会有对 obj 有迭代器操作，触发了 ownkeys proxy handler 调用 <code>track:ITERATE_KEY</code> 触发收集依赖。</p>
</li>
<li><p><font color="green">✓ should observe class method invocations (1 ms)</font></p>
</li>
<li><p><font color="green">✓ lazy (5 ms)</font></p>
</li>
<li><p><font color="green">✓ scheduler (1 ms)</font></p>
</li>
<li><p><font color="green">✓ events: onTrack (1 ms)</font></p>
</li>
<li><p><font color="green">✓ events: onTrigger (3 ms)</font></p>
</li>
<li><p><font color="green">✓ stop (1 ms)</font></p>
</li>
<li><p><font color="green">✓ stop with scheduler (2 ms)</font></p>
<p>来看下 stop 结合 scheduler 调度器是如何使用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">it(<span class="string">'stop with scheduler'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> dummy</span><br><span class="line">  <span class="keyword">const</span> obj = reactive(&#123; <span class="attr">prop</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> queue = []</span><br><span class="line">  <span class="keyword">const</span> runner = effect(</span><br><span class="line">    () =&gt; &#123; <span class="comment">// updater</span></span><br><span class="line">      dummy = obj.prop <span class="comment">// 这里会立即执行一次收集依赖</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">      scheduler: <span class="function">(<span class="params">e</span>) =&gt;</span> queue.push(e) </span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 这里设置触发 trigger:set，但是因为有 scheduler 的存在，所以没有立即调用 effect</span></span><br><span class="line">  <span class="comment">// 而是执行了 scheduler 将 effect 推入了队列 queue</span></span><br><span class="line">  obj.prop = <span class="number">2</span> </span><br><span class="line">  <span class="comment">// 所以这里还是 1</span></span><br><span class="line">  expect(dummy).toBe(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 因为上面的赋值触发 scheduler 缘故</span></span><br><span class="line">  expect(queue.length).toBe(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 清理依赖，targetMap-&gt;depsMap-&gt;dep 里面的所有依赖清理掉</span></span><br><span class="line">  <span class="comment">// 且 effect.active = false</span></span><br><span class="line">  stop(runner) </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// a scheduled effect should not execute anymore after stopped</span></span><br><span class="line">  <span class="comment">// 这里执行的其实是 updater -&gt; ReactiveEffect 化之后的 effect</span></span><br><span class="line">  <span class="comment">// 但是在 stop 之后 effect.active 已经是 FALSE 了</span></span><br><span class="line">  <span class="comment">// 所以会直接检测到 effect.options.scheduler 存在，返回 undefined </span></span><br><span class="line">  <span class="comment">// 真正 try 里面的 执行 fn:updater 实际没有到。所以这里相当于什么都没干</span></span><br><span class="line">  queue.forEach(<span class="function">(<span class="params">e</span>) =&gt;</span> e())</span><br><span class="line">  <span class="comment">// 所以这里值也就不会有任何变化了</span></span><br><span class="line">  <span class="comment">// 如果要这里 updater 被调用只要去掉 stop 那句即可，active = true 进入正常</span></span><br><span class="line">  <span class="comment">// 的 effect&#123;try...finaylly&#125; 执行流程触发 updater</span></span><br><span class="line">  expect(dummy).toBe(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="green">✓ events: onStop (1 ms)</font></p>
</li>
<li><p><font color="green">✓ stop: a stopped effect is nested in a normal effect (1 ms)</font></p>
</li>
<li><p><font color="green">✓ markRaw (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should not be trigger when the value and the old value both are NaN (1 ms)</font></p>
</li>
<li><p><font color="green">✓ should trigger all effects when array length is set 0 (1 ms)</font></p>
</li>
</ul>
<p><span id="code2">阶段代码链接：<a href="https://github.com/gcclll/vue-next-code-read/blob/master/bakups/reactive_with_effect_spec_passed.js" target="_blank" rel="noopener">reactive_with_effect_spec_passed_js</a>  代码</span></p>
<p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vuejs</tag>
        <tag>vuenext</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 新语法</title>
    <url>//blog/js-es6-plus.html</url>
    <content><![CDATA[<blockquote>
<p>参考链接：<a href="https://leanpub.com/understandinges6/read" target="_blank" rel="noopener">https://leanpub.com/understandinges6/read</a>  </p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>JavaScript 核心特性在 <a href="https://tc39.github.io/ecma262/" target="_blank" rel="noopener">ECMA-262</a> 标准中被定义，也叫做 <code>ECMAScript</code> ，我们所熟知的在浏览器端和 <code>Node.js</code> 实际上是 ECMAScript 的一个超集。  </p>
<p>本文包含 es6+ 新增特性。</p>
<a id="more"></a>

<h2 id="ES6-演变之路"><a href="#ES6-演变之路" class="headerlink" title="ES6 演变之路"></a>ES6 演变之路</h2><h3 id="1999-发布-v3"><a href="#1999-发布-v3" class="headerlink" title="1999 发布 v3"></a>1999 发布 v3</h3><p>1999.TC39 年发布了 ECMA-262 第三版。  </p>
<p>直到 2007 之前都没有任何变化。  </p>
<h3 id="2007-发布-v4-v3-1"><a href="#2007-发布-v4-v3-1" class="headerlink" title="2007 发布 v4, v3.1"></a>2007 发布 v4, v3.1</h3><p>2007 年发布了第四版，包含以下特性：  </p>
<ul>
<li>新语法(new syntax)</li>
<li>模块(modules)</li>
<li>类概念(classes)</li>
<li>类继承概念(classical inheritance)</li>
<li>对象私有属性(private object members)</li>
<li>更多类型</li>
<li>其他</li>
</ul>
<p>由于第四版涉及的内容太多，因此造成分歧，部分成员由此创建了  </p>
<p>3.1 版本，只包含少部分的语法变化，聚焦在：  </p>
<ul>
<li>属性</li>
<li>原生 JSON 支持</li>
<li>已有对象增加方法</li>
</ul>
<p>但是两拨人在 v4 和 v3.1 版本之间并没有达成共识，导致最后不了了之。  </p>
<h3 id="2008-JavaScript-创始人决定"><a href="#2008-JavaScript-创始人决定" class="headerlink" title="2008 JavaScript 创始人决定"></a>2008 JavaScript 创始人决定</h3><p><a href="https://en.wikipedia.org/wiki/Brendan_Eich" target="_blank" rel="noopener">Brendan Eich</a> 决定将着力于 v3.1 版本。  </p>
<p>最后 v3.1 作为 <code>ECMA-262</code> 的第五个版本被标准化，即： <code>ECMASCript 5</code>  </p>
<h3 id="2015-年发布-ECMAScript-6-也叫-ECMAScript-2015"><a href="#2015-年发布-ECMAScript-6-也叫-ECMAScript-2015" class="headerlink" title="2015 年发布 ECMAScript 6 也叫 ECMAScript 2015"></a>2015 年发布 ECMAScript 6 也叫 ECMAScript 2015</h3><p>即本书要讲的内容(ES6)。  </p>
<h1 id="块级绑定-var-let-const"><a href="#块级绑定-var-let-const" class="headerlink" title="块级绑定(var, let, const)"></a>块级绑定(var, let, const)</h1><h2 id="Var-声明和提升"><a href="#Var-声明和提升" class="headerlink" title="Var 声明和提升"></a>Var 声明和提升</h2><p>使用 <code>var</code> 来声明变量时，在一个作用域内，无论它在哪里声明的，都会被升到到该作<br>用域的顶部。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 比如： var value; // undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 虽然在这里声明的，其实会被提升到函数顶端</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里依旧可以访问变量 `value` 只不过它的值是 `undefined`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValue(<span class="literal">false</span>)) <span class="comment">// 'null'</span></span><br></pre></td></tr></table></figure>

<p>上面的 <code>getValue</code> 相当于下面的变量声明版本（提升之后）：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    value = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValue(<span class="literal">false</span>)) <span class="comment">// 'null'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>null</code></pre><h2 id="块级声明-let-const-声明"><a href="#块级声明-let-const-声明" class="headerlink" title="块级声明 let/const 声明"></a>块级声明 let/const 声明</h2><p>块级作用域，如：函数，*{ &#x2026; }* 大括号，等等都属于块级作用域，在该作用域下使<br>用 <code>let</code> 声明的变量只在  </p>
<p>该作用域下可访问。  </p>
<h3 id="声明提升问题"><a href="#声明提升问题" class="headerlink" title="声明提升问题"></a>声明提升问题</h3><p><code>let</code> 声明不会被提升，但是也有另一种说法是 <strong>let</strong> 会提升，并且在如果在提升处<br>到赋值的中间范围内使用了该变量，  </p>
<p>会使该区域成为一块临时死区(TDZ)。  </p>
<p>在声明之前使用 let 变量：  </p>
<p><strong>VM88:4 Uncaught ReferenceError: Cannot access ‘value’ before<br>initialization</strong>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">cond</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cond) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// value 在该作用域不存在</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// value 在该作用域不存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValue(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="不能重复声明"><a href="#不能重复声明" class="headerlink" title="不能重复声明"></a>不能重复声明</h3><p>使用 <code>var</code> 的时候是可以重复声明的：  </p>
<p><code>var count = 39; var count;</code>  </p>
<p>这样是不会有问题的，只不过它的声明只会被记录一次而已，即只会记录 <code>var count
    = 39;</code> 这里声明，但是不会出现异常。  </p>
<p>如果使用 <code>let</code> 就不一样了，如果出现重复声明则会异常：  </p>
<p><code>var count = 39;let count;</code>  </p>
<p>异常结果：*SyntaxError: Identifier ‘count’ has already been declared*  </p>
<h3 id="两者差别"><a href="#两者差别" class="headerlink" title="两者差别"></a>两者差别</h3><p>let 声明的值可变，const 声明的是个常量，值是不能发生改变的。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'xxx'</span>;</span><br><span class="line"></span><br><span class="line">name = <span class="string">'yyy'</span>; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">age = <span class="number">88</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h3 id="临时死区-TDZ"><a href="#临时死区-TDZ" class="headerlink" title="临时死区(TDZ)"></a>临时死区(TDZ)</h3><p>使用 <code>let/const</code> 声明的变量，任何时候试图在其声明之前使用变量都会抛出异常。  </p>
<p>即使是在声明之前使用 <code>typeof</code> 也会出现引用异常(ReferenceError)。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value)</span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.ii6g.com/1560691097.png" alt="img">  </p>
<h3 id="循环中使用块级声明"><a href="#循环中使用块级声明" class="headerlink" title="循环中使用块级声明"></a>循环中使用块级声明</h3><p>我们都知道使用 <code>var</code> 声明的变量是不存在块级作用域的，即在 <em>if/for</em> 的 {} 作<br>用域内使用 <code>var</code>  </p>
<p>声明的变量其实是该全局作用下的全局变量。  </p>
<p>比如：我们常见的 <code>for</code> 循环中的 <code>i</code> 的值  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>10</code></pre><p>结果为 <strong>10</strong> 表明在 <code>console.log(i)</code> 处是可以访问 <code>i</code> 变量的，因为 <code>var i =
    0;</code> 的声明  </p>
<p>被提升成了全局变量，即循环体中使用的一直是这一份全局变量。  </p>
<p>如果是同步代码，可能没什么问题，但要是异步代码就会出现问题，如下结果：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>5
5
5
5
5</code></pre><p>很遗憾最后结果都成了 5，因为循环体是个异步代码 <code>setTimeout</code>  </p>
<p>解决方法有：  </p>
<ul>
<li>闭包:</li>
</ul>
<p>形成一个封闭的作用域，将当前的 <code>i</code> 值传递进去。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的 v 值即传递进来的当前次循环的 i 的值</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>0
1
2
3
4</code></pre><ul>
<li>let</li>
</ul>
<p>每次循环相当于新创建了一个变量，因此变量的值都得以保存。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>0
1
2
3
4</code></pre><h3 id="全局作用域声明"><a href="#全局作用域声明" class="headerlink" title="全局作用域声明"></a>全局作用域声明</h3><p>var, let, const 另一个区别是在全局环境下的声明作用域也是不一样，  </p>
<p>我们都知道在全局作用域下使用 <code>var</code> 声明的话，浏览器端是可以通过 window.name<br>来访问该变量的，但是 let, const 却不行。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age)</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<p><img src="http://qiniu.ii6g.com/1560735450.png" alt="img">  </p>
<p>浏览器端作用域：  </p>
<p><img src="http://qiniu.ii6g.com/1560735987.png" alt="img">  </p>
<p><strong>结论：</strong>  </p>
<p>无论 <code>let</code> 在那里声明的它都是个块级作用域变量，只在其声明到该作用域之后才能<br>使用。  </p>
<p>而 <code>var</code> 声明的始终相对于当前作用域下是全局变量。  </p>
<h2 id="总结-var-let-const"><a href="#总结-var-let-const" class="headerlink" title="总结(var, let, const)"></a>总结(var, let, const)</h2><p>在 es6 之后尽量使用 let 和 const 去声明变量，严格控制变量的作用域。  </p>
<ol>
<li>var 变量声明会提升，可重复声明，且在该作用域内为全局变量</li>
<li>let/const 变量声明不会提升，不可重复声明，局部变量，且在 DTZ 范围内使用即<br>使是 typeof 也会报错</li>
<li>let/const 区别在于 const 声明的变量值不能发生改变</li>
</ol>
<table>
<thead>
<tr>
<th>关键词</th>
<th>提升</th>
<th>作用域</th>
<th>值属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>var</code></td>
<td>有提升，声明提升(命名函数定义也提升)</td>
<td>范围内全局</td>
<td>可变</td>
</tr>
<tr>
<td><code>let</code></td>
<td>无提升</td>
<td>局部变量，作用域内声明处开始往下</td>
<td>可变</td>
</tr>
<tr>
<td><code>const</code></td>
<td>无提升</td>
<td>局部变量，作用域内声明处开始往下</td>
<td>不可变</td>
</tr>
</tbody></table>
<h1 id="字符串和正则表达式-String-amp-Regex"><a href="#字符串和正则表达式-String-amp-Regex" class="headerlink" title="字符串和正则表达式(String&amp;Regex)"></a>字符串和正则表达式(String&amp;Regex)</h1><h2 id="更好的-Unicode-编码支持"><a href="#更好的-Unicode-编码支持" class="headerlink" title="更好的 Unicode 编码支持"></a>更好的 Unicode 编码支持<a id="org952d340"></a></h2><h3 id="UTF-16-编码"><a href="#UTF-16-编码" class="headerlink" title="UTF-16 编码"></a>UTF-16 编码</h3><h3 id="新增-str-codePointAt-n-和-String-fromCodePoint-str"><a href="#新增-str-codePointAt-n-和-String-fromCodePoint-str" class="headerlink" title="新增 str.codePointAt(n) 和 String.fromCodePoint(str)"></a>新增 str.codePointAt(n) 和 String.fromCodePoint(str)</h3><p>已有的编码查询函数： str.charCodeAt 和 String.fromCodeAt 用来应对单字符一个<br>字节的情况。  </p>
<p>新增的两个函数可以处理单个字符串占两个字节的大小，比如一些特殊字符“𠮷”需要用<br>到两个字节来存储。  </p>
<p>即 2bytes = 16bits 大小。  </p>
<p>charCodeAt 和 fromCodeAt 是以一个字节为单位来处理字符串的，因此如果遇到这些<br>字就没法正常处理。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'𠮷'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name.charCodeAt(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(name.codePointAt(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(name.charCodeAt(<span class="number">0</span>)))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(name.codePointAt(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>55362
134071
�
𠮷</code></pre><p>可以看到如果我们还用原来的函数 charCodeAt 和 fromCharCode 去处理这个字得到结<br>果是不正确的。  </p>
<h3 id="normalize-函数"><a href="#normalize-函数" class="headerlink" title="normalize() 函数"></a>normalize() 函数</h3><p>参考链接：<a href="https://www.cnblogs.com/hahazexia/p/9257409.html" target="_blank" rel="noopener">https://www.cnblogs.com/hahazexia/p/9257409.html</a>  </p>
<h3 id="repeat-n-函数"><a href="#repeat-n-函数" class="headerlink" title="repeat(n) 函数"></a>repeat(n) 函数</h3><p>将一个字符串重复 n 次后返回。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="string">'x'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = c.repeat(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b, c, b === c)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>xxx x false</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="y-标记"><a href="#y-标记" class="headerlink" title="y 标记"></a>y 标记</h3><h3 id="s-dotAll-flag2018"><a href="#s-dotAll-flag2018" class="headerlink" title="s(dotAll)flag2018"></a>s(dotAll)flag<sup>2018</sup></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/one.two/</span>.test(<span class="string">'one\ntwo'</span>));     <span class="comment">// → false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/one.two/</span>s.test(<span class="string">'one\ntwo'</span>));    <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>

<h3 id="命名捕获组-Named-Caputre-Groups-2018"><a href="#命名捕获组-Named-Caputre-Groups-2018" class="headerlink" title="命名捕获组(Named Caputre Groups)2018"></a>命名捕获组(Named Caputre Groups)<sup>2018</sup></h3><p>格式： <code>?&lt;name&gt;</code>  </p>
<p>引用： <code>match.groups</code> 一个包含捕获组名称的对象  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">const</span> match = re.exec(<span class="string">'2019-10-10'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">0</span>]) <span class="comment">// -&gt; 2019-10-10</span></span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">1</span>]) <span class="comment">// -&gt; 2019</span></span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">2</span>]) <span class="comment">// -&gt; 10</span></span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">3</span>]) <span class="comment">// -&gt; 10</span></span><br></pre></td></tr></table></figure>

<p>命名捕获组：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> namedRe = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;date&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">const</span> namedMatch = namedRe.exec(<span class="string">'2019-10-10'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(namedMatch.groups) <span class="comment">// &#123; year: '2019', month: '10', date: '10' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(namedMatch.groups.year) <span class="comment">// 2019</span></span><br><span class="line"><span class="built_in">console</span>.log(namedMatch.groups.month) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(namedMatch.groups.date) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON-stringify2019"><a href="#JSON-stringify2019" class="headerlink" title="JSON.stringify2019"></a>JSON.stringify<sup>2019</sup></h3><p>更好的处理不支持的字符序列。  </p>
<p><img src="https://miro.medium.com/max/605/1*1avfy0C8OcP71XsBBCmuOA.png" alt="img">  </p>
<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><h3 id="String-prototype-trimStart-2019"><a href="#String-prototype-trimStart-2019" class="headerlink" title="String.prototype.trimStart()2019"></a>String.prototype.trimStart()<sup>2019</sup></h3><h3 id="String-prototype-trimEnd-2019"><a href="#String-prototype-trimEnd-2019" class="headerlink" title="String.prototype.trimEnd()2019"></a>String.prototype.trimEnd()<sup>2019</sup></h3><h3 id="String-prototype-toString-2019"><a href="#String-prototype-toString-2019" class="headerlink" title="String.prototype.toString()2019"></a>String.prototype.toString()<sup>2019</sup></h3><p>更好的处理空格，换行符等特殊字符，比如：字符串化函数的时候，会将函数原样输出。  </p>
<p>如：  </p>
<p><img src="http://qiniu.ii6g.com/1571574030.png" alt="img">  </p>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">`hello world`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> msg)</span><br><span class="line"><span class="built_in">console</span>.log(msg.length)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>hello world
string
11</code></pre><p>如果需要用到反引号，则需要使用转义字符： <code>\`</code>  </p>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>避免一行太长，进行换行书写，但是不影响最终结果显示在一行，可以使用反斜杠  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">`multiline \</span></span><br><span class="line"><span class="string">string`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>multiline string</code></pre><p>多行字符串情况：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"multiline \n string"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>multiline
 string</code></pre><p>使用模板字符串，会按照模板字符串中的格式原样输出，而不再需要显示使用 `\n` 来<br>进行换行：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">`multiline</span></span><br><span class="line"><span class="string">string`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>multiline
string</code></pre><p>在模板字符串中空格也会是字符串的一部分  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg1 = <span class="string">`multiline</span></span><br><span class="line"><span class="string">   string`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg2 = <span class="string">`multiline</span></span><br><span class="line"><span class="string">string`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`len1: <span class="subst">$&#123;msg1.length&#125;</span>`</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`len2: <span class="subst">$&#123;msg2.length&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>len1: 19
len2: 16</code></pre><p>所以在书写模板字符串的时候必须慎重使用缩进。  </p>
<h3 id="模板字符串插值"><a href="#模板字符串插值" class="headerlink" title="模板字符串插值"></a>模板字符串插值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'xxx'</span></span><br><span class="line"><span class="keyword">const</span> getAge = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>) <span class="comment">// 普通字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`3 + 4  = <span class="subst">$&#123;<span class="number">3</span> + <span class="number">4</span>&#125;</span>`</span>) <span class="comment">// 可执行计算</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`call function to get age : <span class="subst">$&#123;getAge()&#125;</span>`</span>) <span class="comment">// 可调用函数</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>my name is xxx
3 + 4  = 7
call function to get age : 100</code></pre><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>允许使用标签模板，该标签对应的是一个函数，后面的模板字符串会被解析成参数传递<br>给该函数去进行处理，最后返回处理的结果。  </p>
<p>比如： <code>let msg = tag`Hello World`</code>  </p>
<p><strong>定义标签：</strong>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">literals, ...substitutions</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</span><br><span class="line">    price = <span class="number">0.25</span>,</span><br><span class="line">    msg = passthru<span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...subs</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(literals.join(<span class="string">'--'</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(subs)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拼起来</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subs.map(<span class="function">(<span class="params">s, i</span>) =&gt;</span> literals[i] + subs[i]).join(<span class="string">''</span>)</span><br><span class="line">    + literals[literals.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>-- items cost $--.
[ 10, &apos;2.50&apos; ]
10 items cost $2.50.</code></pre><p>从结果可以看到，标签函数参数的内容分别为:  </p>
<ol>
<li>literals 被插值(${})分割成的字符串数组，比如上例的结果为： `[“”, “ items<pre><code>const $&quot;, &quot;.&quot;]`</code></pre></li>
<li>subs 为插值计算的结果值作为第2, &#x2026; 第 n 个参数传递给了 <code>passthru</code></li>
</ol>
<h3 id="标签模板原始值-String-raw"><a href="#标签模板原始值-String-raw" class="headerlink" title="标签模板原始值(String.raw())"></a>标签模板原始值(String.raw())</h3><p>有时候需要在模板字符串中直接使用带有转义字符的内容，比如： `\n` 而不是使用其<br>转义之后的含义。  </p>
<p>这个时候则可以使用新增的内置 <code>tag</code> 函数来处理。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg1 = <span class="string">`multiline\nstring`</span></span><br><span class="line"><span class="keyword">let</span> msg2 = <span class="built_in">String</span>.raw<span class="string">`multileline\nstring`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg1)</span><br><span class="line"><span class="built_in">console</span>.log(msg2)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>multiline
string
multileline\nstring</code></pre><p>可看到在我们使用 <code>String.raw</code> 之后的 <strong>\n</strong> 并没有被转义成换行符，而是按照其原<br>始的样子输出。  </p>
<p>如果在不适用内置的 <code>Strng.raw</code> 该怎么做？  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">raw</span>(<span class="params">literals, ...subs</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拼起来</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subs.map(<span class="function">(<span class="params">s, i</span>) =&gt;</span> literals.raw[i] + subs[i]).join(<span class="string">''</span>)</span><br><span class="line">    + literals.raw[literals.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = raw<span class="string">`multiline\nstring`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>multiline\nstring</code></pre><p>nodejs 环境可能看起来不直观，通过下图我们来直观的查看下标签函数是怎么处理带<br>转义字符的字符串的：  </p>
<p><img src="http://qiniu.ii6g.com/1560743558.png" alt="img">  </p>
<p>会发现其实 <code>literals</code> 的值依旧是转义之后的，看数组中第一个元素的字符串中是有<br>一个回车标识的。  </p>
<p>此外该数组对象本身上面多了一个 <code>raw</code> 属性，其值为没有转义的内容。  </p>
<p>从这里我们得出，标签模板是怎么处理带转义字符串的模板的。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>完整的编码支持赋予了 JavaScript 处理 UTF-16 字符的能力(通过<br><code>codePointAt()</code> 和 <code>String.fromCodePoint()</code> 来转换)</li>
<li><code>u</code> 新增的标记使得正则表达式可以通过码点来代替 UTF-16 字符</li>
<li><code>normalize()</code></li>
<li>模板字符串，支持原始字符串，插值支持计算表达式或函数调用</li>
<li>标签模板，第一个参数为分割后的字符串列表，后面的参数分别为插值结果</li>
<li>转义标签模板，转义标签的第一个参数数组对象上包含一个 <code>raw</code> 数组，其中包含<br>了原始值列表</li>
</ol>
<h1 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数(Function)"></a>函数(Function)</h1><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = (</span>) =&gt; </span>&#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认参数值是如何影响 <code>arguments</code> 对象的？  </p>
<h3 id="严格非严格模式下的-arguments"><a href="#严格非严格模式下的-arguments" class="headerlink" title="严格非严格模式下的 arguments"></a>严格非严格模式下的 arguments</h3><p>只要记住一旦使用了默认值，那么 <code>arguments</code> 对象的行为将发生改变。  </p>
<p>在 ECMAScript5 的非严格模式下，arguments 对象的内容是会随着函数内部函数参数值得变化而发生变化的，也就是说它  </p>
<p>并不是在调用函数之初值就固定了，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxArgs</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>])</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>])</span><br><span class="line">  first = <span class="string">'c'</span></span><br><span class="line">  second = <span class="string">'d'</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>])</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maxArgs(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true
true
true</code></pre><p>从结果我们会发现，参数值发生变化也会导致 arguments 对象跟着变化，这种情况只会在非严格模式下产生，  </p>
<p>在严格模式下， arguments 对象是不会随着参数值改变而改变的。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxArgs</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>])</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>])</span><br><span class="line">  first = <span class="string">'c'</span></span><br><span class="line">  second = <span class="string">'d'</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>])</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maxArgs(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true
false
false</code></pre><p>喏，后面结果为 <em>false</em> 。  </p>
<h3 id="带默认参数值情况下-arguments"><a href="#带默认参数值情况下-arguments" class="headerlink" title="带默认参数值情况下 arguments"></a>带默认参数值情况下 arguments</h3><p>在 es6 之后，arguments 的行为和之前严格模式下是一样的，即不会映射参数值得变化。  </p>
<ol>
<li><p>带默认值得参数，如果在调用的时候不传递，是不会计入到 arguments 对象当中  </p>
<p>即 arguments 的实际个数是根据调用的时候所传递的参数个数来决定的。</p>
</li>
<li><p>arguments 对象不再响应参数值得变化</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second = <span class="string">'b'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length)</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]) <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">// false</span></span><br><span class="line">  first = <span class="string">'c'</span></span><br><span class="line">  second = <span class="string">'d'</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]) <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixArgs(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1
true
false
false
false</code></pre><h3 id="默认参数表达式"><a href="#默认参数表达式" class="headerlink" title="默认参数表达式"></a>默认参数表达式</h3><p>参数默认值不仅可以使用静态值，还可以赋值为调用函数的结果  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get value...'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2
get value...
6</code></pre><p>从结果显示：  </p>
<ol>
<li>如果 second 没传，会在调用 <code>add()</code> 时候执行 <code>getValue()</code> 获取默认值</li>
<li>如果传递了 second，那么 <code>getValue()</code> 是不会被执行的</li>
</ol>
<p>即在默认参数中调用的函数，是由在调用时该对应的函数参数是否有传递来决定是否调用。  </p>
<p><del>而不是传递了 second，先调用 getValue() 得到值，然后用传递的 second 值去覆盖。</del>  </p>
<p>也就是说 <code>getValue()</code> 返回的值不用每次都一样，是可以在每次调用的时候发生变化的，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2
6
7</code></pre><p>由于上面的特性，参数默认值可以是动态的，因此我们可以将前面参数值作为后面参数的默认值来使用，  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = first</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2
2</code></pre><p>甚至还可以将 first 作为参数传递给 <code>getValue(first)</code> 获取新值作为默认值来用。  </p>
<h3 id="默认参数值的临时死区-TDZ"><a href="#默认参数值的临时死区-TDZ" class="headerlink" title="默认参数值的临时死区(TDZ)"></a>默认参数值的临时死区(TDZ)</h3><p>这里临时死区的意思是指，第二个参数在使用之前未进行声明，因为参数的声明相当于使用了 <code>let</code> 。  </p>
<p>根据 <code>let</code> 的特性，在为声明之前使用属于在 TDZ 范围，会抛异常。  </p>
<p>实例：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  add(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// error</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2
second is not defined</code></pre><p>既然都存在 TDZ 那为什么第一次调用就没事了，下面来分析下看看：  </p>
<p>记住上一节所讲的：  </p>
<p><span class="underline">默认值的调用(如： <code>getValue()</code> )只有在参数未传递的情况下才会发生，这里 <code>first=second</code> 的情况依旧适用。</span>  </p>
<p>那么将这句话应用到这里：  </p>
<ol>
<li><p><code>add(1, 1)</code> 这里 first 传递了 1  </p>
<p>那么 first 在 add 被调用的时候会被初始化成 1，根据上面那句话，即此时 <code>first=second</code> 这句相当于并没有被执行  </p>
<p>因此就不会去检测 second ，也就不会出现未定义了，从而能得出正确结果：2。</p>
</li>
<li><p><code>add(undefined, 1)</code> 传递了 `undefined` 相当于没传这个参数，只是占了个位  </p>
<p>那么既然没传， <code>first=second</code> 就会被执行， <code>second</code> 就会被检测是否定义，然而检测的结果就是“未定义”，  </p>
<p>因此抛出异常。</p>
</li>
</ol>
<p>将 add 函数参数的变化用下来转声明来表示，问题就会更明显了：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add(1, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span> <span class="comment">// first = second 未执行，不检测</span></span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add(undefined, 1)</span></span><br><span class="line"><span class="keyword">let</span> first = second <span class="comment">// 这句被执行，相当于这里提前使用了 second 变量，let 特性生效</span></span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数参数是有它自己的作用域和TDZ的，并且和函数体作用域是区分开的，  </p>
<p>这就意味着函数参数是无法访问函数体内的任何变量的，因为根据就是两个不同的作用域。  </p>
</blockquote>
<h2 id="未命名参数"><a href="#未命名参数" class="headerlink" title="未命名参数"></a>未命名参数</h2><p>为什么会存在未命名参数？  </p>
<p>因为 JavaScript 是没有限制调用函数的时候传递参数个数的。  </p>
<p>比如：声明了一个函数 <code>function add() {}</code> 没任何参数，但是调用的时候是可以这样<br>的 <code>add(1, 2, 3, ...)</code>  </p>
<p>那么这些调用的时候传递给 add 的参数对应的函数参数就叫做未命名参数。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">  ;[].slice.call(<span class="built_in">arguments</span>).forEach(<span class="function"><span class="params">v</span> =&gt;</span> n += v)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>15</code></pre><h3 id="参数展开符-x2026"><a href="#参数展开符-x2026" class="headerlink" title="参数展开符(&#x2026;)"></a>参数展开符(&#x2026;)</h3><p>未命名参数一般很少使用，因为这让使用者会很迷惑该函数的作用，因此参数没任何明<br>显特征表示它是干什么用的，  </p>
<p>在 es6 中增加了一个展开符号(&#x2026;)，在函数参数中的作用是将传递进的参数列表合并<br>成一个参数数组。  </p>
<p>适用于一个函数参数个数未知的情况下使用。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里 keys 会成为一个包含传入的其余参数值的数组</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    result[keys[i]] = object[keys[i]]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  author: <span class="string">'xxx'</span>,</span><br><span class="line">  name: <span class="string">'yyy'</span>,</span><br><span class="line">  pages: <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = pick(book, <span class="string">'author'</span>, <span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3
{&quot;author&quot;:&quot;xxx&quot;,&quot;name&quot;:&quot;yyy&quot;}</code></pre><p>利用 &#x2026;keys 将传入的 (‘author’, ‘name’) 合并成了一个数组： <code>[&#39;author&#39;,
    &#39;name&#39;]</code> ，方便应对  </p>
<p>函数参数个数可变的情况。  </p>
<h3 id="参数展开符两种异常使用情况"><a href="#参数展开符两种异常使用情况" class="headerlink" title="参数展开符两种异常使用情况"></a>参数展开符两种异常使用情况</h3><ol>
<li><p>展开符参数必须是最后一个，不能在其后面还有其他参数  </p>
<p>比如： <code>function add(n, ...vals, more) {}</code> 这会出现异常</p>
</li>
<li><p>不能用在对象的 <code>setter</code> 函数上</p>
</li>
</ol>
<p>实例：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">set</span> name(...val) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.ii6g.com/1560755195.png" alt="img">  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n, ...vals, more</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.ii6g.com/1560755252.png" alt="img">  </p>
<h3 id="参数展开符对-arguments-的影响"><a href="#参数展开符对-arguments-的影响" class="headerlink" title="参数展开符对 arguments 的影响"></a>参数展开符对 arguments 的影响</h3><p>记住一点：  </p>
<p><span class="underline">arguments 总是由函数调用时传递进来的参数决定</span>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args.length);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">  <span class="built_in">console</span>.log(args[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(args[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2
2
a a
b b</code></pre><h2 id="函数构造函数能力增强"><a href="#函数构造函数能力增强" class="headerlink" title="函数构造函数能力增强"></a>函数构造函数能力增强</h2><p>在实际编码过程，我们很少直接使用 <code>Function()</code> 构造函数去创建一个函数。  </p>
<p>比如这么使用：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：参数一名称 first, 参数二名称 second，... 最后一个是函数体</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'first'</span>, <span class="string">'second'</span>, <span class="string">'return first + second'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3</code></pre><p>在 es6 中对构造函数的使用能力增强了，给其赋予了更多的功能，比如  </p>
<ol>
<li>默认参数值</li>
<li>展开符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second = first"</span>,</span><br><span class="line">                       <span class="string">"return first + second"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pickFirst = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"...args"</span>, <span class="string">"return args[0]"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pickFirst(<span class="number">1</span>, <span class="number">2</span>));   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2
2
1</code></pre><h2 id="展开符-x2026"><a href="#展开符-x2026" class="headerlink" title="展开符(&#x2026;)"></a>展开符(&#x2026;)</h2><p>在之前我们在函数参数中用到了展开符，这个时候的用途是将参数合并成数组来用。  </p>
<h3 id="普通参数传递"><a href="#普通参数传递" class="headerlink" title="普通参数传递"></a>普通参数传递</h3><p>我们一般调用函数的时候都是将参数逐个传递：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = <span class="number">20</span>,</span><br><span class="line">    v2 = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(v1, v2))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>30</code></pre><p>这仅仅两个参数，比较好书写，一旦参数多了起来就比较麻烦，在 es6 之前的做法可以利用 <code>Function.prototype.apply</code> 去实现：  </p>
<h3 id="apply-传递多个参数"><a href="#apply-传递多个参数" class="headerlink" title="apply 传递多个参数"></a>apply 传递多个参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, vs))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>5</code></pre><p>因为 <code>apply</code> 会将数组进行展开作为函数的参数传递个调用它的函数。  </p>
<h3 id="es6-之后展开符传递"><a href="#es6-之后展开符传递" class="headerlink" title="es6 之后展开符传递"></a>es6 之后展开符传递</h3><p>在 es6 之后我们将使用展开符去完成这项工作，让代码更简洁和便于理解。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...vs))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>4</code></pre><h3 id="展开符，传统方式相结合"><a href="#展开符，传统方式相结合" class="headerlink" title="展开符，传统方式相结合"></a>展开符，传统方式相结合</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">10</span>, ...vs)) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...vs, <span class="number">0</span>)) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">3</span>, ...vs, <span class="number">10</span>)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>10
4
10</code></pre><h2 id="函数名字属性"><a href="#函数名字属性" class="headerlink" title="函数名字属性"></a>函数名字属性</h2><p>以往，由于函数的各种使用方式使 JavaScript 在识别函数的时候成为一种挑战，并且<br>匿名函数的频繁使用使得程序的 debugging 过程异常痛苦，经常造成追踪栈很难理解。  </p>
<p>因此在 es6 中给所有函数添加了一个 <code>name</code> 属性。  </p>
<blockquote>
<p>name 属性只是对函数的一种描述特性，并不会有实际的引用特性，也就是说  </p>
<p>在实际编程中不可能通过函数的 name 属性去干点啥。  </p>
</blockquote>
<h3 id="选择合适的名称"><a href="#选择合适的名称" class="headerlink" title="选择合适的名称"></a>选择合适的名称</h3><p>JavaScript 会根据函数的声明方式去给其选择合适的名称，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doThirdThing = <span class="function"><span class="keyword">function</span> <span class="title">do3rdThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name);          <span class="comment">// "doSomething"</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name);       <span class="comment">// "doAnotherThing"</span></span><br><span class="line"><span class="built_in">console</span>.log(doThirdThing.name);       <span class="comment">// "do3rdThing"</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>doSomething
doAnotherThing
do3rdThing</code></pre><ol>
<li><p>如果是命名函数式声明方式，则使用的就是它的名字作为 <code>name</code> 属性值，如： <em>doSomething</em></p>
</li>
<li><p>如果是表达式匿名方式声明函数，则将使用表达式中左边的变量名称来作为 <code>name</code> 属性值，如： <em>doAnotherThing</em></p>
</li>
<li><p>表达式命名方式声明函数，则将使用命名函数的名称作为 <code>name</code> 属性，如： <em>doThridThing</em> 的名字是： <em>do3rdThing</em></p>
</li>
</ol>
<blockquote>
<p>通过第三个输出可知，命名函数的优先级高于表达式的变量名。  </p>
</blockquote>
<h3 id="name-属性的特殊情况"><a href="#name-属性的特殊情况" class="headerlink" title="name 属性的特殊情况"></a>name 属性的特殊情况</h3><ol>
<li>对象的函数名称，即该函数的名字</li>
<li>对象的访问器函数名称，通过 <code>Object.getOwnPropertyDescriptor(obj, &#39;keyname&#39;)</code> 获取访问器对象</li>
<li>调用 <code>bind()</code> 之后的函数名称，总是在原始函数名前加上 <strong>bound</strong></li>
<li>使用 <code>new Function()</code> 创建的函数名称，总是返回 <em>anonymous</em></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doSth = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="keyword">get</span> firstName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Nicholas'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name) <span class="comment">// sayName</span></span><br><span class="line"><span class="comment">// 访问器属性，只能通过 getOwnPropertyDescriptor 去获取</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get.name) <span class="comment">// get firstName</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 bind 之后的函数名称总是会在原始的函数名称之前加上 `bound fname`</span></span><br><span class="line"><span class="built_in">console</span>.log(doSth.bind().name) <span class="comment">// bound doSth</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name) <span class="comment">// anonymous</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>sayName
get firstName
bound doSth
anonymous</code></pre><h2 id="澄清函数双重目的"><a href="#澄清函数双重目的" class="headerlink" title="澄清函数双重目的"></a>澄清函数双重目的</h2><h3 id="函数使用方式"><a href="#函数使用方式" class="headerlink" title="函数使用方式"></a>函数使用方式</h3><ol>
<li><p>直接调用，当做函数来使用 <code>Person()</code></p>
</li>
<li><p>使用 <code>new</code> 的时候当做构造函数来使用创建一个实例对象</p>
</li>
</ol>
<p>在 es6 之后为了搞清楚这两种使用方式，添加了两个内置属性： <code>[[Call]]</code> 和 <code>[[Constructor]]</code>  </p>
<p>当当做函数直接调用时，其实内部是调用了 <code>[[Call]]</code> 执行了函数体，  </p>
<p>当结合 <code>new</code> 来使用是，调用的是 <code>[[Contructor]]</code> 执行了以下步骤：  </p>
<ol>
<li><p>创建一个新的对象 newObj</p>
</li>
<li><p>将 <code>this</code> 绑定到 newObj</p>
</li>
<li><p>将 newObj 对象返回作为该构造函数的一个实例对象</p>
</li>
</ol>
<p>也就是说我们可以在构造函数中去改变它的行为，如果它没有显示的 <code>return</code> 一个合<br>法的对象，则会默认走 #3 步，如果我们显示的去返回了一个对象，那么最后得到的实<br>例对象即这个显示返回的对象。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person1</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'xxx'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有显示的 return 一个合法对象</span></span><br><span class="line"><span class="comment">// 返回的是新创建的对象，并且 this 被绑定到这个心对象上</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person1(<span class="string">'张三'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此这里访问的 name 即构造函数中的 this.name</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person2</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">'李四'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照构造函数的使用定义，这里返回的是</span></span><br><span class="line"><span class="comment">// 显示 return 的那个对象： &#123; name: '李四' &#125;</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person2(<span class="string">'张三'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此这里输出的结果为：李四</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>张三
李四</code></pre><blockquote>
<p>并不是所有的函数都有 <code>[[Constructor]]</code> ，比如箭头函数就没有，因此箭头函数  </p>
<p>也就不能被用来 <code>new</code> 对象实例。  </p>
</blockquote>
<h3 id="判断函数被如何使用？"><a href="#判断函数被如何使用？" class="headerlink" title="判断函数被如何使用？"></a>判断函数被如何使用？</h3><p>有时候我们需要知道函数是如何被使用的，是当做构造函数？还是单纯当做函数直接调用？  </p>
<p>这个时候 <code>instanceof</code> 就派上用场了，它的作用是用来检测一个对象是否在当前对象的  </p>
<p>原型链上出现过。  </p>
<p>比如：在 es5 中强制一个函数只能当做构造函数来使用，一般这么做  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用 new 来创建实例对象。'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种调用，内部的 `this` 被绑定到了全局对象</span></span><br><span class="line"><span class="comment">// 而全局对象并非 Person 原型链上的对象，因此会</span></span><br><span class="line"><span class="comment">// 执行 else 抛出异常</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">'李四'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.ii6g.com/1560820870.png" alt="img">  </p>
<p>但是有一种直接调用的情况，不会走 <code>else</code> ，即通过 <code>call</code> 调用指定 <code>person</code> 实<br>例为调用元。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用 new 来创建实例对象。'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样是合法的，请 this instanceof Person 成立</span></span><br><span class="line"><span class="comment">// 因为 Person.call(person, ...) 指定了作用域为实例对象 person</span></span><br><span class="line"><span class="comment">// 因此函数内部的 this 会被绑定到这个实例对象 person 上，</span></span><br><span class="line"><span class="comment">// 而 person 确实是 Person 的实例对象，因此不会报错</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'李四'</span>)</span><br></pre></td></tr></table></figure>

<p>正常运行的结果  </p>
<p>+RESULTS:  </p>
<pre><code>undefined</code></pre><p>因此，如果是 <code>Person.call(person, ...)</code> 这种情况调用，函数内部同样无法判断它的被使用方式是如何。  </p>
<h3 id="new-target-元属性"><a href="#new-target-元属性" class="headerlink" title="new.target 元属性"></a>new.target 元属性<a id="org52daa00"></a></h3><p>为了解决上一节的“函数调用方式”判断的问题， es6 中引入了 <code>new.target</code> 元属性。  </p>
<blockquote>
<p>元属性：一个非对象的属性，用来为他的目标（比如： <code>new</code> )提供额外的相关信息。  </p>
</blockquote>
<p><code>new.target</code> 的取值？？  </p>
<ol>
<li><p>如果函数当做构造函数  </p>
<p>使用 <code>new</code> 来调用，内部调用 <code>[[Constructor]]</code> 的时候， <code>new.target</code> 会被填充<br>为 <code>new</code> 操作符指定的目标对象，这个目标对象通常是执行内部构造函数的时候新<br>创建的那个对象实例(在函数体重一般是 <code>this</code> ）。</p>
</li>
<li><p>如果函数当做普通函数直接调用，那么 <code>new.target</code> 的值为 <code>undefined</code></p>
</li>
</ol>
<p>从上面两点，那么我们就可以通过在函数内部判断 <code>new.target</code> 来判断函数的使用方<br>式了。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用 new 创建实例。'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name, <span class="string">'new'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'李四'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(notAPerson.name, <span class="string">'call'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.ii6g.com/1560822025.png" alt="img">  </p>
<p>由图中的输出证明上面 #1 和 #2 的结论，也由此结论我们可以直接使用 <code>new.target
    === Person</code> 作为判定条件。  </p>
<p>函数外部使用 <code>new.target</code> :  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span>.target)</span><br></pre></td></tr></table></figure>

<h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><h3 id="lt-es3-行为"><a href="#lt-es3-行为" class="headerlink" title="&lt;= es3 行为"></a>&lt;= es3 行为</h3><p>在 es3 或更早些时候，在块级作用域中声明函数会出现语法错误，虽然在之后默认允<br>许这样使用（不会报错了），但是各个浏览器之间的处理方式依旧不同，因此在实际开<br>发过程中，应该尽量避免这么使用，如果非要在块级作用域声明函数可以考虑使用函数<br>表达式方式。  </p>
<h3 id="es5-行为"><a href="#es5-行为" class="headerlink" title="es5 行为"></a>es5 行为</h3><p>另外，为了尝试去兼容这种怪异情况，在 es5 的严格模式下如果在块级作用域声明函<br>数，会爆出异常。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 在 es5 中会报语法错误， es6 中不会</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="es6-行为"><a href="#es6-行为" class="headerlink" title="es6 行为"></a>es6 行为<a id="org473d6ba"></a></h3><p>在 es6 之后，这种函数声明将会变的合法，且声明之后 <code>doSth()</code> 就成了一个局部函<br>数变量，即只能在 <code>if (true) { ... }</code> 这个作用域内部访问，外部无法访问，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 因为有提升，且命名函数的提升包含声明和定义都会被提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSth) <span class="comment">// function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  doSth()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 之后存在块级作用域，因此 doSth 是个局部变量，在</span></span><br><span class="line"><span class="comment">// 它的作用域范围之外无法访问</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSth); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>function
undefined</code></pre><h3 id="决定什么时候该用块级函数"><a href="#决定什么时候该用块级函数" class="headerlink" title="决定什么时候该用块级函数"></a>决定什么时候该用块级函数</h3><p>在 <a href="#org473d6ba">4.7.3</a> 一节中使用的是命名式函数声明方式，这种方式声明和定义均被提升，<br>因此在声明处至上访问能得到正常结果。  </p>
<p>如果使用表达式 + <code>let</code> 方式，则结果会和用 <code>let</code> 声明一样存在 <strong>TDZ</strong> 的问题。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ 区域，访问会异常</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSth) <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> doSth = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  doSth()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSth) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.ii6g.com/1560823372.png" alt="img">  </p>
<p>因此，我们可以根据需求去决定该使用哪种方式去声明块级函数，如果需要有提升则应<br>该使用“命名式函数”，如果不需要提升，只需要在声明之后的范围使用应该使用“函数<br>表达式”方式去声明函数。  </p>
<h3 id="非严格模式块级函数"><a href="#非严格模式块级函数" class="headerlink" title="非严格模式块级函数"></a>非严格模式块级函数</h3><p>在 es6 中的非严格模式下，块级函数的提升不再是针对块级作用域，而是函数体或全<br>局环境。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于提升到了这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSth)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非严格模式，全局提升</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  doSth()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSth) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>function
function</code></pre><p>结果显示外面的 <code>typeof doSth</code> 也是 ‘function’ 。  </p>
<p>因此，在 es6 之后函数的声明只需要区分严格或非严格模式，而不再需要考虑浏览器<br>的兼容问题，相当于统一了标准。  </p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="箭头函数特性"><a href="#箭头函数特性" class="headerlink" title="箭头函数特性"></a>箭头函数特性<a id="org5e8d16a"></a></h3><p>在 es6 中引入了箭头函数，大大的简化了函数的书写，比如  </p>
<p>声明一个函数： <code>function run() {}</code>  </p>
<p>现在： <code>const run = () =&gt; {}</code> 或者 <code>const getName = () =&gt; &#39;张三&#39;</code>  </p>
<p>虽然用起来方便了，但是箭头函数与普通函数又很大的不同，使用的时候必须要注意以<br>下几点：  </p>
<table>
<thead>
<tr>
<th>序</th>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>无 <code>this</code></td>
<td>减少问题，便于优化</td>
</tr>
<tr>
<td>2</td>
<td>无 <code>super</code></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>无 <code>arguments</code></td>
<td>箭头函数必须依赖命名参数或 <code>rest</code> 参数去访问函数的参数列表</td>
</tr>
<tr>
<td>4</td>
<td>无 <code>new.target</code> 元属性</td>
<td>不能被实例化，功能无歧义，不需要这个属性</td>
</tr>
<tr>
<td>5</td>
<td>不能 <code>new</code> 实例化</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>无原型</td>
<td>因为不能用 <code>new</code> 因此也不需要原型</td>
</tr>
<tr>
<td>7</td>
<td>不能改变 <code>this</code> 指向</td>
<td>此时指向不再受函数本身限制</td>
</tr>
<tr>
<td>8</td>
<td>不能有重复的命名参数</td>
<td>之前非严格模式下普通函数是可以有的</td>
</tr>
</tbody></table>
<blockquote>
<p>箭头函数中如果引用 <code>arguments</code> ，它指向的不再是该箭头函数的参数列表，  </p>
<p>而是包含该箭头函数的那个非箭头函数的参数列表(<a href="#orga805ee7">4.8.6</a>)。  </p>
</blockquote>
<p>没有 <code>this</code> 绑定主要有两点理由：  </p>
<ol>
<li><p>不易追踪，易造成未知行为，众多错误来源  </p>
<p>函数内部 <code>this</code> 的值非常不容易追踪，经常会造成未知的函数行为，箭头函数去<br>掉它可以避免这些烦恼</p>
</li>
<li><p>便于引擎优化  </p>
<p>限制箭头函数内部使用 <code>this</code> 去执行代码也有利于 JavaScript 引擎更容易去优<br>化内部操作，而不像普通函数一样，函数有可能会当做构造函数使用或其他用途。</p>
</li>
</ol>
<blockquote>
<p>同样，箭头函数也有自己的 <code>name</code> 属性，用来描述函数的名称特征。  </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> print = <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length, <span class="string">'arguments'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'this'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(print.name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'...end'</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>print
0 &apos;arguments&apos;
Object [global] {
// ... 省略
        { [Function: setImmediate] [Symbol(util.promisify.custom)]: [Function] } } &apos;this&apos;
...end
undefined</code></pre><p>因为是 <code>nodejs</code> 环境，因此 <code>this</code> 被绑定到了 <code>global</code> 对象上。  </p>
<p>第二行输出结果是 <code>0 &#39;arguments&#39;</code> 说明已经不能使用 <code>arguments</code> 去正确获取传入<br>的参数了。  </p>
<h3 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h3><p>箭头函数语法非常灵活，具体如何使用根据使用场景和实际情况决定。  </p>
<p>比如：  </p>
<p><code>var reflect = value =&gt; value;</code> 直接返回原值  </p>
<p>相当于  </p>
<p><code>var reflect = function(value) { return value; }</code>  </p>
<p>当只有一个参数时刻省略小括号 <code>()</code>  </p>
<p>多个参数时候：  </p>
<p><code>var sum = (n1, n2) =&gt; n1 + n2;</code>  </p>
<p>函数体更多内容时候：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do more...</span></span><br><span class="line">  <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空函数：  </p>
<p><code>var empty = () =&gt; {}</code>  </p>
<p>返回一个对象：  </p>
<p><code>var getTempItem = id =&gt; ({ id: id, name: &#39;Temp&#39; })</code>  </p>
<p>等等。。。  </p>
<h3 id="箭头立即函数表达式"><a href="#箭头立即函数表达式" class="headerlink" title="箭头立即函数表达式"></a>箭头立即函数表达式</h3><p>在 es6 之前我们要实现一个立即执行函数，一般这样：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直接在函数后面加上小括号即成为立即执行函数</span></span><br><span class="line">&#125;(<span class="string">'张三'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getName()) <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>张三</code></pre><p><strong>PS: 但是为了代码可读性，建议给函数加上小括号。</strong>  </p>
<p>箭头函数形式的立即执行函数，不可以直接在 <code>}</code> 后面使用小括号方式：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function">(<span class="params">(name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">'张三'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getName()) <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>张三</code></pre><h3 id="没有-this-对象"><a href="#没有-this-对象" class="headerlink" title="没有 this 对象"></a>没有 this 对象</h3><p>在之前我们经常遇到的一个问题写法是事件的监听回调函数中直接使用 <code>this</code> ，这将<br>导致引用错误问题，因为事件的回调属于被动触发的，而触发调用该回调的对象是不确<br>定的，这就会导致各种问题。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里用了 this ，意图是想在点击事件触发的时候去调用 PageHandler 的</span></span><br><span class="line">      <span class="comment">// doSomething 这个函数，但实际却是事与愿违的</span></span><br><span class="line">      <span class="comment">// 因为这里的 this 并非指向 Pagehandler 而是事件触发调用回调时候的那个目标对象</span></span><br><span class="line">      <span class="keyword">this</span>.doSomething(event.type);     <span class="comment">// error</span></span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以往解决方法：通过 <code>bind(this)</code> 手动指定函数调用对象  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 经过 bind 之后，回调函数的调用上下文就被绑定到了 PageHandler 这个对象</span></span><br><span class="line">    <span class="comment">// 真正绑定到 click 事件的函数其实是执行 bind(this) 之后绑定了上下文的一个函数副本</span></span><br><span class="line">    <span class="comment">// 从而执行能得到我们想要的结果</span></span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.doSomething(event.type);     <span class="comment">// no error</span></span><br><span class="line">    &#125;).bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然问题是解决了，但是使用 <code>bind(this)</code> 无疑多创建了一份函数副本，多少都会有<br>些奇怪。  </p>
<p>然后，在 es6 之后这个问题就很好的被箭头函数解决掉：  </p>
<p>根据箭头函数没有 <code>this</code> 绑定的特性，在其内部使用 <code>this</code> 的时候这个指向将是包<br>含该箭头函数的非箭头函数所在的上下文，即：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(</span><br><span class="line">      <span class="string">"click"</span>,</span><br><span class="line">      <span class="comment">// 箭头函数无 this 绑定，内部使用 this</span></span><br><span class="line">      <span class="comment">// 这个 this 的上下文将有包含该箭头函数的上一个非箭头函数</span></span><br><span class="line">      <span class="comment">// 这里即 init() 函数，而 init() 函数的上下文为 PageHandler 对象</span></span><br><span class="line">      <span class="comment">// 也就是说这里箭头函数内部的 this 指向的就是 Pagehandler 这个对象</span></span><br><span class="line">      <span class="comment">// 从而让代码按照预期运行</span></span><br><span class="line">      event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数和数组"><a href="#箭头函数和数组" class="headerlink" title="箭头函数和数组"></a>箭头函数和数组</h3><p>在使用数组的一些内置函数时，我们经常会碰到需要传递一个参考函数给他们，比如，<br>排序函数 <code>Array.prototype.sort</code> 就需要我们传递一个比较函数用来决定是升序还是<br>降序等等。  </p>
<p>如果用箭头函数将大大简化代码：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es6 之前</span></span><br><span class="line"><span class="keyword">const</span> values = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res1 = values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 指定为升序</span></span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 之后</span></span><br><span class="line"><span class="keyword">var</span> res2 = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"><span class="built_in">console</span>.log(res1.toString(), res2.toString())</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1,2,3,5,10 1,2,3,5,10</code></pre><p>或者 <code>map()</code>, <code>reduce()</code> 等等用起来会更方便更简洁许多。  </p>
<h3 id="无参数绑定-arguments"><a href="#无参数绑定-arguments" class="headerlink" title="无参数绑定(arguments)"></a>无参数绑定(arguments)<a id="orga805ee7"></a></h3><p>看实例：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrowFunctionReturningFirstArg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrowFunction = createArrowFunctionReturningFirstArg(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrowFunction()) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>5</code></pre><p>从结果看出，返回的 <code>arrowFunction()</code> 箭头函数调用的时候并没有传递任何参数，<br>但是执行结果得到了结果这个结果正是包含它的那个非箭头函数<br>(<code>createArrowFunctionReturingFirstArt()</code>)所接受的参数值。  </p>
<p><em>因此箭头函数内部如果访问 <code>arguments</code> 对象，此时该对象指向的是包含它的那个非箭头函数的参数列表对象。</em>  </p>
<h3 id="箭头函数的识别"><a href="#箭头函数的识别" class="headerlink" title="箭头函数的识别"></a>箭头函数的识别</h3><p>跟普通函数一样， <code>typeof</code> 和 <code>instanceof</code> 对齐依然使用。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> comparator = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> comparator) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(comparator <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>function
true</code></pre><p>在 <a href="#org5e8d16a">4.8.1</a> 一节提到过箭头函数是不能改变 <code>this</code> 指向的，但是  </p>
<p>并不代表我们就完全不能使用 <code>call, apply, bind</code>  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> (<span class="keyword">this</span>.n1 || <span class="number">0</span>) + n2</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.call(&#123; <span class="attr">n1</span>: <span class="number">10</span> &#125;, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2
2</code></pre><p>从这个例子中可以验证，箭头函数是无法修改它的 <code>this</code> 指向的，如果可以修改  </p>
<p>第二个结果值就应该是 <code>12</code> 而不是和第一个一样为 <code>2</code> ，因为在第二个中  </p>
<p>我们手动将 <code>sum</code> 执行上下文绑定到了一个新的对象上 <code>{n1: 10}</code> 。  </p>
<blockquote>
<p>也就是说，并非不能使用，而是用了也不会有任何变化而已。  </p>
</blockquote>
<p>使用 <code>bind</code> 保留参数：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生新的函数，这种和普通函数使用方式一样</span></span><br><span class="line"><span class="keyword">var</span> boundSum = sum.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(boundSum())</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3
3
3</code></pre><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用：将一个函数的调用放在两一个函数的最后一行。  </p>
<p>或许在 es6 中对于函数相关的最感兴趣的改动就是引擎的优化了，它改变了函数的尾调<br>用系统。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSthElse() <span class="comment">// tail call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 es6 之前，它和普通的函数调用一样被处理：创建一个新的栈帧然后将它推到调用栈<br>的栈顶等待被执行, 也就意味着之前的每一个栈帧都在内存里面保留着，如果调用栈过<br>大那这将可能是问题的来源。  </p>
<h3 id="有什么不同？"><a href="#有什么不同？" class="headerlink" title="有什么不同？"></a>有什么不同？</h3><p>在 es6 之后优化了引擎，包含尾调用系统的优化（严格模式下，非严格模式下依旧未<br>发生改变）。  </p>
<p>优化之后，不再会为尾部调用创建一个新的栈帧，而是将当前的栈帧情况，然后将其复<br>用到尾部调用，前提是满足下面几个条件：  </p>
<ol>
<li><p>尾调用函数不需要访问当前栈帧中的任何变量(即尾调用的函数不能是闭包，闭包的<br>作用就是用来持有变量)</p>
</li>
<li><p>即在尾调用的函数之后不能有其他的代码，即尾调用函数必须是函数体的最后一行</p>
</li>
<li><p>尾调用函数的调用结果要作为当前函数的返回值返回</p>
</li>
</ol>
<p>比如：下面的函数就满足尾调用优化的条件  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>; <span class="comment">// 1. 严格模式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 没有引用任何内部变量，非闭包</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 最后一行</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 调用结果被作为 doSth 的返回值返回</span></span><br><span class="line">  <span class="keyword">return</span> doSthElse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下情况不会被优化：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  doSthElse() <span class="comment">// 返回作为返回值，不会优化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + doSthElse() <span class="comment">// 在尾调用函数返回之后不能有其他操作，不会优化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = doSthElse()</span><br><span class="line">  <span class="keyword">return</span> res <span class="comment">// 不是最后一行，即不是将结果立即返回，不会优化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">1</span>,</span><br><span class="line">      func = <span class="function"><span class="params">()</span> =&gt;</span> num</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func() <span class="comment">// 闭包，不会优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何利用尾调用优化？"><a href="#如何利用尾调用优化？" class="headerlink" title="如何利用尾调用优化？"></a>如何利用尾调用优化？</h3><p>尾调用最经典的莫过于递归调用了，比如斐波那契数列问题。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会被优化，因为函数返回之后还需要进行乘积计算才返回</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3628800</code></pre><p>上面的并不会被优化，因为尾调用函数并不是立即返回的，修改如下：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, p = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> * p;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = n * p</span><br><span class="line">    <span class="comment">// 被优化</span></span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3628800</code></pre><p>尾调用优化应该是我们在书写代码的时候时常应该考虑的问题，尤其是书写递归的时候，<br>当使用递归涉及到大量的计算的时候，  </p>
<p>尾调用优化的优势将会很明显。  </p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
<th>描述</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td><strong>arguments</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ES6之前非严格模式</td>
<td>值会随着函数体内参数的改变而改变</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ES6之前严格模式</td>
<td>不会响应改变，调用之初就定了</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ES6之后行为统一</td>
<td>不会响应改变，内容由实际调用者传递个数决定</td>
<td></td>
</tr>
<tr>
<td><strong>函数默认参数</strong></td>
<td>可以是常量值</td>
<td><code>function add(f, s = 3) {}</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>可以是变量</td>
<td><code>var n = 10; function add(f, s = n) {}</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>可以是函数调用</td>
<td><code>function getVal() {}; function add(f, s = getVal) {}</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>默认值参数的执行</td>
<td>调用时有传递则不会检测或执行，未传递则会检测和执行</td>
<td></td>
</tr>
<tr>
<td></td>
<td>相互引用</td>
<td>后面的参数可以引用前面的参数变量 <code>function add(f, s = f) {}</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>临时死区(TDZ)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>参数 rest 符号</strong></td>
<td>接受多个参数，合并成数组供函数内部使用</td>
<td><code>function add(f, ...a) {}</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>异常使用一</td>
<td>不能用在访问器函数</td>
<td><code>obj = { set name(...val) {} }</code>  非法。</td>
</tr>
<tr>
<td></td>
<td>异常使用二</td>
<td>必须作为函数最后一个参数使用</td>
<td><code>function add(f, ...s, t) {}</code> 非法。</td>
</tr>
<tr>
<td></td>
<td>对arguments影响</td>
<td>非箭头函数没什么影响</td>
<td>arguments总是由调用者传递的参数决定个数</td>
</tr>
<tr>
<td><strong>构造函数</strong></td>
<td>new Function()</td>
<td>可以使用默认值，rest符号等功能</td>
<td></td>
</tr>
<tr>
<td><strong>展开符(&#x2026;)</strong></td>
<td>普通多参数函数</td>
<td><code>Math.max(1, 2, 3, 4, ...)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>普通多参数函数apply</td>
<td><code>Math.max.apply(Math, [1, 2, 3, 4])</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ES6展开符</td>
<td><code>Math.max(...[1, 2, 3, 4, ...])</code></td>
<td></td>
</tr>
<tr>
<td><strong>name 属性</strong></td>
<td>函数名称</td>
<td>仅辅助描述功能，易于跟踪函数</td>
<td></td>
</tr>
<tr>
<td></td>
<td>特殊情况: 访问器函数</td>
<td><code>get fnName</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>特殊情况：bind() 函数</td>
<td><code>bound fnName</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>特殊情况：new Function()</td>
<td>匿名函数 <code>anonymous</code></td>
<td></td>
</tr>
<tr>
<td><strong>new.target</strong></td>
<td>函数可直接调用可new构造实例</td>
<td>因此造成函数内部如何识别使用释放问题？</td>
<td></td>
</tr>
<tr>
<td></td>
<td>如果作为函数调用 <code>[[Call]]</code></td>
<td>new.target = undefined</td>
<td></td>
</tr>
<tr>
<td></td>
<td>如果是 new 构造函数 <code>[[Constructor]]</code></td>
<td>new.target = Person 构造函数本身</td>
<td></td>
</tr>
<tr>
<td><strong>块级函数</strong></td>
<td>在 es6之情块级函数的声明处理并没有统一</td>
<td>严格模式必出异常，非严格不好说</td>
<td></td>
</tr>
<tr>
<td></td>
<td>es6之后统一标准</td>
<td>严格模式：块级函数只是局部函数</td>
<td>只在作用域内有效</td>
</tr>
<tr>
<td></td>
<td></td>
<td>非严格模式：块级函数会提升到函数顶部或全局环境</td>
<td>全局或函数体生效</td>
</tr>
<tr>
<td><strong>箭头函数特性</strong></td>
<td>无 <code>this</code> 不易追踪，易于引擎优化</td>
<td>内部可以使用，但是它指向的是当前箭头函数所在的非箭头函数所在的上下文</td>
<td></td>
</tr>
<tr>
<td></td>
<td>无 <code>super</code></td>
<td>没有原型，继承等，不需要 <code>super</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>无 <code>arguments</code></td>
<td>内部访问的该对象，其实是当前环境函数的参数，而非箭头函数本身的参数列表</td>
<td></td>
</tr>
<tr>
<td></td>
<td>无 <code>new.target</code></td>
<td>不支持 <code>new</code> 就不存在使用方式问题</td>
<td></td>
</tr>
<tr>
<td></td>
<td>无原型</td>
<td>不支持 <code>new</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>不能改变 <code>this</code> 指向</td>
<td>其内部的 <code>this</code> 已经不是它管辖，可以调用 <code>call, apply, bind</code> 之流，但是不会有任何作用</td>
<td></td>
</tr>
<tr>
<td></td>
<td>不能有重复命名参数</td>
<td>非严格模式下ES6之前的普通参数可以用</td>
<td></td>
</tr>
<tr>
<td></td>
<td>箭头函数语法</td>
<td>使用方式灵活多变</td>
<td></td>
</tr>
<tr>
<td></td>
<td>立即表达式</td>
<td>必须括号包起来再执行，普通函数可直接在 <code>}</code> 后执行</td>
<td><code>(() =&gt; {})()</code>, <code>function(name){}(&#39;xxx&#39;)</code></td>
</tr>
<tr>
<td></td>
<td>typeof, instanceof</td>
<td>对箭头函数依旧有效， typeof fn <code>=</code> ‘function’, fn instanceof Function (true)</td>
<td></td>
</tr>
<tr>
<td><strong>尾调用优化</strong></td>
<td>必须满足三个条件</td>
<td>不满足条件不会优化，典型的递归调用</td>
<td></td>
</tr>
<tr>
<td></td>
<td>1. 非闭包，尾函数体内不能访问正函数体内任何变量</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>2. 结果值必须立即返回，不能参与其他计算后再返回</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>3. 必须是正函数的最后一个语句</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>优化之前</td>
<td>尾函数新建栈帧，放在调用栈顶等待调用</td>
<td></td>
</tr>
<tr>
<td></td>
<td>优化之后</td>
<td>清空调用栈，将它作为尾调用函数的栈帧复用</td>
<td></td>
</tr>
</tbody></table>
<h1 id="对象扩展-Object"><a href="#对象扩展-Object" class="headerlink" title="对象扩展(Object)"></a>对象扩展(Object)</h1><h2 id="对象分类"><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>普通对象(Ordinary)</em></td>
<td>拥有所有对象的默认行为</td>
</tr>
<tr>
<td><em>异类对象(Exotic)</em></td>
<td>和默认行为有所差异</td>
</tr>
<tr>
<td><em>标准对象(Standard)</em></td>
<td>那些由 ECMAScript 6 定义的，如： <code>Array</code>, <code>Date</code> 等等</td>
</tr>
<tr>
<td><em>内置对象(Built-in)</em></td>
<td>脚本当前执行环境中的对象，所有标准对象都是内置对象</td>
</tr>
</tbody></table>
<h2 id="对象字面量-literal-语法扩展"><a href="#对象字面量-literal-语法扩展" class="headerlink" title="对象字面量(literal)语法扩展"></a>对象字面量(literal)语法扩展</h2><p>字面量语法在 JavaScript 中使用非常普遍  </p>
<ol>
<li>书写方便</li>
<li>简洁易懂</li>
<li>JSON 就是基于字面量语法演变而来</li>
</ol>
<p>es6 的来到是的对象字面量语法更加强大简洁易用。  </p>
<h3 id="对象属性简写"><a href="#对象属性简写" class="headerlink" title="对象属性简写"></a>对象属性简写</h3><p>&lt;= es5:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es6:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简洁函数写法"><a href="#简洁函数写法" class="headerlink" title="简洁函数写法"></a>简洁函数写法</h3><p>&lt;= es5:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es6:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>在 es6 之前书写对象字面量的时候，可以直接使用多个字符串组成的字符串作为<br><code>key</code> ，但是这种方式在实际使用中是非常不方便的，假如说 key 是个很长的串呢？？  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">'first name'</span>: <span class="string">'张三'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>]) <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>张三</code></pre><p>因此， es6 中支持了变量作为对象属性名去访问，根据变量的值动态决定使用什么<br><code>key</code> 去访问对象的属性值，这样不管 <code>key</code> 多长，只需要使用变量将它存储起来，<br>直接使用变量名去使用将更加方便。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;,</span><br><span class="line">    lastName = <span class="string">"last name"</span>;</span><br><span class="line"></span><br><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"张三"</span>;</span><br><span class="line">person[lastName] = <span class="string">"李四"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]);      <span class="comment">// "张三"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]);          <span class="comment">// "李四"</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>张三
李四</code></pre><p>支持表达式计算属性名：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">' name'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  [<span class="string">'first'</span> + suffix]: <span class="string">'张三'</span>,</span><br><span class="line">  [<span class="string">'last'</span> + suffix]: <span class="string">'李四'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>]) <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'last name'</span>]) <span class="comment">// 李四</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>张三
李四</code></pre><h2 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h2><h3 id="Object-fromEntries-iterable-2019"><a href="#Object-fromEntries-iterable-2019" class="headerlink" title="Object.fromEntries(iterable)2019"></a>Object.fromEntries(iterable)<sup>2019</sup></h3><p>将一组 map 类型或似 map 类型的数组转成对象。  </p>
<p>如： <code>[ [&#39;key1&#39;, &#39;value1&#39; ], [&#39;key2&#39;, &#39;value2&#39;] ]</code>  </p>
<p>转换之后： <code>{ key1: &#39;value1&#39;, key2: &#39;value2&#39; }</code>  </p>
<h3 id="Object-is-value1-value2"><a href="#Object-is-value1-value2" class="headerlink" title="Object.is(value1, value2)"></a>Object.is(value1, value2)</h3><p>在以往我们判断两个值是否相等，经常使用的是 <code>==</code> 和 <code>===</code> ，一般推荐使用后者  </p>
<p>因为前者会有隐式强转，会在比较之前将两个值进行强制转换成同一个类型再比较。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span> == <span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="string">''</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">'5'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> == +<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true
true
true
true
false</code></pre><p>对于 <code>+0</code> 和 <code>-0</code> 使用 <code>===</code> 的结果是 <code>true</code> ，但实际上他们是有符号的，理论<br>上应该是不相等的。  </p>
<p>而两个 <code>NaN</code> 五路你是 <code>==</code> 或 <code>===</code> 都判定他们是不相等的。  </p>
<p>为了解决这些差异， es6 中加入了 <code>Object.is()</code> 接口，意指将等式的判断更加合理<br>化，它的含义是两个值是否是同一个值。  </p>
<p>我们看下各对值使用 <code>Object.is()</code> 比较的结果:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> is = <span class="built_in">Object</span>.is</span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log</span><br><span class="line"></span><br><span class="line"><span class="comment">// +0, -0</span></span><br><span class="line">log(<span class="string">'+0 == -0'</span>, +<span class="number">0</span> == <span class="number">-0</span>)</span><br><span class="line">log(<span class="string">'+0 === -0'</span>, +<span class="number">0</span> === <span class="number">-0</span>)</span><br><span class="line">log(<span class="string">'+0 is -0: '</span>, is(+<span class="number">0</span>, <span class="number">-0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line">log(<span class="string">'NaN == NaN: '</span>, <span class="literal">NaN</span> == <span class="literal">NaN</span>)</span><br><span class="line">log(<span class="string">'NaN === NaN: '</span>, <span class="literal">NaN</span> === <span class="literal">NaN</span>)</span><br><span class="line">log(<span class="string">'NaN is NaN: '</span>, is(<span class="literal">NaN</span>, <span class="literal">NaN</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// number, string</span></span><br><span class="line">log(<span class="string">'5 == "5": '</span>, <span class="number">5</span> == <span class="string">'5'</span>)</span><br><span class="line">log(<span class="string">'5 == 5: '</span>, <span class="number">5</span> == <span class="number">5</span>)</span><br><span class="line">log(<span class="string">'5 === "5": '</span>, <span class="number">5</span> === <span class="string">'5'</span>)</span><br><span class="line">log(<span class="string">'5 === 5: '</span>, <span class="number">5</span> === <span class="number">5</span>)</span><br><span class="line">log(<span class="string">'5 is "5": '</span>, is(<span class="number">5</span>, <span class="string">'5'</span>))</span><br><span class="line">log(<span class="string">'5 is 5: '</span>, is(<span class="number">5</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>+0 == -0 true
+0 === -0 true
+0 is -0:  false
NaN == NaN:  false
NaN === NaN:  false
NaN is NaN:  true
5 == &quot;5&quot;:  true
5 == 5:  true
5 === &quot;5&quot;:  false
5 === 5:  true
5 is &quot;5&quot;:  false
5 is 5:  true</code></pre><p>因此， <code>Object.is</code> 能够弥补， <code>===</code> 无法判断出 <code>+0, -0</code>, <code>NaN, Nan</code> 相等的结<br>果。  </p>
<h3 id="Object-assign-target-source-source1-source2-x2026"><a href="#Object-assign-target-source-source1-source2-x2026" class="headerlink" title="Object.assign(target, source, source1, source2, &#x2026;)"></a>Object.assign(target, source, source1, source2, &#x2026;)</h3><p>参数：  </p>
<ol>
<li><code>target</code> 接受拷贝的对象，也将返回这个对象</li>
<li><code>source</code> 拷贝内容的来源对象</li>
<li>来源对象参数可以有多个，如果存在同名属性值，最后的值由最后一个拥有同名属<br>性对象中的值为准</li>
</ol>
<p><a href="https://tc39.es/ecma262/#sec-object.assign" target="_blank" rel="noopener">TC39.ECMA262</a> 实现原理图：  </p>
<p><img src="http://qiniu.ii6g.com/Object-assign.png" alt="img">  </p>
<p>合并对象，将 source 中自身的可枚举的属性浅拷贝到 <code>target</code> 对象中，返回<br><code>target</code> 对象。  </p>
<p>混合器(<em>Mixins</em>)在 JavaScript 中被广泛使用，在一个 mixin 中，一个对象可以从<br>另个对象中接受他们的属性和方法，即浅拷贝，许多 JavaScript 库都会有一个与下面<br>类似的 mixin 函数:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = <span class="function">(<span class="params">receiver, supplier</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(supplier).forEach(</span><br><span class="line">    key =&gt; receiver[key] = supplier[key])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: EventTarget,</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'EventTarget.prototype'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  emit: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg, <span class="string">'in EventTarget.prototype'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  on: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg, <span class="string">'on EventTarget.prototype'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj1 = &#123;&#125;</span><br><span class="line">mixin(myObj1, EventTarget.prototype)</span><br><span class="line"></span><br><span class="line">myObj1.emit(<span class="string">'something changed from myObj1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myObj1.name, <span class="string">'obj1 name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj2 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(myObj2, EventTarget.prototype)</span><br><span class="line"></span><br><span class="line">myObj2.on(<span class="string">'listen from myObj1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myObj2.name, <span class="string">'obj2 name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(EventTarget.prototype, myObj1, myObj2)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>something changed from myObj1 in EventTarget.prototype
EventTarget.prototype obj1 name
listen from myObj1 on EventTarget.prototype
EventTarget.prototype obj2 name</code></pre><p>由于 <code>mixin()</code>, <code>Object.assign</code> 的实现都是采用的 <code>=</code> 操作符，因此是没法拷贝<br>访问器属性的，或者说拷贝过来之后就不会再是访问器属性了，看上面代码的运行结果对比图：  </p>
<p><img src="http://qiniu.ii6g.com/1560930362.png" alt="img">  </p>
<p>多个来源对象支持：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> receiver = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.assign(receiver, &#123;</span><br><span class="line">  name: <span class="string">'xxx'</span>,</span><br><span class="line">  age: <span class="number">100</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  height: <span class="number">180</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  color: <span class="string">'yellow'</span>,</span><br><span class="line">  age: <span class="number">80</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(receiver === res)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
{ name: &apos;xxx&apos;, age: 80, height: 180, color: &apos;yellow&apos; }</code></pre><p>最后 <code>age: 80</code> 值是最后一个来源对象中的值，返回值即第一个参数对象。  </p>
<h2 id="重复属性"><a href="#重复属性" class="headerlink" title="重复属性"></a>重复属性</h2><p>&lt;= es5 严格模式下，重复属性会出现语法错误：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'xxx'</span>,</span><br><span class="line">  name: <span class="string">'yyy'</span> <span class="comment">// syntax error in es5 strict mode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es6 无论严格或非严格模式下都属合法操作，其值为最后一个指定的值：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'xxx'</span>,</span><br><span class="line">  name: <span class="string">'yyy'</span> <span class="comment">// no error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>yyy</code></pre><h2 id="自有属性枚举顺序"><a href="#自有属性枚举顺序" class="headerlink" title="自有属性枚举顺序"></a>自有属性枚举顺序</h2><p>&lt;= es5 中是不会定义对象属性的枚举顺序的，它的枚举顺序是在实际运行时取决于所处<br>的 JavaScript 引擎。  </p>
<p>es6 中严格定义了枚举时返回的属性顺序，这将会影响在使用<br><code>Objct.getOwnPropertyNames()</code> 和 <code>Reflect.ownKeys</code> 时属性该如何返回。  </p>
<p>枚举时基本顺序遵循：  </p>
<ol>
<li><p>所有数字类型的 <code>keys</code> 为升序排序</p>
</li>
<li><p>所有字符串类型的 <code>keys</code> 按照它添加的时机排序</p>
</li>
<li><p>所有符号类型(Symbols)的 <code>keys</code> 按照它添加的时机排序</p>
</li>
</ol>
<p>三者的优先级为： <em>numbers &gt; strings &gt; symbols</em>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.d = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">''</span>)) <span class="comment">// 012acbd</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>012acbd</code></pre><blockquote>
<p>由于并非所有 JavaScript 引擎并非统一实现方式，导致 <code>for-in</code> 循环依旧无法确定<br>枚举的顺序。  </p>
<p>并且 <code>Object.keys()</code> 和 <code>JSON.stringify()</code> 采用的枚举顺序和 <code>for-in</code> 一样。  </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.d = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="功能更强的原型对象"><a href="#功能更强的原型对象" class="headerlink" title="功能更强的原型对象"></a>功能更强的原型对象</h2><p>原型是 JavaScript 中实现继承的基石，早起的版本中严重限制了原型能做的事情，  </p>
<p>然后随着 JavaScript 的逐渐成熟程序员们开始越来越依赖原型，我们现在能很清晰  </p>
<p>地感受到开发者们对原型控制上和易用性的渴望越来越强烈，由此 ES6 对齐进行了加强。  </p>
<h3 id="改变对象原型"><a href="#改变对象原型" class="headerlink" title="改变对象原型"></a>改变对象原型</h3><p>正常情况下，对象通过构造函数或 <code>Object.create()</code> 创建的同时原型也就被创建了。  </p>
<p>ES5 中可以通过 <code>Object.getPrototypeof()</code> 方法去获取对象原型，但是依然  </p>
<p>缺少一个标准的方式去获取失利之后的对象原型。  </p>
<p>ES6 增加了 <code>Object.setPrototypeof(source, target)</code> 用来改变对象的原型指向，  </p>
<p>指将 <code>source.prototype</code> 指向 <code>target</code> 对象。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prototype is person</span></span><br><span class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set prototype to dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Woof"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>实际上，一个对象的原型是存储在它的内部属性 <code>[[Prototype]]</code> 上的， <code>Object.getPrototypeOf()</code>  </p>
<p>获取的也是这个属性的值， <code>Object.setPrototypeOf()</code> 设置也是改变这个属性的值。  </p>
<h3 id="旧版原型的访问"><a href="#旧版原型的访问" class="headerlink" title="旧版原型的访问"></a>旧版原型的访问</h3><p>比如：如果想在实例中重写原型的某个方法的时候，需要在重写的方法内调用原型方法<br>时候，以往是这样搞  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set prototype to person</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set prototype to dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Woof, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>Object.getPrototypeOf(this).getGreeting.call(this)</code> &#x2026; 去获取原型中的<br>方法  </p>
<h3 id="通过-super-引用简化原型的访问"><a href="#通过-super-引用简化原型的访问" class="headerlink" title="通过 super 引用简化原型的访问"></a>通过 super 引用简化原型的访问</h3><p>如之前所提，原型是 JavaScript 中一个很重要也很常用的一个对象，ES6 对他们的使<br>用进行了简化。  </p>
<p>另外 es6 对原型的另一个改变是 <code>super</code> 的引用，这让对象访问原型对象更加方便。  </p>
<p>而在 es6 增加 <code>super</code> 之后就变得异常简洁了：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="comment">// in the previous example, this is the same as:</span></span><br><span class="line">    <span class="comment">// Object.getPrototypeOf(this).getGreeting.call(this)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类似其他语言的继承， <code>friend</code> 是实例，它的原型是它的父类，在实例中的 <code>super</code><br>其实是指向父类的引用，因此可以直接在子类中直接使用 <code>super</code> 去使用父类的方法。  </p>
<h3 id="只能在简写函数中访问-super"><a href="#只能在简写函数中访问-super" class="headerlink" title="只能在简写函数中访问 super"></a>只能在简写函数中访问 super</h3><p>但是 <code>super</code> 只能在对象的简写方法中使用，如果是使用 “function” 关键词声明的<br>函数中使用会出现  </p>
<p><em>syntax error</em>  </p>
<p>比如：下面的方式是非法的  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// syntax error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为 <code>super</code> 在这种函数的上下文中中不存在的。  </p>
<h3 id="Object-getPrototypeOf-并不是所有场景都能使用的"><a href="#Object-getPrototypeOf-并不是所有场景都能使用的" class="headerlink" title="Object.getPrototypeOf() 并不是所有场景都能使用的"></a><code>Object.getPrototypeOf()</code> 并不是所有场景都能使用的</h3><p>因为 <code>this</code> 的指向是根据函数的执行上下文来决定了，因此使用 <code>this</code> 是完全靠谱<br>的。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prototype is person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// prototype is friend</span></span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting());                  <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());                  <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting());                <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>上面的 <code>relative.getGreeting())</code> 会报错，原因是 relative 本身是个新的变量，<br>这个变量指向由 <code>Object.create(friend)</code> 创建的一个空对象，其原型为 <code>friend</code> ，<br>即 <code>reletive.getGreeting()</code> 的调用首先在 friend 中找但没找到，最后在<br><code>friend</code> 中找到了，也就是说它实际上调用的就是原型上的 <code>getGreeting()</code> 然后原<br>型方法里面又是通过 <code>this</code> 去调用了原型的方法(也就自身)，由于 <code>this</code> 始终是根<br>据当前上下文发生变化的，此时它的指向是 <code>friend</code> ，最终会导致循环调用。  </p>
<p>而用 <code>super</code> 就不会有上面的问题，因为 <code>super</code> 指向是固定的，就是指向当前对象<br>的原型对象（父对象），即这里指向的是 <code>person</code> 。  </p>
<h3 id="super-引用的过程"><a href="#super-引用的过程" class="headerlink" title="super 引用的过程"></a><code>super</code> 引用的过程</h3><p>一般情况下是没什么区别的，但是在我们做继承或者获取对象的原型的时候就很有用了，<br>因为 <code>super</code> 的指向是和 <code>[[HomeObject]]</code> 密切相关的， <code>super</code> 获取指向的过程：  </p>
<ol>
<li><p>通过在当前方法的内部属性 <code>[[HomeObject]]</code> 上面调用 <code>Object.getPrototypeOf()</code><br>去获取这个方法所在对象的原型对象；</p>
</li>
<li><p>在原型对象上搜与这个函数同名函数；</p>
</li>
<li><p>最后将这个同名函数绑定当前的 <code>this</code> 执行，然后执行这个函数。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prototype is person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting());  <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure>

<p>比如，上面的代码  </p>
<ol>
<li><p>将 <code>person</code> 设置为 <code>friend</code> 的原型，成为它的父对象</p>
</li>
<li><p>调用 <code>friend.getGreeting()</code> 执行之后在其内部使用 <code>super.getGreeting()</code> 这<br>个一开始会找到 <code>friend.getGreeting</code> 这个方法的 <code>[[HomeObject]]</code> 也就是 <code>friend</code></p>
</li>
<li><p>然后根据扎到的 <code>friend</code> ，通过 <code>Object.getPrototypeOf()</code> ，去找到原型对象，<br>即 <code>person</code> ，找到之后再去这里面找同名函数 <code>getGreeting</code></p>
</li>
<li><p>找到之后将该函数执行上下文绑定到 <code>this</code> (即 friend 所在的上下文）。</p>
</li>
<li><p>执行同名函数，此时这个虽是原型(<code>person</code>)上的函数，但是上下文已经被绑定到<br>了 <code>friend</code> 上</p>
</li>
</ol>
<p>过程简单描述就是：  </p>
<p>设置继承<br>=&gt; 重写方法<br>=&gt; super 调用父级方法<br>=&gt; 找当前函数的 <code>[[HomeObject]]</code><br>=&gt; <code>Object.getPrototypeOf([[HomeObject]]</code>) 找原型<br>=&gt; 找原型上同名函数<br>=&gt; 绑定找到的同名函数到当前的 <code>this</code><br>=&gt; 执行同名函数  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fnName: <span class="string">'person'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fnName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = &#123;</span><br><span class="line">  fnName: <span class="string">'child'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">','</span> + <span class="keyword">this</span>.fnName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(child, person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child.getName()) <span class="comment">// child child</span></span><br></pre></td></tr></table></figure>

<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>在 es6 之前是没有“方法”这个词的定义的，但在 es6 之后对方法的定义才正式有了规定。  </p>
<h3 id="函数和方法定义"><a href="#函数和方法定义" class="headerlink" title="函数和方法定义"></a>函数和方法定义</h3><p>在对象中的函数才叫做方法，非对象中的叫做函数，且 es6 给方法增加了一个<br><code>[[HomeObject]]</code> 内置属性， 它指向的是包含这个方法的那个对象。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'xxx'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not method</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'yyy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getGreeting</code> 叫做方法，且其有个内部属性 <code>[[HomeObject]]</code> 指向了 <code>person</code> 说明这<br>个对象拥有它。  </p>
<p><code>shareGreeting</code> 叫做函数，不是方法  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更新内容  </p>
<table>
<thead>
<tr>
<th>内容</th>
<th>示例/说明</th>
</tr>
</thead>
<tbody><tr>
<td>属性简写</td>
<td><code>{name, age}</code> &lt;=&gt; <code>{name: name, age: age}</code></td>
</tr>
<tr>
<td>计算属性</td>
<td><code>{ [first + &#39;name&#39;]: &#39;张三&#39; }</code>, <code>{ [&#39;first name&#39;]: &#39;张三&#39; }</code></td>
</tr>
<tr>
<td>简写方法</td>
<td><code>{ getName() {} }</code></td>
</tr>
<tr>
<td>重复属性名合法化</td>
<td><code>{ age: 10, age: 100 }</code> &lt;=&gt; <code>{ age: 100 }</code></td>
</tr>
<tr>
<td><code>Object.assign</code> 合并对象</td>
<td>浅拷贝，内部 <code>=</code> 实现拷贝</td>
</tr>
<tr>
<td><code>Object.is</code></td>
<td>加强判断，弥补 <code>===</code> 不能判断 <code>+0, -0</code> 和 <code>NaN, NaN</code> 问题</td>
</tr>
<tr>
<td>固定对象属性枚举顺序</td>
<td>number &gt; string &gt; symbol, string 和 symbol 按照增加先后顺序排列</td>
</tr>
<tr>
<td><code>Object.setPrototypeOf</code></td>
<td>可改变对象原型</td>
</tr>
<tr>
<td><code>super</code></td>
<td>指向原型对象，可通过它去访问原型对象中的方法</td>
</tr>
</tbody></table>
<h1 id="数据解构"><a href="#数据解构" class="headerlink" title="数据解构"></a>数据解构</h1><h2 id="解构优势"><a href="#解构优势" class="headerlink" title="解构优势"></a>解构优势</h2><p>在 es5 及之前如果我们想要从对象中取出属性的值，只能通过普通的赋值表达式来实现，  </p>
<p>一个还好，如果是多个的话就会出现很重复的代码，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  repeat: <span class="literal">true</span>,</span><br><span class="line">  save: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> repeat = options.repeat,</span><br><span class="line">    save = options.save</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// if more ???</span></span><br></pre></td></tr></table></figure>

<p>上面只是取两个对象的属性，如果很多呢，十几个二十几个？？  </p>
<p>不仅代码量大，还不美观。  </p>
<p>因此 es6 加入了解构系统，让这些操作变的很容易，很简洁。  </p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构的时候，等号右边不能是 <code>null</code> 或 <code>undefined</code> ，这样会报错，这是因为，<br>无论什么时候去读取 <code>null</code> 或 <code>undefined</code> 的属性都会出发运行时错误。  </p>
<h3 id="声明式解构"><a href="#声明式解构" class="headerlink" title="声明式解构"></a>声明式解构</h3><p>解构的同时声明解构后赋值的变量：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span>,</span><br><span class="line">  name: <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125; = node</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type) <span class="comment">// Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>在使用解构的过程中必须要有右边的初始值，而不能只是用来声明变量，这是不合法的<br>操作, 比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syntax error!</span></span><br><span class="line"><span class="keyword">var</span> &#123; type, name &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syntax error!</span></span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syntax error!</span></span><br><span class="line"><span class="keyword">const</span> &#123; type, name &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="先声明后解构"><a href="#先声明后解构" class="headerlink" title="先声明后解构"></a>先声明后解构</h3><p>有时候有些变量早已经存在了，只是后面我们需要将它的值改变，也正好是需要从对象<br>中去取值，这个时候就是先声明后解构：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">// 这里变量已经声明好了</span></span><br><span class="line">    type = <span class="string">"Literal"</span>,</span><br><span class="line">    name = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign different values using destructuring</span></span><br><span class="line">(&#123; type, name &#125; = node);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p>这个时候必须用 <code>()</code> 将解构语句包起来，让其成为一个执行语句，如果不，左边就相<br>当于一个块级语句，然而块级语句是不能出现在等式的左边的。  </p>
<p>在这基础上，另一种情况是将 <code>{type, name} = node</code> 作为参数传递给函数的时候，<br>这个时候传递给函数的参数其实就是 <code>node</code> 本身，例如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span></span><br><span class="line">&#125;,</span><br><span class="line">    type = <span class="string">"Literal"</span>,</span><br><span class="line">    name = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputInfo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value === node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outputInfo(&#123; type, name &#125; = node);        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<h3 id="解构默认值"><a href="#解构默认值" class="headerlink" title="解构默认值"></a>解构默认值</h3><p>在解构过程中，可能左边声明的变量在右边的对象中并不存在或者值为 <code>undefined</code><br>的时候，这个变量的值将会赋值为 <code>undefined</code> ，因此这个时候就需要针对这种情况<br>有个默认处理，即这里的解构默认值。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>属性值为 <code>undefined</code> 的情况：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span>,</span><br><span class="line">  value: <span class="literal">undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="number">0</span> &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="属性变量重命名"><a href="#属性变量重命名" class="headerlink" title="属性变量重命名"></a>属性变量重命名</h3><p>解构出来之后，可能不想沿用右边对象中的属性名，因此需要将左边的变量名称重命名：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(localType);     <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(localName);     <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p>重命名 + 默认值:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName = <span class="string">'xxx'</span> &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(localType);     <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(localName);     <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<h3 id="多级对象解构"><a href="#多级对象解构" class="headerlink" title="多级对象解构"></a>多级对象解构</h3><p>右边对象中的属性的值不一定是普通类型，可能是对象，或对象中包含对象，数组等等<br>类型，次数可以使用内嵌对象解构来进行解构：  </p>
<p>原则就是左边的变量的结构要和右边实际对象中的结构保持一致  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span>,</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; start &#125;&#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(start.line);        <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column);      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>多层解构重命名：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span>,</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; <span class="attr">start</span>: localStart &#125;&#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(start.line);        <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column);      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>#+BEGIN<sub>QUOTE</sub>  </p>
<h3 id="语法陷阱"><a href="#语法陷阱" class="headerlink" title="语法陷阱"></a>语法陷阱</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// no variables declared!</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123;&#125; &#125; = node;</span><br></pre></td></tr></table></figure>

<p>这种形式实际上是没任何作用的，因为左边的 <code>loc</code> 只是起到了站位的作用，实际起<br>作用的是在 <code>{}</code> 里面，但是里面没任何东西，也就是说这个不会解构出任何东西，也<br>不会产生任何新的变量。  </p>
<p>#+END<sub>QUOTE</sub>  </p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>数组解构和对象解构用法基本是一样的，无非就是讲 <code>{}</code> 改成数组的 <code>[]</code> ，和对象<br>一样，右边不可以是 <code>null</code> 和 <code>undefined</code>  </p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>let [first, second] = [1, 2]</code></td>
<td><code>first = 1, first = 2</code></td>
<td>普通解构</td>
</tr>
<tr>
<td><code>let [ , , third] = [1, 2, 3]</code></td>
<td><code>third = 3</code></td>
<td>空置解构，只指定某个位置解构</td>
</tr>
<tr>
<td><code>let first = 1, second = 2</code> =&gt; <code>[first, second] = [11, 22]</code></td>
<td><code>first = 11, second = 22</code></td>
<td>先声明再解构</td>
</tr>
<tr>
<td><code>let a = 1, b = 2</code>    =&gt; <code>[a, b] = [b, a]</code></td>
<td><code>a = 2, b = 1</code></td>
<td>替换值快捷方式</td>
</tr>
<tr>
<td><code>let [a = 1, b] = [11, 22]</code></td>
<td><code>a = 11, b = 22</code></td>
<td>默认值</td>
</tr>
<tr>
<td><code>let [a = 1, b] = [, 22]</code></td>
<td><code>a = 1, b = 22</code></td>
<td>默认值</td>
</tr>
<tr>
<td><code>let [a, b = 2] = [ 1 ]</code></td>
<td><code>a = 1, b = 2</code></td>
<td>默认值</td>
</tr>
<tr>
<td><code>let [a, [b]] = [1, [2]]</code></td>
<td><code>a = 1, b = 2</code></td>
<td>嵌套解构</td>
</tr>
<tr>
<td><code>let [a, [b]] = [1, [2, 3], 4]</code></td>
<td><code>a = 1, b = 2</code></td>
<td>嵌套解构</td>
</tr>
<tr>
<td><code>let [a, [b], c] = [1, [2, 3], 4]</code></td>
<td><code>a = 1, b = 2, c = 4</code></td>
<td>复杂解构</td>
</tr>
<tr>
<td><code>let [a, ...bs] = [1, 2, 3, 4, 5]</code></td>
<td><code>a = 1, bs = [2, 3, 4, 5]</code></td>
<td>rest 符号解构</td>
</tr>
<tr>
<td><code>[1, 2, 3].concat()</code> =&gt; <code>[1, 2, 3]</code> =&gt; es6: <code>[...as] = [1, 2, 3]</code></td>
<td><code>as = [1, 2, 3]</code></td>
<td>克隆数组</td>
</tr>
</tbody></table>
<h2 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h2><p>混合解构意味着被解构的对象中可能既包含对象由包含数组，也是按照对象和数组的解<br>构原理进行解构就OK。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span>,</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  range: [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  loc: &#123; start &#125;,</span><br><span class="line">  range: [ startIndex ]</span><br><span class="line">&#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(start.line);        <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column);      <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(startIndex);        <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><p>参数解构，即函数在声明的时候，参数是采用解构等式左边的形式书写，这种就需要要<br>求在调用的时候, 这个参数位置必须有个非 null 和 Undefined 值，否则会报错，原因<br>一样解构时候无法从 null 或 undefined 读取属性。  </p>
<h3 id="被解构的参数属性列表"><a href="#被解构的参数属性列表" class="headerlink" title="被解构的参数属性列表"></a>被解构的参数属性列表</h3><p>实例：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// code to set the cookie</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">  secure: <span class="literal">true</span>,</span><br><span class="line">  expires: <span class="number">60000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>不传值得非法操作：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error!</span></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>);</span><br></pre></td></tr></table></figure>

<p>这样第三个参数就是 <code>undefined</code> 报错。  </p>
<p>优化参数解构写法有两种：  </p>
<ol>
<li>函数体内解构</li>
<li>解构体默认值方式(推荐)</li>
</ol>
<h3 id="函数体内解构："><a href="#函数体内解构：" class="headerlink" title="函数体内解构："></a>函数体内解构：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数体内解构，给个默认值 || &#123;&#125; ，或者在参数那里这样： (name, value, options = &#123;&#125;)</span></span><br><span class="line">  <span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// code to set the cookie</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// code to set the cookie</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接参数解构体给默认值："><a href="#直接参数解构体给默认值：" class="headerlink" title="直接参数解构体给默认值："></a>直接参数解构体给默认值：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认值，如果不传第三个参数，那么它的默认值就是 <code>{}</code> 避免解构出错。  </p>
<h3 id="解构的参数默认值"><a href="#解构的参数默认值" class="headerlink" title="解构的参数默认值"></a>解构的参数默认值</h3><p>和普通对象一样，解构出来的参数我们还可以给他们一个默认值：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value,</span></span></span><br><span class="line"><span class="function"><span class="params">                   &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                     secure = false,</span></span></span><br><span class="line"><span class="function"><span class="params">                     path = <span class="string">"/"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     domain = <span class="string">"example.com"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     expires = new Date(Date.now(</span>) + 360000000)</span></span><br><span class="line"><span class="function">                   &#125; = </span>&#123;&#125;</span><br><span class="line">                  ) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>第三个参数没传，四个参数都取默认值</li>
<li>第三个参数有传递，根据普通对象定义解构</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>对象，先声明再解构，表达式必须用 <code>()</code> 包起来，作为表达式执行</li>
<li>对象数组解构都可以给默认值，重命名，多层解构，混合解构</li>
<li>解构遵循左侧最内层的变量声明，如果左侧最内层无任何变量，则解构表达式无任何意义</li>
<li>参数解构，要么给当前参数默认值，要么保证调用时该参数都有传入非 <code>null</code> 或<br><code>undefined</code> 的值，推荐参数默认值</li>
</ol>
<h1 id="符号和符号属性-Symbols"><a href="#符号和符号属性-Symbols" class="headerlink" title="符号和符号属性(Symbols)"></a>符号和符号属性(Symbols)</h1><p>符号类型值(<code>Symbol()</code>)是 es6 新增的一种原始数据类型和 strings, numbers,<br>booleans, <code>null</code> 和 <code>undefined</code> 属于原始值类型。  </p>
<p>它相当于数字的 <code>42</code> 或字符串的 “hello” 一样，只是单穿的一些值，因此不能对其使<br>用 <code>new Symbol()</code> 否则会报错。  </p>
<p><img src="http://qiniu.ii6g.com/1561166674.png" alt="img">  </p>
<p>符号类型是作为一种创建私有对象成员的类型，在 es6 之前是没有什么方法可以区分普<br>通属性和私有属性的。  </p>
<h2 id="新增属性或方法"><a href="#新增属性或方法" class="headerlink" title="新增属性或方法"></a>新增属性或方法</h2><h3 id="Symbol-description2019"><a href="#Symbol-description2019" class="headerlink" title="Symbol.description2019"></a>Symbol.description<sup>2019</sup></h3><p>返回符号变量的描述。  </p>
<p>如： <code>Symbol(&#39;my symbol&#39;)</code> 的 <code>Symbol.description</code> 值为 ‘my symbol’。  </p>
<p>也就是返回内置属性 <code>[[Description] ]</code> 的值。  </p>
<h2 id="创建符号"><a href="#创建符号" class="headerlink" title="创建符号"></a>创建符号</h2><p>符号类型会创建一个包含唯一值得符号变量，这些变量是没有实际字面量表示的，也就<br>是说一旦符号变量创建之后，只能通过这个变量去访问你所创建的这个符号类型。  </p>
<h3 id="创建符号-1"><a href="#创建符号-1" class="headerlink" title="创建符号"></a>创建符号</h3><p>通过 <code>Symbol([ description ])</code> 来创建符号，创建过程：  </p>
<ol>
<li>如果 <em>description</em> 是 <strong>undefined</strong>, 让 <code>descString = undefined</code></li>
<li>否则 <code>descString = ToString(description)</code></li>
<li>让内部值 <code>[[Description]]</code> 为 <em>descString</em></li>
<li>返回一个唯一的 Symbol 值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> secondName = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">person[firstName] = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]);     <span class="comment">// "Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstName)</span><br><span class="line"><span class="built_in">console</span>.log(secondName)</span><br><span class="line"><span class="built_in">console</span>.log(firstName == secondName)</span><br><span class="line"><span class="built_in">console</span>.log(firstName === secondName)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(firstName, secondName))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Nicholas
Symbol()
Symbol()
false
false
false</code></pre><p><code>firstName</code> 是存放了一个唯一值得符号类型变量，并且用来作为 <code>person</code> 对象的一<br>个属性使用。  </p>
<p>因此，如果要访问对象中的对应的这个属性的值，每次都必须使用 <code>firstName</code> 这个<br>符号变量去访问。  </p>
<blockquote>
<p>如果需要实在需要符号类型对象，可以通过 <code>new Object(Symbol())</code> 去创建一个对象，<br>而不能直接 <code>new Symbol()</code> 因为 <code>Symbol()</code> 得到的是一个原始值，就像你不能直接<br><code>new 42</code> 一个道理。  </p>
<p><img src="http://qiniu.ii6g.com/1561167374.png" alt="img">  </p>
</blockquote>
<h3 id="带参数的-Symbol-arg"><a href="#带参数的-Symbol-arg" class="headerlink" title="带参数的 Symbol(arg)"></a>带参数的 Symbol(arg)</h3><p>有时候可能需要对创建的符号做一些简单的区分，或者让其更加语义化，可以在创建的<br>时候给 <code>Symbol()</code> 函数  </p>
<p>一个参数，参数本身并没有实际的用途，但是有利于代码调试。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">"first name"</span>);</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">person[firstName] = <span class="string">"Nicholas"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"first name"</span> <span class="keyword">in</span> person);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]);             <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(firstName);                     <span class="comment">// "Symbol(first name)"</span></span><br><span class="line"><span class="built_in">console</span>.log(firstName.description) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">'xxx'</span>).description) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false
Nicholas
Symbol(first name)
undefined
undefined</code></pre><p>如输出，参数会一并输出，因此推荐使用的时候加上参数，这样在调试的时候你就能区<br>分开哪个符号来自哪里，而不至于输出都是 <code>Symbol()</code> 无法区分。  </p>
<p>参数作为符号的一种描述性质特征被储存在了内部 <code>[[Description]]</code> 属性中，这个属性<br>会在对符号调用 <code>toString()</code> (隐式或显示调用)的时候去读取它的值，除了这个没有<br>其他方法可以直接去访问 <code>[[Description]]</code> 。  </p>
<h3 id="符号类型检测-typeof"><a href="#符号类型检测-typeof" class="headerlink" title="符号类型检测(typeof)"></a>符号类型检测(typeof)</h3><p>由于符号属于原始值，因此可以直接通过 <code>typeof</code> 就可以去判断变量是不是符号类型，<br>es6 对 <code>typeof</code> 进行了扩展，如果是符号类型检测的结果值是“symbol”  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>(<span class="string">"test symbol"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol) <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>symbol</code></pre><h2 id="使用符号"><a href="#使用符号" class="headerlink" title="使用符号"></a>使用符号</h2><p>之前的例子中使用变量作为对象属性名的，都可以使用符号来替代，并且还可以对符号<br>类型的属性进行定制，让其变成只读的。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建符号，唯一</span></span><br><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">'first name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="comment">// 直接当做计算属性使用</span></span><br><span class="line">  [firstName]: <span class="string">'张三'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让属性只读</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, firstName, &#123; <span class="attr">writable</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="built_in">Symbol</span>(<span class="string">'last name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">  [lastName]: &#123;</span><br><span class="line">    value: <span class="string">'李四'</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[firstName])</span><br><span class="line"><span class="built_in">console</span>.log(person[lastName])</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>张三
李四</code></pre><h2 id="分享符号"><a href="#分享符号" class="headerlink" title="分享符号"></a>分享符号</h2><p>在使用过程中我们需要考虑一个问题：  </p>
<p>假设某个地方声明了一个符号类型及一个使用了这个符号作为属性 key 的对象，哪天  </p>
<p>如果我想在其他地方去使用它，该怎么办？？  </p>
<p>如今模块化得到普及，现在经常都是一个文件一个模块，用的时候导入这个文件得到相应的对象  </p>
<p>但由于符号值是唯一的，那外部模块又怎么知道另一个模块内部用了怎样的符号值作为对象？？  </p>
<p>这就是下面要讲的“符号分享”问题。  </p>
<blockquote>
<p>全局符号注册表(Global Symbol Registry) 会在所有代码执行之前就创建好，且列表为空。  </p>
<p>它和全局对象一样属于环境变量，因此不要去假设它是什么或它不存在之类的，因此它在所有代码执行之前  </p>
<p>就创建好了，所以它是确确实实存在的。  </p>
</blockquote>
<h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()<a id="org281b793"></a></h3><p>在之前我们通过 <code>let firstName = Symbol(&#39;first name&#39;);</code> 来创建一个符号变量，但是在使用的时候必须的用  </p>
<p><code>firstName</code> 去使用这个变量，而现在我们想将符号分享出去需要用到 <code>Symbol.for()</code> 。  </p>
<p><code>Symbol.for(description)</code> 会针对 <code>description</code> 去创建一个唯一的符号值：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">object[uid] = <span class="string">"12345"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object[uid]);       <span class="comment">// "12345"</span></span><br><span class="line"><span class="built_in">console</span>.log(uid);               <span class="comment">// "Symbol(uid)"</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for(desc)</code> 在第一次调用的时候，首先会去“全局符号注册表(global symbol registry)” 中去查找  </p>
<p>这个 <code>desc</code> 对应的符号值，找到了就返回这个符号值，如果没找到会创建一个新的符号值并且将它注册到全局符号注册表中，  </p>
<p>供下次调用时使用。  </p>
<p>-&#x2014;  </p>
<p><code>Symbol.for(key)</code> 内部<a href="https://tc39.es/ecma262/#sec-symbol-objects" target="_blank" rel="noopener">实现步骤</a>(伪代码)：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1 key 转字符串</span></span><br><span class="line">  <span class="keyword">let</span> stringKey = ToString(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 遍历 GlobalSymbolRegistryList 注册表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">in</span> GlobalSymbolRegistryList) &#123;</span><br><span class="line">    <span class="comment">// 符号值已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (SameValue(e.[[Key]], stringKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> e.[[<span class="built_in">Symbol</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注册表中不含 `stringKey` 的符号值，则创建新的符号值</span></span><br><span class="line">  <span class="comment">// 3.1 新建符号值</span></span><br><span class="line">  <span class="keyword">let</span> newSymbol = <span class="built_in">Symbol</span>(stringKey);</span><br><span class="line">  <span class="comment">// 3.1 给 [[Description]] 赋值</span></span><br><span class="line">  newSymbol.[[Description]] = stringKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 注册到符号注册表中去</span></span><br><span class="line">  GlobalSymbolRegistryList.push(&#123;</span><br><span class="line">    [[Key]]: stringKey,</span><br><span class="line">    [[<span class="built_in">Symbol</span>]]: newSymbol</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 返回新建的符号值</span></span><br><span class="line">  <span class="keyword">return</span> newSymbol;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结起来为3个步骤： 查找 -&gt; 新建 -&gt; 注册  </p>
<p>注册表中的每个符号片段是以对象形式存在(对象中包含 <code>Key</code> 和 <code>Symbol</code> 两个属性分别表示创建时的描述和符号值)。  </p>
<h3 id="使用分享符号"><a href="#使用分享符号" class="headerlink" title="使用分享符号"></a>使用分享符号</h3><p>在上一节<a href="#org281b793">7.4.1</a> 中我们描述过了用来创建分享符号的 <code>Symbol.for(desc)</code> 接口，这里将探讨如何具体使用它来分享符号值。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  [uid]: <span class="string">"12345"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object[uid]);       <span class="comment">// "12345"</span></span><br><span class="line"><span class="built_in">console</span>.log(uid);               <span class="comment">// "Symbol(uid)"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(uid === uid2);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(object[uid2]);      <span class="comment">// "12345"</span></span><br><span class="line"><span class="built_in">console</span>.log(uid2);              <span class="comment">// "Symbol(uid)</span></span><br></pre></td></tr></table></figure>

<p>在当前代码运行的全局作用域中都可以分享到一份 <code>Symbol.for(&quot;uid&quot;)</code> 符号，只需要调用它就可以拿到那个  </p>
<p>唯一的值。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line">  <span class="keyword">let</span> object = &#123;</span><br><span class="line">    [uid]: <span class="string">"12345"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line">  <span class="keyword">let</span> object = &#123;</span><br><span class="line">    [uid]: <span class="string">"67890"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid1 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = createObj1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">const</span> obj2 = createObj2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(uid1 === uid2);</span><br><span class="line"><span class="built_in">console</span>.log(obj1[uid1]);</span><br><span class="line"><span class="built_in">console</span>.log(obj1[uid2]);</span><br><span class="line"><span class="built_in">console</span>.log(obj2[uid1]);</span><br><span class="line"><span class="built_in">console</span>.log(obj2[uid2]);</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
12345
12345
67890
67890</code></pre><h3 id="Symbol-keyFor-symbolValue"><a href="#Symbol-keyFor-symbolValue" class="headerlink" title="Symbol.keyFor(symbolValue)"></a>Symbol.keyFor(symbolValue)</h3><p>我们如果想创建或获取全局注册表中的符号是可以通过 <a href="#org281b793">7.4.1</a> 中的 <code>Symbol.for(key)</code> ，但是  </p>
<p>如果我们只知道一个符号值变量的情况下，使用 <code>Symbol.for(key)</code> 就没法从注册表中取值了。  </p>
<p>因此，这里将介绍如何使用 <code>Symbol.keyFor(symbolValue)</code> 去根据符号变量查找注册表中的值。  </p>
<p>在这之前需要知道  </p>
<ol>
<li><code>Symbol.for(key)</code> 创建的符号才会进入全局注册表</li>
<li><code>Symbol()</code> 直接创建的是不会加入全局注册表的</li>
</ol>
<p>也就有了下面的代码及结果：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid));    <span class="comment">// "uid"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid2));   <span class="comment">// "uid"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid3 = <span class="built_in">Symbol</span>(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid3));   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>uid
uid
undefined</code></pre><p>因此 <code>Symbol(&quot;uid&quot;);</code> 结果不会加入注册表，因此结果是 <code>undefined</code> 。  </p>
<h2 id="符号强制转换"><a href="#符号强制转换" class="headerlink" title="符号强制转换"></a>符号强制转换</h2><p>在 JavaScript 中类型强制转换是经常会被用到的一个特性，也让 JavaScript 使用起<br>来会很灵活地可以将一个数据类型转成另一种数据类型。  </p>
<p>但是符号类型不支持强制转换。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(uid) <span class="comment">// Symbol(uid)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在输出的时候实际上是调用了 uid.toString()</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Symbol(uid)</code></pre><p>当我们将符号变量加入计算或字符串操作时会报错，因为两个不同类型的值进行操作会<br>发生隐式转换，但是符号类型不支持强转的，因此会报异常。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>),</span><br><span class="line">    desc = <span class="string">''</span>,</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  desc = uid + <span class="string">""</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  sum = uid / <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 异常信息  </p>
<pre><code>Cannot convert a Symbol value to a string
Cannot convert a Symbol value to a number</code></pre><h2 id="获取对象符号属性"><a href="#获取对象符号属性" class="headerlink" title="获取对象符号属性"></a>获取对象符号属性</h2><p>获取对象属性的方法：  </p>
<ol>
<li><code>Object.keys()</code> 会获取所有可枚举的属性</li>
<li><code>Object.getOwnPropertyNames()</code> 获取所有属性，忽略可枚举性</li>
</ol>
<p>但是为了兼容 es5 及以前的版本，他们都不会去获取符号属性，因此需要使用<br><code>Object.getOwnPropertySymbols()</code> 去单独获取对象所有的符号属性，返回一个包含所<br>有符号属性的数组。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  [uid]: <span class="string">"12345"</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.for(<span class="string">"uid2"</span>)]: <span class="string">"67890"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(object);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(symbols.length);        <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(symbols[<span class="number">0</span>]);            <span class="comment">// "Symbol(uid)"</span></span><br><span class="line"><span class="built_in">console</span>.log(object[symbols[<span class="number">0</span>]]);    <span class="comment">// "12345"</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2
Symbol(uid)
12345</code></pre><h2 id="符号内部操作-方法"><a href="#符号内部操作-方法" class="headerlink" title="符号内部操作(方法)"></a>符号内部操作(方法)</h2><p>在 es6 中 JavaScript 的许多特性中其内部的实现都是使用到了符号内部方法。  </p>
<p>比如下表涉及到的内容<a id="org3f0983b"></a>：  </p>
<table>
<thead>
<tr>
<th>符号方法</th>
<th>类型</th>
<th>JavaScript 特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol.hasInstance</code></td>
<td><code>boolean</code></td>
<td><code>instanceof</code></td>
<td><a href="#org7e71710">7.7.1</a> 实例(原型链)检测</td>
</tr>
<tr>
<td><code>Symbol.isConcatSpreadable</code></td>
<td><code>boolean</code></td>
<td><code>Array.prototype.concat</code></td>
<td><a href="#org67eb564">7.7.2</a> 检测参数合法性</td>
</tr>
<tr>
<td><code>Symbol.iterator</code></td>
<td><code>function</code></td>
<td>调用后得到迭代器</td>
<td>遍历对象或数组(等可迭代的对象)的时候会用到</td>
</tr>
<tr>
<td><code>Symbol.asyncIterator</code></td>
<td><code>function</code></td>
<td>调用后得到异步迭代器(返回一个 <code>Promise</code> )</td>
<td>遍历对象或数组(等可迭代的对象)的时候会用到</td>
</tr>
<tr>
<td><code>Symbol.match</code></td>
<td><code>function</code></td>
<td><code>String.prototype.match</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.matchAll</code></td>
<td><code>function</code></td>
<td><code>String.prototype.matchAll</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.replace</code></td>
<td><code>function</code></td>
<td><code>String.prototype.replace</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.search</code></td>
<td><code>function</code></td>
<td><code>String.prototype.search</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.split</code></td>
<td><code>function</code></td>
<td><code>String.prototype.split</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.species</code></td>
<td><code>constructor</code></td>
<td>-</td>
<td>派生对象生成</td>
</tr>
<tr>
<td><code>Symbol.toPrimitive</code></td>
<td><code>function</code></td>
<td>-</td>
<td><a href="#orgae3ed38">7.7.4</a> 返回一个对象的原始值</td>
</tr>
<tr>
<td><code>Symbol.toStringTag</code></td>
<td><code>string</code></td>
<td><code>Object.prototype.toString()</code></td>
<td><a href="#orgc7b5259">7.7.5</a> 返回一个对象的字符串描述</td>
</tr>
<tr>
<td><code>Symbol.unscopables</code></td>
<td><code>object</code></td>
<td><code>with</code></td>
<td><a href="#orgf7af38d">7.7.8</a> 不能出现在 <code>with</code> 语句中的一个对象</td>
</tr>
</tbody></table>
<blockquote>
<p>通过改变对象的上面的内部符号属性的实现，可以让我们去修改对象的一些  </p>
<p>默认行为，比如 <code>instanceof</code> 一个对象的时候可以改变它的行为让它返回一个非预期值。  </p>
</blockquote>
<h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance<a id="org7e71710"></a></h3><p>每个函数都有一个内部 <code>Symbol.hasInstance</code> 方法用来判断给定的对象是不是这个函<br>数的一个实例。  </p>
<p>这个函数定义在 <code>Function.prototype</code> 上，因此所有的函数都会继承 <code>instanceof</code><br>属性的默认行为，  </p>
<p>并且这个方法是 <em>nonwritable</em>, <em>nonconfigurable</em>, 和 <em>nonenumerable</em> 的，确保<br>它不会被错误的重写。  </p>
<p>因此下面的中的两句 <code>obj instanceof Array</code> 和<br><code>Array[Symbol.hasInstance](obj)</code> 是等价的。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v1 = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v2 = <span class="built_in">Array</span>[<span class="built_in">Symbol</span>.hasInstance](obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(v1, v2)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false false</code></pre><p>在 es6 中实际上已经对 <code>instanceof</code> 操作做了重定义，其内部还让它支持了函数调<br>用方式，即其内部的 <code>Symbol.hasInstance</code> 不再限定只是 <code>boolean</code> 类型，它还可<br>以是函数类型，因此我们可以通过重写这个方法来改变 <code>instanceof</code> 的默认行为。  </p>
<p>比如：让一个对象的 <code>instanceof</code> 操作总是返回 <code>false</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(MyObj, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'override method'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyObj();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> MyObj); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>override method
false</code></pre><p>由于 <code>Symbol.hasInstance</code> 属性是 <em>nonwritable</em> 的因此需要通过<br><code>Object.defineProperty</code> 去重新定义这个属性。  </p>
<p>#+BIGIN<sub>QUOTE</sub><br>虽然 es6 赋予了这种可以重写一些 JavaScript 特性的默认行为的能力，但是依旧不<br>推荐去这么做，很可能让你的代码变得很不可控，也不容易让人理解你的代码。<br>#+END<sub>QUOTE</sub>  </p>
<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable<a id="org67eb564"></a></h3><p>对应着 <code>Array.prototype.concat</code> 的内部使用 <code>Symbol.isConcatSpreadable</code> 。  </p>
<p>concat 使用示例：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors1 = [ <span class="string">"red"</span>, <span class="string">"green"</span> ],</span><br><span class="line">    colors2 = colors1.concat([ <span class="string">"blue"</span>, <span class="string">"black"</span> ]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2.length);    <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2);           <span class="comment">// ["red","green","blue","black"]</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>4
[ &apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;black&apos; ]</code></pre><p>我们一般用 <code>concat</code> 去扩展一个数组，把他们合并到一个新的数组中去。  </p>
<p>根据 <code>Array.prototype.concat(value1, ...valueNs)</code> 的定义，它是可以接受 <code>n</code><br>多个参数的，比如：  </p>
<p><code>[].concat(1, 2, 3, ...)</code> <code>&gt; =[1, 2, 3, ...]</code>  </p>
<p>并且并没有限定参数的类型，即这些 <code>value1, ...valuesNs</code> 可以是任意类型的值<br>（数组，对象，纯值等等）。  </p>
<p>另外，如果参数是数组的话，它会将数组项一一展开合并到源数组中区(且只会做一级<br>展开，数组中的数组不会展开)。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors1 = [ <span class="string">"red"</span>, <span class="string">"green"</span> ],</span><br><span class="line">    colors2 = colors1.concat(</span><br><span class="line">      [ <span class="string">"blue"</span>, <span class="string">"black"</span>, [ <span class="string">"white"</span> ] ], <span class="string">"brown"</span>, &#123; <span class="attr">color</span>: <span class="string">"red"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors1 === colors2)</span><br><span class="line"><span class="built_in">console</span>.log(colors2.length);    <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2);           <span class="comment">// ["red","green","blue","black","brown"]</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false
7
[ &apos;red&apos;,
  &apos;green&apos;,
  &apos;blue&apos;,
  &apos;black&apos;,
  [ &apos;white&apos; ],
  &apos;brown&apos;,
  { color: &apos;red&apos; } ]</code></pre><p>但是，如果我们需要的是将 <code>{ color: &#39;red&#39; }</code> 中的属性值 <code>&#39;red&#39;</code> 合并到数组末<br>尾，该如何做？？  </p>
<p>-&gt;&gt;&gt; <code>Symbol.isConcatSpreadable</code> 就是它  </p>
<p>和其他内置符号不一样，这个在所有的对象中默认是不存在的，因此如果我们需要就得<br>手动去添加，让这个对象  </p>
<p>变成 <em>concatable</em> 只需要将这个属性值置为 <code>true</code> 即可:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'aaa'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">'bbb'</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objNoLength = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'xxx'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'yyy'</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objNoNumberAttrs = &#123;</span><br><span class="line">  a: <span class="string">'www'</span>,</span><br><span class="line">  b: <span class="string">'vvv'</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> words = [ <span class="string">'somthing'</span> ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(words.concat(collection).toString())</span><br><span class="line"><span class="built_in">console</span>.log(words.concat(objNoLength).toString())</span><br><span class="line"><span class="built_in">console</span>.log(words.concat(objNoNumberAttrs).toString())</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>somthing,aaa,bbb
somthing
somthing,,</code></pre><p>分析结果得出，对象要变的可以被 <code>Array.prototype.concat</code> 使用，  </p>
<p>需要满足以下条件：  </p>
<ol>
<li>必须有 <code>length</code> 属性，否则对结果没任何影响，如结果第二行输出： <em>somthing</em></li>
<li>必须有以数字为 <code>key</code> 的属性，否则数组中将使用空值代替追加的值追加到数组中<br>去，如第三行输出： <em>somthing,,</em></li>
<li>必须增加符号属性 <code>Symbol.isConcatSpreadable</code> 且值为 <code>true</code></li>
</ol>
<p>同理，我们可以将数组对象的 <code>Symbol.isConcatSpreadable</code> 符号属性置为 <code>false</code><br>来阻止数组的 <em>concatable</em> 行为。  </p>
<h3 id="Symbol-match-Symbol-replace-Symbol-search-Symbol-split"><a href="#Symbol-match-Symbol-replace-Symbol-search-Symbol-split" class="headerlink" title="Symbol.match, Symbol.replace, Symbol.search, Symbol.split"></a>Symbol.match, Symbol.replace, Symbol.search, Symbol.split<a id="org139fb83"></a></h3><p>和字符串，正则表达式有关的一些符号，对应着字符串和正则表达式的方法：  </p>
<ul>
<li><code>match(regex)</code> 字符串是否匹配正则</li>
<li><code>replace(regex, replacement)</code> 字符串替换</li>
<li><code>search(regex)</code> 字符串搜索</li>
<li><code>split(regex)</code> 字符串切割</li>
</ul>
<p>这些都需要用到正则表达式 <code>regex</code>  </p>
<p>在 es6 之前这些方法与正则表达式的交互过程对于开发者而已都是隐藏了其内部细节<br>的，也就是说开发者无法通过自己定义的对象去表示一个正则。  </p>
<p>在 es6 中定义了四个符号便是用来实现 <code>RegExp</code> 内部实现对象，即可以通过对象的<br>方式去实现一个正则表达式规则。  </p>
<p>这四个符号属性是在 <code>RegExp.prototype</code> 原型上被定义的，作为以上方法的默认实现。  </p>
<blockquote>
<p>意思就是 <code>math</code>, <code>replace</code>, <code>search</code>, <code>split</code> 这四个方法的 <code>regex</code> 正则  </p>
<p>表达式的内部实现基于对应的四个符号属性函数 <code>Symbol.math</code>, <code>Symbol.replace</code>,  </p>
<p><code>Symbol.search</code>, <code>Symbol.split</code> 。  </p>
</blockquote>
<ul>
<li><code>Symbol.match</code> 接受一个字符串参数，如果匹配会返回一个匹配的数组，未匹配返回 <code>null</code> 。</li>
<li><code>Symbol.replace</code> 接受一个字符串参数和一个用来替换的字符串，返回一个新的字符串。</li>
<li><code>Symbol.search</code> 接受一个字符串，返回匹配到的数字所以呢，未匹配返回 -1。</li>
<li><code>Symbol.split</code> 接受一个字符串，返回以匹配到的字符串位置分割成的一个字符串数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 等价于 /^.$&#123;10&#125;$/</span></span><br><span class="line"><span class="keyword">let</span> hasLengthOf10 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length === <span class="number">10</span> ? [value] : <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.replace]: <span class="function"><span class="keyword">function</span>(<span class="params">value, replacement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length === <span class="number">10</span> ? replacement : value</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.search]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length === <span class="number">10</span> ? <span class="number">0</span> : <span class="number">-1</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.split]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length === <span class="number">10</span> ? [<span class="string">""</span>, <span class="string">""</span>] : [value]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg1 = <span class="string">"Hello World"</span>, <span class="comment">// 11 chars</span></span><br><span class="line">    msg2 = <span class="string">"Hello John"</span>; <span class="comment">// 10 chars</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m1 = msg1.match(hasLengthOf10)</span><br><span class="line"><span class="keyword">let</span> m2 = msg2.match(hasLengthOf10)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m1)</span><br><span class="line"><span class="built_in">console</span>.log(m2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = msg1.replace(hasLengthOf10, <span class="string">"Howdy!"</span>)</span><br><span class="line"><span class="keyword">let</span> r2 = msg2.replace(hasLengthOf10, <span class="string">"Howdy!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r1)</span><br><span class="line"><span class="built_in">console</span>.log(r2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = msg1.search(hasLengthOf10)</span><br><span class="line"><span class="keyword">let</span> s2 = msg2.search(hasLengthOf10)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line"><span class="built_in">console</span>.log(s2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sp1 = msg1.split(hasLengthOf10)</span><br><span class="line"><span class="keyword">let</span> sp2 = msg2.split(hasLengthOf10)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sp1)</span><br><span class="line"><span class="built_in">console</span>.log(sp2)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>null
[ &apos;Hello John&apos; ]
Hello World
Howdy!
-1
0
[ &apos;Hello World&apos; ]
[ &apos;&apos;, &apos;&apos; ]</code></pre><p>通过这几个正则对象的内部符号属性，使得我们有能力根据需要去完成更复杂的正则匹配规则。  </p>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive<a id="orgae3ed38"></a></h3><p>在 es6 之前，如果我们要使用 <code>==</code> 去比较两个对象的时候，其内部都会讲对象转成<br>原始值之后再去比较，且此时的转换属于内部操作，我们是无法知晓更无法干涉的。  </p>
<p>但在 es6 出现之后，这种内部实现通过 <code>Symbol.toPrimitvie</code> 被暴露出来了，从而<br>使得我们有能力取改变他们的默认行为。  </p>
<p><code>Symbol.toPrimitvie</code> 是定义在所有的标准类型对象的原型之上，用来描述在对象被<br>转换成原始值之前的都做了些什么行为。  </p>
<p>当一个对象发生原始值转换的时候， <code>Symbol.toPrimitive</code> 就会带上一个参数<br>(<code>hint</code>)被调用，这个参数值为 “number”, “string”, “default” 中的一个(<em>值是由<br>JavaScript 引擎所决定的</em>)，分别表示：  </p>
<ol>
<li>“number” ：表示 <code>Symbol.toPrimitive</code> 应该返回一个数字。</li>
<li>“string” ：表示 <code>Symbol.toPrimitvie</code> 应该返回一个字符串。</li>
<li>“default” ： 表示原样返回。</li>
</ol>
<p>在大部分的标准对象中， <code>number</code> 模式的行为按照以下的优先级来返回：  </p>
<ol>
<li>先调用 <code>valueOf()</code> 如果结果是一个原始值，返回它。</li>
<li>然后调用 <code>toString()</code> 如果结果是一个原始值，返回它。</li>
<li>否则，抛出异常。</li>
</ol>
<p>同样， <code>string</code> 模式的行为优先级如下：  </p>
<ol>
<li>先调用 <code>toString()</code> 如果结果是一个原始值，返回它。</li>
<li>然后调用 <code>valueOf()</code> 如果结果是一个原始值，返回它。</li>
<li>否则，抛出异常。</li>
</ol>
<p>在此，可以通过重写 <code>Symbol.toPrimitive</code> 方法，可以改变以上的默认行为。  </p>
<blockquote>
<p>“default” 模式仅在使用 <code>==</code>, <code>+</code> 操作符，以及调用 <code>Date</code> 构造函数的时候  </p>
<p>只传递一个参数的时候才会用到。大部分的操作都是采用的 “number” 或 “string” 模式。  </p>
</blockquote>
<p>实例：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Temperature</span>(<span class="params">degrees</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.degrees = degrees</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> freezing = <span class="keyword">new</span> Temperature(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(freezing + <span class="string">"!"</span>) <span class="comment">// [object Object]!</span></span><br><span class="line"><span class="built_in">console</span>.log(freezing / <span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(freezing)) <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>

<p>输出结果：  </p>
<p><img src="http://qiniu.ii6g.com/1561273762.png" alt="img">  </p>
<p>因为默认情况下一个对象字符串化之后会变成 <code>[object Object]</code> 这是其内部的默认<br>行为。  </p>
<p>通过重写原型上的 <code>Symbol.toPrimitive</code> 函数可以改写这种默认行为。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Temperature</span>(<span class="params">degrees</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.degrees = degrees</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Temperature.prototype[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.degrees + <span class="string">'\u00b0'</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.degrees</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.degrees + <span class="string">" degrees"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> freezing = <span class="keyword">new</span> Temperature(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(freezing + <span class="string">"!"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(freezing / <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(freezing))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>32 degrees!
16
32°</code></pre><p>结果就像我们之前分析的， 只有 <code>==</code> 和 <code>+</code> 执行的是 “default” 模式，  </p>
<p>其他情况执行的要么是 “number” 模式(如： <code>freezing / 2</code>)  </p>
<p>要么是 “string” 模式(如： <code>String(freezing)</code>)  </p>
<h3 id="Symbol-toStringTag-介绍"><a href="#Symbol-toStringTag-介绍" class="headerlink" title="Symbol.toStringTag 介绍"></a>Symbol.toStringTag 介绍<a id="orgc7b5259"></a></h3><p>在 JavaScript 的一个有趣的问题是，能同时拥有多个全局执行上下文的能力。  </p>
<p>这个发生在 web 浏览器环境下，一个页面可能包含一个 <code>iframe</code> ，因此当前页面和<br>这个 iframe 各自都拥有自己的执行环节。  </p>
<p>通常情况下，这并不是什么问题，因为数据可以通过一些手段让其它当前页和<br><code>iframe</code> 之间进行传递，问题是如何去识别这个被传递的对象是源自哪个执行环境？？  </p>
<p>比如，一个典型的问题是在 <code>page</code> 和 <code>iframe</code> 之间互相传递一个数组。在 es6 的<br>术语中， 页面和iframe 每一个都代表着一个不同的领域(<em>realm</em>, JavaScript 执行<br>环境)。每个领域都有它自己的全局作用域包含了它自己的一份全局对象的副本。  </p>
<p>无论，数组在哪个领域被创建，它都很明确的是一个数组对象，当它被传递到另一个领<br>域的时候，使用 <code>instanceof Array</code> 的结果都是 <code>false</code> ，因为数组是通过构造函<br>数在别的领域所创建的，而  </p>
<p><code>Array</code> 代表的仅仅是当前领域下的构造函数，即两个领域下的 <code>Array</code> 不是一回事。  </p>
<p><em>这就造成了在当前领域下去判断另一个领域下的一个数组变量是不是数组，得到的结<br>果将是 <code>false</code> 。</em>  </p>
<h3 id="Symbol-toStringTag-延伸-不同-realm-下的对象识别"><a href="#Symbol-toStringTag-延伸-不同-realm-下的对象识别" class="headerlink" title="Symbol.toStringTag 延伸(不同 realm 下的对象识别) "></a>Symbol.toStringTag 延伸(不同 <em>realm</em> 下的对象识别) <a id="org1d14060"></a></h3><p>对象识别的应对之策(<code>Object.prototype.toString.call(obj)</code>)  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">"[object Array]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isArray([]));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true</code></pre><p>这种方式虽然比较麻烦，但是却是最靠谱的方法。  </p>
<p>因为每个类型的 <code>toString()</code> 可能有自己的实现，返回的值是无法统一的，但是<br><code>Object.prototype.toString</code> 返回的内容始终是 <code>[object Array]</code> 这种，后面是被<br>检测数据代表的类型的构造函数，它总是能得到正确且精确的  </p>
<p>结果。  </p>
<p><code>Object.prototype.toString</code> 内部实现的伪代码：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// toString(object)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 判断 undefined 和 null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[object Undefined]'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[object Null]'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> O = ToObject(<span class="keyword">this</span>); <span class="comment">// 上下文变量对象化</span></span><br><span class="line">  <span class="keyword">let</span> isArray = IsArray(O); <span class="comment">// 先判断是不是数组类型</span></span><br><span class="line">  <span class="keyword">let</span> builtinTag = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> has = <span class="function"><span class="params">builtinName</span> =&gt;</span> !!O.builtinName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 根据内置属性，检测各对象的类型</span></span><br><span class="line">  <span class="keyword">if</span> (isArray === <span class="literal">true</span>) &#123; <span class="comment">// 数组类型</span></span><br><span class="line">    builtinTag = <span class="string">'Array'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( has([[ParameterMap]]) ) &#123; <span class="comment">// 参数列表，函数参数对象</span></span><br><span class="line">    <span class="comment">// 函数的参数 arguments 对象</span></span><br><span class="line">    builtinTag = <span class="string">'Arguments'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( has([[Call]]) ) &#123; <span class="comment">// 函数</span></span><br><span class="line">    builtinTag = <span class="string">'Function'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( has([[ErrorData]]) ) &#123; <span class="comment">// Error对象</span></span><br><span class="line">    builtinTag = <span class="string">'Error'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( has([[BooleanData]]) ) &#123; <span class="comment">// Boolean 布尔对象</span></span><br><span class="line">    builtinTag = <span class="string">'Boolean'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( has([[StringData]]) ) &#123; <span class="comment">// String 对象</span></span><br><span class="line">    builtinTag = <span class="string">'String'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( has([[DateValue]]) ) &#123; <span class="comment">// Date 对象</span></span><br><span class="line">    builtinTag = <span class="string">'Date'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( has([[RegExpMatcher]]) ) &#123; <span class="comment">// RegExp 正则对象</span></span><br><span class="line">    builtinTag = <span class="string">'RegExp'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    builtinTag = <span class="string">'Object'</span> <span class="comment">// 其他</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 最后检测 @@toStringTag - Symbol.toStringTag 的值</span></span><br><span class="line">  <span class="keyword">let</span> tag = Get(O, @@toStringTag);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Type(tag) !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    tag = builtinTag;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`[object <span class="subst">$&#123;tag&#125;</span>]`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从伪代码中我们知道，最后的实现中使用到了 <code>@@toStringTag</code> 即对应这里的<br><code>Symbol.toStringTag</code> 属性值,  </p>
<p>并且这个放在最后判断，优先级最高，即如果我们重写了 <code>Symbol.toStringTag</code> 那么<br>重写之后的返回值将最优先返回。  </p>
<h3 id="Symbol-toStringTag-的-ES6-实现"><a href="#Symbol-toStringTag-的-ES6-实现" class="headerlink" title="Symbol.toStringTag 的 ES6 实现"></a>Symbol.toStringTag 的 ES6 实现</h3><p>正如 <a href="#org1d14060">7.7.6</a> 中的伪代码所示，在 es6 中对于<br><code>Object.prototype.toString.call(obj)</code> 的实现中加入了 <code>@@toStringTag</code> 内部属<br>性的检测，即对应着这里的 <code>Symbol.toStringTag</code> ，那么我们便  </p>
<p>可以通过改变这个值来修改它的默认行为，从而得到我们想要的类型值。  </p>
<p>比如：我们有一个 <code>Person</code> 构造函数，我们希望在使用 <code>toString()</code> 的时候得到结<br>果是 <code>[object Person]</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'Person'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">'xxx'</span>)</span><br><span class="line"></span><br><span class="line">Person.prototype.toString = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'[object Test]'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.toString()) <span class="comment">// [object Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(me)) <span class="comment">// [object Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(me.toString === <span class="built_in">Object</span>.prototype.toString) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: 未重写 Person.prototype.toString 结果  </p>
<pre><code>[object Person]
[object Person]
true</code></pre><p>+RESULTS: 重写 Person.prototype.toString 的结果  </p>
<pre><code>[object Test]
[object Person]
false</code></pre><p>我们发现就算重写了 <code>Person.prototype.toString</code> 也不会影响<br><code>Symbol.toStringTag</code> 赋值后的运行结果，如后面调用<br><code>Object.prototype.toString.call(me)</code> 结果依旧是 <code>[object Person]</code> 。  </p>
<p>因为我们重写了 <code>Symbol.toStringTag</code> 属性值，因此<a href="#org1d14060">7.7.6</a>实现部分：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 最后检测 @@toStringTag - Symbol.toStringTag 的值</span></span><br><span class="line"><span class="keyword">let</span> tag = Get(O, @@toStringTag); <span class="comment">// 这里的结果就成了 'Person'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Type(tag) !== <span class="string">'string'</span>) &#123;</span><br><span class="line">  tag = builtinTag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">`[object <span class="subst">$&#123;tag&#125;</span>]`</span></span><br></pre></td></tr></table></figure>

<p>因此得到 <code>[object Person]</code> 返回结果。  </p>
<p>我们还可以通过重写 <code>Person</code> 自身的 <code>toString()</code> 的实现让其拥有自己的默认行为，<br>上面的第三行  </p>
<p>结果表明 <code>me.toString()</code> 最终调用的是 <code>Object.prototype.toString</code> 。  </p>
<h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables<a id="orgf7af38d"></a></h3><p><code>with</code> 语句在 JavaScript 世界中是最具争议的一项特性之一。  </p>
<p>原本设计的初衷是避免重复书写一样的代码，但是在实际使用过程中，却是让代码更难<br>理解，很容易出错，也有性能上的影响。  </p>
<p>虽然，极力不推荐使用它，但是在 es6 中为了考虑向后兼容性问题，在非严格模式下<br>依旧对它做了支持。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    colors = [<span class="string">"red"</span>, <span class="string">"green"</span>],</span><br><span class="line">    color = <span class="string">"black"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(colors) &#123;</span><br><span class="line">  push(color);</span><br><span class="line">  push(...values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.toString())</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>red,green,black,1,2,3</code></pre><p>上面代码，在 <code>with</code> 里面调用的两次 <code>push</code> 等价于 <code>colors.push</code> 调用，  </p>
<p>因为 <code>with</code> 将本地执行上下文绑定到了 <code>colors</code> 上。  </p>
<p><code>values, color</code> 指向的均是在 <code>with</code> 语句外面创建的 <code>values</code> 和 <code>color</code> 。  </p>
<p>但是在 ES6 中给数组增加了一个 <code>values</code> 方法，这个方法会返回当前数组的迭代器<br>对象： <code>Array Iterator {}</code>  </p>
<p>这就意味着在 ES6 的环境中， <code>values</code> 指向的将是数组本身的 <code>values()</code> 方法而<br>不是外面声明的 <code>values = [1, 2, 3]</code> 这个数组，将破坏整个代码的运行。  </p>
<p>这就是 <code>Symbol.unscopables</code> 存在的原因。  </p>
<p><code>Symbol.unscopables</code> 被用在 <code>Array.prototype</code> 上用来指定那些属性不能在<br><code>with</code> 中创建绑定：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// built into ECMAScript 6 by default</span></span><br><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables] = <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(<span class="literal">null</span>), &#123;</span><br><span class="line">  copyWithin: <span class="literal">true</span>,</span><br><span class="line">  entries: <span class="literal">true</span>,</span><br><span class="line">  fill: <span class="literal">true</span>,</span><br><span class="line">  find: <span class="literal">true</span>,</span><br><span class="line">  findIndex: <span class="literal">true</span>,</span><br><span class="line">  keys: <span class="literal">true</span>,</span><br><span class="line">  values: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面是默认情况下 ES6 内置的设定，即数组中的上列属性不允许在 <code>with</code> 中创建绑<br>定，从列表能发现这些被置为 <code>true</code> 的属性都是 <code>es6</code> 中新赠的方法，这主要是为<br>了兼容以前的代码只针对新增的属性这么使用。  </p>
<p>#+BIGIN<sub>QUOTE</sub><br>一般情况下，不需要重新定义 <code>Symbol.unscopables</code> ，除非代码中存在 <code>with</code> 语句并且  </p>
<p>需要做一些特殊处理的时候，但是建议尽量避免使用 <code>with</code> 。<br>#+END<sub>QUOTE</sub>  </p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Symbols 是一种新的原始值类型，用来创建一些属性，这些属性只能使用对应的符号<br>或符号变量去访问。</li>
<li><code>Symbol([description])</code> 用来创建一个符号，推荐传入描述，便于识别。</li>
<li><code>Symbol.for(key)</code> 首先查找注册表(GSR)，如果 <code>key</code> 对应的符号存在直接返回，<br>如果不存在则创建新符号并加入到注册表，然后返回新创建的符号。</li>
<li><code>Symbol.keyFor(symbolValue)</code> 通过符号变量从注册表中找到对应的符号值，没有<br>返回 <code>undefined</code> 。</li>
<li>符号共享通过 <code>Symbol.for(key)</code> 和 <code>Symbol.keyFor(symbolValue)</code> 可以让符号<br>达到共享的目的，因为全局注册表在所有代码运行之前就已经创建好了。</li>
<li>符号不允许类型转换(或隐式转换)。</li>
<li><code>Object.keys()</code> 和 <code>Object.getOwnPropertyNames()</code> 不能获取到符号属性。</li>
<li><code>Object.getOwnPropertySymbols(obj)</code> 能获取到对象的所有符号属性。</li>
<li><code>Object.defineProperty()</code> 和 <code>Object.defineProperties()</code> 对符号属性也有效。</li>
<li>知名符号<a href="#org3f0983b">7.7</a>，以往的内部实现是不对开发者开放的，如今有了这些知名<br>符号属性，可以让开发者自信改变一些功能和接口的默认行为。</li>
</ol>
<h1 id="Sets-和-Maps"><a href="#Sets-和-Maps" class="headerlink" title="Sets 和 Maps"></a>Sets 和 Maps</h1><ul>
<li><em>set</em> 集合是一组没有重复元素的一个序列。</li>
<li><em>map</em> key 值得集合，指向对应的值</li>
</ul>
<h2 id="ECMAScript-5-中的-Sets-和-Maps"><a href="#ECMAScript-5-中的-Sets-和-Maps" class="headerlink" title="ECMAScript 5 中的 Sets 和 Maps"></a>ECMAScript 5 中的 Sets 和 Maps</h2><p>在 es6 之前会有各种 sets/maps 的实现方式，但是大都或多或少有所缺陷。  </p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>比如： 使用对象属性实现  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> st = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.foo = true</span><br><span class="line"></span><br><span class="line">if (<span class="keyword">set</span>.foo) &#123;</span><br><span class="line">  <span class="comment">// sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在将对象作为 set 或 map 使用的时候唯一的区别在于：  </p>
<p><em>map</em> 里面的 key 有存储对应的具体内容，而不像 <em>set</em> 仅仅用来存储 true or false,  </p>
<p>用来标识 key 是否存在。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">map.foo = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value = map.foo</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 'bar'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>bar</code></pre><h3 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h3><p>使用对象实现 set/map 的问题：  </p>
<ol>
<li>无法避免字符串 key 的唯一性问题</li>
<li>无法避免对象作为 key 的唯一性问题</li>
</ol>
<p><strong>字符串作为 key</strong> :  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">map[<span class="number">5</span>] = <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="string">"5"</span>]) <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>foo</code></pre><p>因为对于对象来说，使用数字下表去访问的时候，实际上是将下标数值转成字符串去访问了，  </p>
<p>即相当于 <code>map[5]</code> 等价于 <code>map[&#39;5&#39;]</code> 因此，有上面的结果输出。  </p>
<p><em>但是，你偏偏想使用 5 和 ‘5’ 去标识两个 key 的时候就无法达到目的了。</em>  </p>
<p><strong>对象作为 key</strong> :  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">    key1 = &#123;&#125;,</span><br><span class="line">    key2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">map[key1] = <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map[key2]) <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>foo</code></pre><p>对象作为 <code>key</code> 值得时候，内部会发生类型转换，将对象转成 <code>&quot;[object Object]&quot;</code>  </p>
<p>因此无论用 key1 还是 key2 去访问 map ，最后的结果都是 <code>map[&quot;[object
    Object]&quot;]</code> 去访问了  </p>
<p>因此，结果都是 ‘foo’。  </p>
<h2 id="Sets-集合"><a href="#Sets-集合" class="headerlink" title="Sets 集合"></a>Sets 集合</h2><ol>
<li>创建使用 <code>new Set()</code> 创建实例。</li>
<li>添加使用 <code>set.add()</code> 方法。</li>
<li>集合区分数值的数字类型和字符串类型，不会发生类型强转。</li>
<li><code>-0</code> 和 <code>+0</code> 在集合中会被当做一样处理</li>
<li>对象可以作为 set 的元素，且两个 <code>{}</code> 会被当做两个不同的元素处理</li>
</ol>
<h3 id="set-初始化"><a href="#set-初始化" class="headerlink" title="set 初始化"></a>set 初始化</h3><p><code>new Set()</code> 创建了一个空的 <code>set</code>  </p>
<p>可以在初始化的时候传入一个数组。  </p>
<blockquote>
<p>实际上， <code>Set</code> 构造函数可以接受任意一个 <code>iterable</code> 对象作为参数。  </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4])</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 4</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>4</code></pre><h3 id="添加元素-set-add"><a href="#添加元素-set-add" class="headerlink" title="添加元素 set.add()"></a>添加元素 <code>set.add()</code></h3><p>添加的元素区分类型，不会做类型转换，即 <code>5</code> 和 <code>&#39;5&#39;</code> 是不一样的，重复添加也只<br>会执行一次，=set= 的元素是不会重复的。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add('5')</span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size, <span class="keyword">set</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2 Set { 5, &apos;5&apos; }</code></pre><p>对象元素：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(),</span><br><span class="line">    key1 = &#123;&#125;,</span><br><span class="line">    key2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key1)</span><br><span class="line"><span class="keyword">set</span>.add(key2)</span><br><span class="line"><span class="keyword">set</span>.add(key1)</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 2</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2</code></pre><h3 id="set-apis"><a href="#set-apis" class="headerlink" title="set apis"></a>set apis</h3><ol>
<li><code>set.has(v)</code> 判断 set 中是否有元素 <code>v</code> ，返回 <code>true/false</code></li>
<li><code>set.add(v)</code> 添加元素</li>
<li><code>set.size</code> 集合大小</li>
<li><code>set.delete(v)</code> 删除元素</li>
<li><code>set.clear()</code> 清空集合</li>
</ol>
<h3 id="集合迭代-forEach"><a href="#集合迭代-forEach" class="headerlink" title="集合迭代(forEach)"></a>集合迭代(forEach)</h3><p>对集合使用 <code>forEach</code> 和对数组使用的方法一样，它接受一个函数，抓个函数又三个<br>参数：  </p>
<ol>
<li>第一个参数：集合的当前值</li>
<li>第二个参数：和第一个参数一样是当前元素的值，跟数组不一样，数组使用<br><code>forEach</code> 这个参数是当前索引值</li>
<li>第三个参数：被遍历的集合本身。</li>
</ol>
<p><strong>Sets 没有 Key 值。</strong>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['a', 'b', 'c', 'd', 'e'])</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>[0]) // undefined, 没有下标值</span><br><span class="line"><span class="keyword">set</span>.forEach(function(idx, v, ownerSet) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(idx, v, ownerSet === <span class="keyword">set</span>, ownerSet)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>undefined
a a true Set { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; }
b b true Set { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; }
c c true Set { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; }
d d true Set { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; }
e e true Set { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; }</code></pre><p>结果所示：  </p>
<ol>
<li>集合的 key 就是 value。</li>
<li>遍历的函数第三个参数 <code>ownerSet</code> 就是被遍历的 <code>set</code> 集合本身。</li>
</ol>
<p>在使用 <code>forEach</code> 可以给它传递一个上下文参数，让绑定回调函数里面的 <code>this</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1,2])</span><br><span class="line"></span><br><span class="line">let processor = &#123;</span><br><span class="line">  output(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'output from processor: '</span> + value)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  process(dataSet, scope = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      output(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'output from obj: '</span> + value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dataSet.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.output(value)</span><br><span class="line">    &#125;, scope === <span class="number">1</span> ? <span class="keyword">this</span> : obj)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processor.process(<span class="keyword">set</span>) // scope: processor</span><br><span class="line">processor.process(<span class="keyword">set</span>, 2) // scope: obj</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>output from processor: 1
output from processor: 2
output from obj: 1
output from obj: 2</code></pre><ol>
<li>将 <code>this</code> 传递给回调，从而 <code>output</code> 来自 <code>processor</code> 。</li>
<li>将 <code>obj</code> 传递给回调，从而 <code>output</code> 来自 <code>obj</code> 。</li>
</ol>
<p>结论：*我们可以通过给 forEach 传递第二个参数来改变回调函数的执行上下文。*  </p>
<p>使用箭头函数解决 <code>this</code> 指向问题：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1,2])</span><br><span class="line"></span><br><span class="line">let processor = &#123;</span><br><span class="line">  output(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'output from processor: '</span> + value)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  process(dataSet) &#123;</span><br><span class="line">    <span class="comment">// this 总是绑定到 processor</span></span><br><span class="line">    dataSet.forEach(<span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">this</span>.output(value), &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processor.process(<span class="keyword">set</span>) // scope: processor</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>output from processor: 1
output from processor: 2</code></pre><p>无论第二个参数 <code>{}</code> 传或不传结果都一样，箭头函数里的 <code>this</code> 指向不会发生改变。  </p>
<blockquote>
<p>集合不能直接使用索引访问元素，如果需要使用到索引访问元素，那最好将集合转成数组来使用。  </p>
</blockquote>
<h3 id="Set-和-Array-之间的转换"><a href="#Set-和-Array-之间的转换" class="headerlink" title="Set 和 Array 之间的转换"></a>Set 和 Array 之间的转换</h3><ol>
<li>集合转数组 <code>let set = new Set([1, 2, 3, 2]);</code> ，且会将重复的元素去掉只余<br>一个。</li>
<li>数组转集合，最简单的就是展开符了 <code>let arr = [...set];</code></li>
</ol>
<p><em>展开符(&#x2026;)可以作用域任何 iterable 的对象。即任何可 iterable 的对象都可以通<br>过 <code>...</code> 转成数组。</em>  </p>
<p>也因为有了 <code>Set</code> 和 <code>...</code> 从而是数组的去重变得异常简单:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> eleminateDuplicates = <span class="function"><span class="params">items</span> =&gt;</span> [...new <span class="built_in">Set</span>(items)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eleminateDuplicates(nums).toString())</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1,2,3,4</code></pre><h3 id="弱集-Weak-Sets"><a href="#弱集-Weak-Sets" class="headerlink" title="弱集(Weak Sets)"></a>弱集(Weak Sets)</h3><p>因为它存储对象引用的方式，集合类型也可以叫做强集合类型。  </p>
<p>即集合中对于对象的存储是存储了该对象的引用而不是被添加到集合是的那个变量名而<br>已，类似对象的属性的值为对象一样，就算改变了这个属性的值，那个对象如果有其他<br>变量指向它，那他一样存在（类似 C 的指针概念，两个指针同时指向一块内存，一个<br>指针的指向发生变化并不会影响另一个指针指向这块内存）。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  dog: &#123;</span><br><span class="line">    name: <span class="string">'xxx'</span>,</span><br><span class="line">    age: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog1 = animal.dog</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1.name) <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="comment">// 引用发生变化</span></span><br><span class="line">animal.dog = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不影响别的变量指向 &#123; name: 'xxx', age: 10 &#125; 这个对象</span></span><br><span class="line"><span class="built_in">console</span>.log(dog1.age) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指回去，依旧是它原来指向的那个对象</span></span><br><span class="line">animal.dog = dog1</span><br><span class="line"><span class="built_in">console</span>.log(animal.dog.name) <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.dog.age) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>xxx
10
xxx
10</code></pre><p>根据引用的特性，对于集合元素也一样实用：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">let key = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key) // 实际将对象的引用加到集合中</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>) // 1</span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 1</span><br><span class="line"></span><br><span class="line">key = null // 改变了变量值而已，实际引用的那个对象还在</span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 1</span><br><span class="line"></span><br><span class="line">key = [...<span class="keyword">set</span>][0]</span><br><span class="line"></span><br><span class="line">console.log(key)// &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Set { {} }
1
1
{}
undefined</code></pre><p>这种强引用在某些情况下很可能会出现内存泄漏，比如，在浏览器环境中  </p>
<p>集合中保存了一些 DOM 元素的引用，而这些元素本身可能会被其他地方的  </p>
<p>代码从 DOM 树中移除，同时你也不想再保有这些 DOM 元素的引用了，或者说以后  </p>
<p>都不会用到它了，应该被释放回收才对，但是实际上集合中仍然保有这些元素的引用<br>(实际已经不存在的东西)，这种情况就叫做内存泄漏(<em>memory leak</em>)。  </p>
<p>为了解决这种情况， ECMAScript 6 中增加了一种集合类型： <em>weak sets</em> ,弱引用只<br>会保存对象的弱引用 。  </p>
<h3 id="创建-Weak-Sets-WeakSet"><a href="#创建-Weak-Sets-WeakSet" class="headerlink" title="创建 Weak Sets(WeakSet)"></a>创建 Weak Sets(<code>WeakSet</code>)</h3><p>弱引用集合构造函数： <code>WeakSet</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet(),</span><br><span class="line">    key = &#123;&#125;, key1 = key</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>)</span><br><span class="line">key = null</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key))</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key1))</span><br><span class="line">console.log(<span class="keyword">set</span>.has(null))</span><br><span class="line">console.log(<span class="keyword">set</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>WeakSet { [items unknown] }
false
true
false
WeakSet { [items unknown] }
undefined</code></pre><p>浏览器环境输出结果：  </p>
<p><img src="http://qiniu.ii6g.com/1561596922.png" alt="img">  </p>
<h2 id="Set-和-WeakSet-对比"><a href="#Set-和-WeakSet-对比" class="headerlink" title="Set 和 WeakSet 对比"></a>Set 和 WeakSet 对比<a id="org08033ce"></a></h2><p>Set 中添加对象，添加的是对该对象的引用，因此保存该对象的变量值发生变化，并不<br>影响该对象在集合中的事实。  </p>
<p>WeakSet 中添加的是该变量的原始值？？变量值一旦改变，集合中的内容将随之改变(由<br>JavaScript 引擎处理)。  </p>
<blockquote>
<p>TODO: Set 保存引用？WeekSet 保存原始值？？有啥区别？？  </p>
</blockquote>
<p>这里我们将对比两种集合在不同形式下的运行结果，通过对比分析来搞清楚集合中引用<br>和原始值的概念。  </p>
<h3 id="Set-WeakSet-添加对象的结果"><a href="#Set-WeakSet-添加对象的结果" class="headerlink" title="Set, WeakSet 添加对象的结果"></a>Set, WeakSet 添加对象的结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">let key = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line">console.log(<span class="keyword">set</span>)</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)) // true</span><br><span class="line"></span><br><span class="line">let wset = new WeakSet()</span><br><span class="line">let wkey = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">wset.add(wkey)</span><br><span class="line"><span class="built_in">console</span>.log(wset)</span><br><span class="line"><span class="built_in">console</span>.log(wset.has(wkey))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Set { { a: 1 } }
true
WeakSet { [items unknown] }
true
undefined</code></pre><p>这里 WeakSet 结果不直观，下面是浏览器结果：  </p>
<p><img src="http://qiniu.ii6g.com/1561597399.png" alt="img">  </p>
<p>从浏览器端的结果分析：  </p>
<ol>
<li>两者在内部属性 <code>Entries</code> 中都有一个我们添加的 <code>{a : 1}</code> 对象元素。</li>
<li>WeakSet 没有 size 属性， Set 有 size 属性。</li>
</ol>
<h3 id="改变对象-key-wkey-的值"><a href="#改变对象-key-wkey-的值" class="headerlink" title="改变对象 key/wkey 的值"></a>改变对象 key/wkey 的值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">let key = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line">console.log(<span class="keyword">set</span>) // 改变之前</span><br><span class="line">key = null</span><br><span class="line">console.log(<span class="keyword">set</span>) // 改变之后</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)) // true</span><br><span class="line"></span><br><span class="line">let wset = new WeakSet()</span><br><span class="line">let wkey = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">wset.add(wkey)</span><br><span class="line"><span class="built_in">console</span>.log(wset) <span class="comment">// weak key 改变之前</span></span><br><span class="line">wkey = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(wset) <span class="comment">// weak key 改变之后</span></span><br><span class="line"><span class="built_in">console</span>.log(wset.has(wkey))</span><br></pre></td></tr></table></figure>

<p>+RESULTS: emacs nodejs  </p>
<pre><code>Set { { a: 1 } }
Set { { a: 1 } }
false
WeakSet { [items unknown] }
WeakSet { [items unknown] }
false
undefined</code></pre><p>浏览器环境输出结果：  </p>
<p><img src="http://qiniu.ii6g.com/1561597936.png" alt="img">  </p>
<p>结果：  </p>
<ol>
<li><p>对于 Set 对象变量 key 值得改变并不会影响 Set 中 <code>{a:1}</code> 对象  </p>
<p>Set 存放的是对象 <code>{a:1}</code> 的引用，即在 <code>set.add(key)</code> 之后，实际上是有两个引用指向了<br><code>{a:1}</code> 对象，一个是 key 这个变量，一个是集合 set 中的某个位置上的变量(假设为: <em>fkey</em>)。<br>根据引用的特性， key 的释放并不会影响 <code>{a:1}</code> 这个对象本身在内存中的存在，即不会影响 fkey<br>对这个对象的影响，从而并不影响 set 的内容。</p>
</li>
<li><p>WeakSet 中的 <code>{a:1}</code> 没有了  </p>
<p>WeakSet 我们说它添加的是 wkey 的原始值，即使直接和 wkey 这个变量的原始值挂钩的，<br>执行 <code>wkey = null</code> 就是讲它的原始值发生改变，最终将影响 WeakSet 。</p>
</li>
</ol>
<p>针对 #2 中的 WeakSet 情况，将程序改造一下:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">let key = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> key1 = key</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line">console.log(<span class="keyword">set</span>) // 改变之前</span><br><span class="line">key = null</span><br><span class="line">console.log(<span class="keyword">set</span>) // 改变之后</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)) // true</span><br><span class="line"></span><br><span class="line">console.log('-------- 楚河汉界 ---------')</span><br><span class="line">let wset = new WeakSet()</span><br><span class="line">let wkey = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> wkey1 = wkey</span><br><span class="line"></span><br><span class="line">wset.add(wkey)</span><br><span class="line"><span class="built_in">console</span>.log(wset) <span class="comment">// weak key 改变之前</span></span><br><span class="line">wkey = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(wset) <span class="comment">// weak key 改变之后</span></span><br><span class="line"><span class="built_in">console</span>.log(wset.has(wkey))</span><br><span class="line"><span class="built_in">console</span>.log(wset.has(wkey1))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Set { { a: 1 } }
Set { { a: 1 } }
false
-------- 楚河汉界 ---------
WeakSet { [items unknown] }
WeakSet { [items unknown] }
false
true
undefined</code></pre><p>再来看看输出结果：  </p>
<p><img src="http://qiniu.ii6g.com/1561598712.png" alt="img">  </p>
<p>我们得到了令人意外的结果：  </p>
<ol>
<li>并没有显示的 <code>wset.add(wkey1)</code> 但是最后的 <code>wset.has(wkey1)</code> 的结果却是 <code>true</code> 。</li>
<li>wset 集合中的 <code>{a:1}</code> 依然存在。</li>
</ol>
<p>要理解这个问题，则需要知道“强引用”和“弱引用”的区别：  </p>
<h3 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h3><p>我们都知道 JavaScript 的垃圾回收机制中有一个相关知识点就叫做引用计数，即一个<br>对象如果有被其他变量  </p>
<p>引用那么这个对象的引用计数就 <code>+1</code> 如果这个变量被释放该对象的引用计数就 <code>-1</code><br>一旦引用计数为 <code>0</code> 垃圾回收机制就会将这个对象回收掉，因为没有人再使用它了。  </p>
<p><strong>强引用(<code>Set</code>)</strong> ：相当于让该对象的引用计数 <code>+1</code> ，如 <code>Set</code> 集合保存了对象的引用导<br>致引用计数 <code>+1</code> ，在拥有该对象的变量 <code>key</code> 的值怎么变化都不会导致引用计数为<br><code>0</code> 从而阻止了垃圾回收器将其回收掉。  </p>
<p><strong>弱引用(<code>WeakSet</code>)</strong>: 对对象的引用不会计入到引用计数中，即将 wkey 加入到<br>WeakSet 中，并不会引起 wkey 指向的那个对象的引用计数 <code>+1</code> ，因此只要释放了<br>wkey 对其的引用，对象的引用计数就变成 0 了，因此此时只有 wkey 指向 <code>{a:1}</code><br>这个对象，改变 wkey 就会改变 WeakSet 中的内容，因为这个内容已经被回收掉了。  </p>
<p>/根据上面的结论，我们就知道为什么我们增加了一行 <code>let key1 = key</code> 之后，<br><code>{a:1}</code> 对象依然会在 <code>wset</code> 中因为此时 <code>{a:1}</code> 引用计数不为 <code>0</code> 并没有被释放<br>掉。/  </p>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>es6 的 <code>Map</code> 类型是一个有序的键值对列表， key 和 value 可以是任意类型，并且 key<br>不会发生类型强转，也就是说 <code>5</code> 和 <code>&quot;5&quot;</code> 属于不同的两个键，和对象不一样(对象把他<br>们当做一个键，因为对象的 key 最终表示形式为 <code>string</code> 内部有发生强制转换)。  </p>
<h3 id="Map-初始化"><a href="#Map-初始化" class="headerlink" title="Map 初始化"></a>Map 初始化</h3><p>一个 map 实例必须通过构造函数来创建 <code>new Map()</code> ，同时可以给构造函数传递一个<br>iterable 的对象，在创建的时候初始化，这个 iterable 对象会被转成 map。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'张三'</span>], [<span class="string">'age'</span>, <span class="number">25</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'name'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'name'</span>)) <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'age'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'age'</span>)) <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 一维数组，不符合 entry object</span></span><br><span class="line">  <span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">  <span class="built_in">console</span>.log(map1)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 对象非 iterable</span></span><br><span class="line">  <span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(map2)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> map3 = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="keyword">new</span> <span class="built_in">Set</span>([[<span class="string">'name'</span>, <span class="string">'张三'</span>, <span class="number">1</span>], [<span class="string">'age'</span>, <span class="number">25</span>, <span class="number">2</span>]]))</span><br><span class="line">  <span class="built_in">console</span>.log(map3)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> map4 = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'name'</span>, <span class="string">'张三'</span>]))</span><br><span class="line">  <span class="built_in">console</span>.log(map4)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> map5 = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="keyword">new</span> <span class="built_in">Set</span>([[<span class="string">'name'</span>, <span class="string">'张三'</span>], [<span class="string">'age'</span>, <span class="number">25</span>]]))</span><br><span class="line">  <span class="built_in">console</span>.log(map5)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Map { &apos;name&apos; =&gt; &apos;张三&apos;, &apos;age&apos; =&gt; 25 }
true
张三
true
25
2
Iterator value 1 is not an entry object
#&lt;Object&gt; is not iterable
Map { &apos;name&apos; =&gt; &apos;张三&apos;, &apos;age&apos; =&gt; 25 }
Iterator value name is not an entry object
Map { &apos;name&apos; =&gt; &apos;张三&apos;, &apos;age&apos; =&gt; 25 }
undefined</code></pre><p>因此能被转成 <code>map</code> 的对象需要满足：  </p>
<ol>
<li>必须是 iterable</li>
<li>必须有键值对类型的列表对象，比如二维数组。</li>
</ol>
<p>Map 的 key 和 value 可以是任意对象。  </p>
<p><a id="orgde6b501"></a>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">map.set(&#123;&#125;, <span class="string">'EmptyObject'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然都是 &#123;&#125; 但是对象是引用类型，是不能等同的</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(&#123;&#125;)) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">map.clear()</span><br><span class="line"><span class="keyword">let</span> emptyObj = &#123;&#125;</span><br><span class="line">map.set(emptyObj, <span class="string">'EmptyObject'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br><span class="line"><span class="built_in">console</span>.log(map.get(emptyObj)) <span class="comment">// 'EmptyObject'</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">emptyObj = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br><span class="line"><span class="built_in">console</span>.log(map.get(emptyObj)) <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 1, 因为 Map 是强引用，emptyObj = null 并不会改变</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>undefined
Map { {} =&gt; &apos;EmptyObject&apos; }
EmptyObject
1
Map { {} =&gt; &apos;EmptyObject&apos; }
undefined
1
undefined</code></pre><h3 id="map-set-key-value-和-map-get-key"><a href="#map-set-key-value-和-map-get-key" class="headerlink" title="map.set(key, value) 和 map.get(key)"></a><code>map.set(key, value)</code> 和 <code>map.get(key)</code></h3><p><code>Map</code> 实例可以通过 <code>set</code> 和 <code>get</code> 方法去设置键值对然后获取该值。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">'title'</span>, <span class="string">'u es6'</span>)</span><br><span class="line">map.set(<span class="string">'year'</span>, <span class="number">2019</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'title'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'year'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Map { &apos;title&apos; =&gt; &apos;u es6&apos;, &apos;year&apos; =&gt; 2019 }
u es6
2019
undefined
undefined</code></pre><p>map 数据的内部存储格式(<code>{ &#39;key&#39; =&gt; value }</code>)：  </p>
<p><img src="http://qiniu.ii6g.com/1561607782.png" alt="img">  </p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>map.has(key)</code> 检测 map 中是否存在 key</li>
<li><code>map.delete(key)</code> 删除 key 对应的值</li>
<li><code>map.clear()</code> 清空所有键值对</li>
<li><code>map.size</code> map 的大小，键值对的个数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'张三'</span>)</span><br><span class="line">map.set(<span class="string">'age'</span>, <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-------- init ---------'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'name'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'name'</span>)) <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'age'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'age'</span>)) <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-------- delete ---------'</span>)</span><br><span class="line">map.delete(<span class="string">'name'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'name'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'name'</span>)) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-------- clear ---------'</span>)</span><br><span class="line">map.clear()</span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'name'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'name'</span>)) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'age'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'age'</span>)) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>-------- init ---------
Map { &apos;name&apos; =&gt; &apos;张三&apos;, &apos;age&apos; =&gt; 22 }
2
true
张三
true
22
-------- delete ---------
Map { &apos;age&apos; =&gt; 22 }
false
undefined
1
-------- clear ---------
Map {}
false
undefined
false
undefined
0
undefined</code></pre><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code> 在 map 上的使用方式跟集合和数组类似，回调接受三个参数分别代表：  </p>
<ol>
<li>value: 代表当前循环 map 中元素键值中的值</li>
<li>key: 代表 map 元素键值中的键</li>
<li>map: 当前的 map 自身</li>
</ol>
<p>因此， map 的 <code>forEach</code> 看起来与数组更像，有 <code>value</code>, <code>key</code>, <code>map</code> ，并且 value<br>代表值，key 表示键（数组中的索引），map 代表自身。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'张三'</span>], [<span class="string">'age'</span>, <span class="number">22</span>]])</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, ownerMap</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(ownerMap === map)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>name: 张三
true
age: 22
true
undefined</code></pre><p>和 Set 一样，也可以将 <code>this</code> 作为第二个参数传入，绑定回调函数的上下文，或者直接<br>使用箭头函数，就可以省略这个参数了。  </p>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><code>WeakMap</code> 类似 <code>WeakSet</code> 一样，是一种弱引用类型。  </p>
<p>有了<a href="#org08033ce">8.3</a>的说明，理解将让我们很容易理解 <code>WeakMap</code> 。  </p>
<div class="org-center">
**WeakMap 弱引用，即它里面的引用类型，不计入引用计数统计，不会阻止垃圾回收器回收。**  
</div>

<p>看下 <a href="#orgde6b501">8.4.1</a> 的示例，将 <code>Map</code> 改成 <code>WeakMap</code> 看下结果：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  map.clear()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emptyObj = &#123;&#125;</span><br><span class="line">map.set(emptyObj, <span class="string">'EmptyObject'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map.get(emptyObj)) <span class="comment">// 'EmptyObject'</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">emptyObj = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(emptyObj)) <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">map.delete(emptyObj)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">map.set(obj, <span class="string">'NormalObject'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map.get(obj))</span><br><span class="line">map.delete(obj)</span><br><span class="line"><span class="built_in">console</span>.log(map.get(obj))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>map.clear is not a function
EmptyObject
undefined
undefined
undefined
NormalObject
undefined</code></pre><ol>
<li>WeakMap 中没有 <code>map.clear()</code></li>
<li>WeakMap 没有 <code>size</code> 属性，和 WeakSet 一样</li>
<li>弱引用， <code>emptyObj = null</code> 会使 map 中的 emptyObj 被删除</li>
</ol>
<h1 id="迭代器和生成器-Iterators-amp-Generators"><a href="#迭代器和生成器-Iterators-amp-Generators" class="headerlink" title="迭代器和生成器(Iterators &amp; Generators)"></a>迭代器和生成器(Iterators &amp; Generators)<a id="orge26ee44"></a></h1><h2 id="什么是迭代器-Iterators-？"><a href="#什么是迭代器-Iterators-？" class="headerlink" title="什么是迭代器(Iterators)？"></a>什么是迭代器(Iterators)？</h2><p>迭代器：拥有特殊接口(用来遍历该对象)的一些对象。  </p>
<p>所有迭代器对象都有一个 <code>next()</code> 方法返回一个结果对象。  </p>
<p>该结果对象包含两个属性：  </p>
<ol>
<li><code>value</code> 迭代过程中下一个值</li>
<li><code>done</code> , <em>boolean</em> 是否是最后一个</li>
</ol>
<p>迭代器拥有一个内部指针指向总是指向下一个值。  </p>
<p>创建一个迭代器：  </p>
<ol>
<li>返回对象中必须有 <code>next()</code> 方法</li>
<li>必须有终结条件属性 <code>done</code></li>
</ol>
<p><a id="org2892a08"></a>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> done = ( i &gt;= items.length);</span><br><span class="line">      <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done, value</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ done: false, value: 1 }
{ done: false, value: 2 }
{ done: false, value: 3 }
{ done: true, value: undefined }
{ done: true, value: undefined }
{ done: true, value: undefined }</code></pre><h2 id="什么是生成器-Generators-？"><a href="#什么是生成器-Generators-？" class="headerlink" title="什么是生成器(Generators)？"></a>什么是生成器(Generators)？</h2><p>生成器：一个返回迭代器的函数。  </p>
<p>生成器声明方式： <code>function *createIterator() {}</code> ，使用 <code>*fnName</code> 方式。  </p>
<p>它的返回值也是一个迭代器，里面使用 <code>yield</code> 关键词暂停语句。  </p>
<p><a id="orgac453ee"></a>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: undefined, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }</code></pre><p>跟 <a href="#org2892a08">9.1</a> 结果一样。  </p>
<p>生成器函数与普通函数区别：  </p>
<ol>
<li>使用星号(<code>*</code>) 加名字声明</li>
<li>返回值是一个迭代器 <em>iterator</em></li>
<li>只有使用迭代器调用了 <code>next()</code> 才会返回值，该值为函数中 <code>yield</code> 关键词语句对应</li>
</ol>
<p><code>yield</code> 告诉引擎，我在这里要暂停下，如果要我继续下去，就请用我返回的迭代器调用下<br><code>next()</code> 获取当前 <code>yield</code> 暂停地方的返回结果。  </p>
<h3 id="循环中的-yield"><a href="#循环中的-yield" class="headerlink" title="循环中的 yield"></a>循环中的 yield</h3><p><code>yield</code> 关键词可以用于任意值或语句，比如：循环中使用 <code>yield</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> items[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: undefined, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }</code></pre><h3 id="两个-yield-之间有多个语句"><a href="#两个-yield-之间有多个语句" class="headerlink" title="两个 yield 之间有多个语句"></a>两个 yield 之间有多个语句</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i, <span class="string">'i'</span>);</span><br><span class="line">    <span class="keyword">yield</span> items[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">//console.log(iterator.next()) // &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="comment">//console.log(iterator.next()) // &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="comment">// console.log(iterator.next()) // &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// console.log(iterator.next()) // &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// console.log(iterator.next()) // &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>yield</code> 在 <code>console.log</code> 语句之后的结果分析：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(i, <span class="string">'i'</span>);</span><br><span class="line"><span class="keyword">yield</span> items[i];</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>next() 个数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>console.log(iterator.next()) * 0</code></td>
<td>:</td>
</tr>
<tr>
<td><code>console.log(iterator.next()) * 1</code></td>
<td>: 0 ‘i’</td>
</tr>
<tr>
<td></td>
<td>: { value: 1, done: false }</td>
</tr>
<tr>
<td><code>console.log(iterator.next()) * 2</code></td>
<td>: 0 ‘i’</td>
</tr>
<tr>
<td></td>
<td>: { value: 1, done: false }</td>
</tr>
<tr>
<td></td>
<td>: 1 ‘i’</td>
</tr>
<tr>
<td></td>
<td>: { value: 2, done: false }</td>
</tr>
<tr>
<td><code>console.log(iterator.next()) * 3</code></td>
<td>: 0 ‘i’</td>
</tr>
<tr>
<td></td>
<td>: { value: 1, done: false }</td>
</tr>
<tr>
<td></td>
<td>: 1 ‘i’</td>
</tr>
<tr>
<td></td>
<td>: { value: 2, done: false }</td>
</tr>
<tr>
<td></td>
<td>: 2 ‘i’</td>
</tr>
<tr>
<td></td>
<td>: { value: 3, done: false }</td>
</tr>
</tbody></table>
<p><code>yield</code> 在 <code>console.log</code> 语句之前的结果分析：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> items[i];</span><br><span class="line"><span class="built_in">console</span>.log(i, <span class="string">'i'</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>next() 个数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>console.log(iterator.next()) * 1</code></td>
<td>: { value: 1, done: false }</td>
</tr>
<tr>
<td><code>console.log(iterator.next()) * 2</code></td>
<td>: { value: 1, done: false }</td>
</tr>
<tr>
<td></td>
<td>: 0 ‘i’</td>
</tr>
<tr>
<td></td>
<td>: { value: 2, done: false }</td>
</tr>
<tr>
<td><code>console.log(iterator.next()) * 3</code></td>
<td>: { value: 1, done: false }</td>
</tr>
<tr>
<td></td>
<td>: 0 ‘i’</td>
</tr>
<tr>
<td></td>
<td>: { value: 2, done: false }</td>
</tr>
<tr>
<td></td>
<td>: 1 ‘i’</td>
</tr>
<tr>
<td></td>
<td>: { value: 3, done: false }</td>
</tr>
</tbody></table>
<p>从上面三种结果得出： <code>yield</code> 在调用 <code>next()</code> 之后执行的语句范围是：当前 <code>yield</code><br>与上一个 <code>yield</code> 之间的语句。  </p>
<p>得出上述结果的原因：执行生成器函数本身的时候，它只是返回了一个迭代器，本身的函数<br>体是不会执行的，除非调用了 <code>next()</code> 才会去执行函数体。  </p>
<p>证明：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'generator called...'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i, <span class="string">'i'</span>);</span><br><span class="line">    <span class="keyword">yield</span> items[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 结果什么都没有，第一个 <code>console.log</code> 并没有被执行。  </p>
<pre><code>undefined</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'generator called...'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i, <span class="string">'i'</span>);</span><br><span class="line">    <span class="keyword">yield</span> items[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>generator called...
0 &apos;i&apos;
{ value: 1, done: false }
1 &apos;i&apos;
{ value: 2, done: false }
2 &apos;i&apos;
{ value: 3, done: false }
{ value: undefined, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }
undefined</code></pre><h3 id="生成器函数表达式-Generator-Function-Expressions"><a href="#生成器函数表达式-Generator-Function-Expressions" class="headerlink" title="生成器函数表达式(Generator Function Expressions)"></a>生成器函数表达式(Generator Function Expressions)</h3><p>除了可以在声明式命名函数生成迭代器函数，还可以通过表达式的方式创建生成器函数：  </p>
<ol>
<li>右边带名字的 <code>var createIterator = function *createIterator() {}</code></li>
<li>右边不名字的 <code>var createIterator = function *() {}</code></li>
</ol>
<p>使用和效果和普通生成器函数 <a href="#orgac453ee">9.2</a>一样。  </p>
<blockquote>
<p>箭头函数不能用来生成生成器函数。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = *<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后错误结果：  </p>
<p> /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI/js-script-4JzlJj:3<br>   let createIterator = *() =&gt; {<br>                        ^</p>
<p> SyntaxError: Unexpected token *<br>     at Module._compile (internal/modules/cjs/loader.js:721:23)<br>     at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10)<br>     at Module.load (internal/modules/cjs/loader.js:653:32)<br>     at tryModuleLoad (internal/modules/cjs/loader.js:593:12)<br>     at Function.Module._load (internal/modules/cjs/loader.js:585:3)<br>     at Function.Module.runMain (internal/modules/cjs/loader.js:829:12)<br>     at startup (internal/bootstrap/node.js:283:19)<br>     at bootstrapNodeJSCore (internal/bootstrap/node.js:622:3)</p>
</blockquote>
<h3 id="对象中的生成器方法成员"><a href="#对象中的生成器方法成员" class="headerlink" title="对象中的生成器方法成员"></a>对象中的生成器方法成员</h3><p>ECMAScript 5 风格：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  createIterator: <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }</code></pre><p>ECMAScript 6 方法简写风格：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  *createIterator(items) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }</code></pre><h2 id="可迭代性和-for-of"><a href="#可迭代性和-for-of" class="headerlink" title="可迭代性和 for-of"></a>可迭代性和 <code>for-of</code></h2><p>一个可迭代的对象必须有一个 <code>Symbol.iterator</code> 属性。  </p>
<p>像我们在迭代集合对象(arrays, sets, maps)和字符串的时候，在内部其实是使用了到了他<br>们默认的 <code>Symbol.iterator</code> 迭代器的。  </p>
<blockquote>
<p>所有由生成器创建的迭代器都是可以迭代的，因为生成器也有默认的 <code>Symbol.iterator</code><br>内部属性。  </p>
</blockquote>
<h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><p><code>for-of</code> 会在每次迭代的时候自动调用 <code>next()</code> 进入下一次迭代，并且将 <code>value</code> 的值<br>保存到一个变量当中以供使用。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> values) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1
2
3</code></pre><p>如果，在迭代过程中只需要用到该被迭代对象的元素值得时候，推荐使用 <code>for-of</code> 因为它<br>依赖和检测的条件更少。  </p>
<blockquote>
<p><code>for-of</code> 语句使用在 non-iterable 对象， <code>null</code> 或 <code>undefined</code> 上的时候会报错。  </p>
</blockquote>
<h3 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h3><p>之前我们讲过，任何一个可以迭代的对象，都必须有 <code>Symbol.iterator</code> 属性，无论是内<br>部实现还是用户实现也好。  </p>
<p>这里将探讨如果使用和访问默认迭代器：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到数组内部的迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: undefined, done: true }
{ value: undefined, done: true }</code></pre><p>和我们自定义方式创建的迭代器<a href="#org2892a08">9.1</a>结果一样。  </p>
<p>检测一个对象是否是可迭代的，根据每个可迭代的对象都会有一个 <code>Symbol.iterator</code> 属<br>性(内部或自定义)，且是一个函数。  </p>
<p>则有：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">'string'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>())); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>())); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>())); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>())); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true
true
true
false
false</code></pre><h3 id="创建或重写迭代器"><a href="#创建或重写迭代器" class="headerlink" title="创建或重写迭代器"></a>创建或重写迭代器</h3><p>通过 <code>Symbol.iterator</code> 属性加上生成器函数可以很容易的让一个 non-iterable 对象变成<br>iterable :  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">  items: [],</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collection.items.push(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">  <span class="comment">// 事实上是调用了自定义实现的 `*[Symbol.iterator]() &#123;&#125;` 函数</span></span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1
2
3</code></pre><h2 id="内置迭代器"><a href="#内置迭代器" class="headerlink" title="内置迭代器"></a>内置迭代器</h2><p>迭代器是 ECMASCript 6 的很重要的一部分，因此你不再需要为许多内置类型去构建自己的<br>的迭代器，因为从现在开始他们自己内部就已经包含了一个默认的迭代器。  </p>
<h3 id="集合迭代器-for-of"><a href="#集合迭代器-for-of" class="headerlink" title="集合迭代器(for-of)"></a>集合迭代器(for-of)<a id="org001eece"></a></h3><p>从 ECMAScript 6 开始有三种类型的集合对象： arrays, maps 和 sets。并且他们都有内<br>置的迭代器帮助我们遍历操作内中的元素。  </p>
<ol>
<li><code>entries()</code> 返回一个迭代器的 key-value 键值对</li>
<li><code>values()</code> 返回一个迭代器的所有值的集合</li>
<li><code>keys()</code> 返回一个迭代器所有键的集合</li>
</ol>
<p><strong>entries() 迭代器</strong>:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'xxx'</span>);</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'yyy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ array.entries() ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> colors.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ set.entries() ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> tracking.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ map.entries() ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>------ array.entries() ---------
[ 0, &apos;red&apos; ]
[ 1, &apos;green&apos; ]
[ 2, &apos;blue&apos; ]
------ set.entries() ---------
[ 123, 123 ]
[ 456, 456 ]
[ 789, 789 ]
------ map.entries() ---------
[ &apos;title&apos;, &apos;xxx&apos; ]
[ &apos;format&apos;, &apos;yyy&apos; ]</code></pre><ol>
<li>数组 key - key， value - value</li>
<li>set key - value, value - value</li>
<li>map key - key, value - value</li>
</ol>
<p>通过 <code>entries()</code> 获取到的 array, set, map 迭代器：  </p>
<p><img src="http://qiniu.ii6g.com/1562493375.png" alt="img">  </p>
<p><strong>values() 迭代器</strong>:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'xxx'</span>);</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'yyy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ array.values() ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ set.entries() ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> tracking.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ map.entries() ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> data.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>------ array.values() ---------
red
green
blue
------ set.entries() ---------
123
456
789
------ map.entries() ---------
xxx
yyy</code></pre><p><strong>keys() 迭代器</strong>:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.name = <span class="string">'colors'</span>;</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'xxx'</span>);</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'yyy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ array.keys() ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> colors.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ set.entries() ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> tracking.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ map.entries() ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> data.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>------ array.keys() ---------
0
1
2
------ set.entries() ---------
123
456
789
------ map.entries() ---------
title
format</code></pre><blockquote>
<p>如上，数组中的 <code>name</code> 属性并没有输出，这是因为 <code>for-of</code> 只会针对数组的数字索引属<br>性，对于非数字的属性会忽略掉，因此如果需要遍历到非数字属性就需要用到 <code>for-in</code> 去<br>遍历。  </p>
</blockquote>
<p><code>for-in</code> 是根据该对象的属性遍历的，它会将对象中的所有属性遍历出来：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.name = <span class="string">'colors'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> colors) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>0
1
2
name</code></pre><p><strong>集合类型默认迭代器</strong> <a id="orgaccce3d"></a>:  </p>
<p>上面所有使用到 <code>for-of</code> 加上 <code>entries()</code>, <code>values()</code>, <code>keys()</code>, 的情况都可以使用<br>默认的迭代器来替代，其实这些迭代器方法最终取得也是集合的默认迭代器：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.name = <span class="string">'colors'</span>;</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'xxx'</span>);</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'yyy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ array ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors) &#123; <span class="comment">// 相当于使用了 colors.values()</span></span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ set ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> tracking) &#123; <span class="comment">// 相当于使用了 tracking.values()</span></span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------ map ---------'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data) &#123; <span class="comment">// 相当于 data.entries()</span></span><br><span class="line">  <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>------ array ---------
red
green
blue
------ set ---------
123
456
789
------ map ---------
[ &apos;title&apos;, &apos;xxx&apos; ]
[ &apos;format&apos;, &apos;yyy&apos; ]</code></pre><h3 id="for-of-循环的解构"><a href="#for-of-循环的解构" class="headerlink" title="for-of 循环的解构"></a>for-of 循环的解构</h3><p>在集合类型默认迭代器<a href="#orgaccce3d">9.4.1</a>中我们讲了，在对 arrays, sets,<br>maps 使用 <code>for-in</code> 的时候，其实都是分别使用了他们的默认迭代器(arrays.values(),<br>sets.values(), maps.entries()) 。  </p>
<p>那针对 maps 其内部用到的是 <code>entries()</code> 迭代器，得到的结果是： <code>[key, value]</code> 类<br>型，如果我们想要再循环体内使用，可以结合 ECMAScript 6 的解构功能，很方便的去使用<br>他们：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'xxxx'</span>],</span><br><span class="line">  [<span class="string">'format'</span>, <span class="string">'yyyy'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> data) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>title = xxxx
format = yyyy</code></pre><h3 id="字符串迭代器"><a href="#字符串迭代器" class="headerlink" title="字符串迭代器"></a>字符串迭代器</h3><p>在我们字符串的使用当中经常会看到 <code>str[0]</code> 和数组一样通过下标方式去访问字符串中的<br>字符。  </p>
<p>但是需要注意的一点是：字符串中括号索引方式的访问不是基于字符的而是基于编码单元的<br>(即单个字节的)。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"A ð ®· B"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; message.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ECMAScript 6 之前的输出结果：  </p>
<pre><code>A
(blank)
(blank)
(blank)
(blank)
B</code></pre><p>ECMAScript 6 之后的输出结果：  </p>
<p>+RESULTS:  </p>
<pre><code>A

ð

®
·

B</code></pre><p>ECMASCript 6 之后能正确输出是因为，在字符串一章<a href="#org952d340">3.1</a>新增的 16 字节的编码支<br>持，且字符串的默认迭代器是基于字符而不是编码字节去遍历的，所以通过 <code>for</code> 可以得<br>到正确的结果。  </p>
<p>同样，ES6 的 <code>for-of</code> 也一样能获得正确结果：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"A ð ®· B"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> message) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>A

ð

®
·

B</code></pre><h3 id="NodeList-迭代器-DOM元素列表迭代器"><a href="#NodeList-迭代器-DOM元素列表迭代器" class="headerlink" title="NodeList 迭代器(DOM元素列表迭代器)"></a>NodeList 迭代器(DOM元素列表迭代器)<a id="org999edd7"></a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> div <span class="keyword">of</span> divs) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(div.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器实例：  </p>
<p><img src="http://qiniu.ii6g.com/1562550190.png" alt="img">  </p>
<h2 id="展开符-x2026-和非数组类可迭代对象"><a href="#展开符-x2026-和非数组类可迭代对象" class="headerlink" title="展开符(&#x2026;)和非数组类可迭代对象"></a>展开符(&#x2026;)和非数组类可迭代对象</h2><p>展开符将集合转成数组：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line">let array = [...<span class="keyword">set</span>];</span><br><span class="line">console.log(array)</span><br></pre></td></tr></table></figure>

<p>将 maps 转成数组：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'xxx'</span>],</span><br><span class="line">  [<span class="string">'age'</span>, <span class="number">100</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [...map];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(array))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>[[&quot;name&quot; (\, &quot;xxx&quot;)] (\, [&quot;age&quot; (\, 100)])]</code></pre><p>数组的合并:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> moreNums = [<span class="number">0</span>, ...nums, ...[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(moreNums.toString())</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>0,1,2,3,4,5,6</code></pre><p>NodeList<a href="#org999edd7">9.4.4</a>一节中提到过在新的 HTML 标准中 <code>NodeList</code> 也有自己的默认迭代器，<br>因此展开符也对 <code>NodeList</code> 有效。  </p>
<p>如图示例：(浏览器环境)  </p>
<p><img src="http://qiniu.ii6g.com/1562497834.png" alt="img">  </p>
<h2 id="高级迭代器功能"><a href="#高级迭代器功能" class="headerlink" title="高级迭代器功能"></a>高级迭代器功能</h2><p>之前的章节讲述了使用迭代器和生成器如何去实现一些基本的功能，这一章节将讲述如何去<br>使用迭代器和生成去去实现一些高级功能。  </p>
<h3 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h3><p>之前使用迭代器，使用 <code>iterator.next()</code> 都是没有传递参数的，其实它是可以传递参数<br>的，其实就跟普通的函数参数传递是一样的。  </p>
<p>结合生成器使用时候的特殊性： <code>next(v)</code> 中的参数 <code>v</code> 的值会当做当前 <code>yield</code> 的返<br>回值返回，不管该 <code>yield</code> 后面表达式的结果是什么：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 不传值理应是： first + 2 =&gt; 1 + 2 =&gt; 3</span></span><br><span class="line">  <span class="comment">// 但 next(4) 有参数，则该参数就是 yield 表达式的值，因此结果会是： 4 + 2</span></span><br><span class="line">  <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 如上，结果是 5 + 3 = 8</span></span><br><span class="line">  <span class="keyword">yield</span> second + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)); <span class="comment">// &#123; value: 6, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>)); <span class="comment">// &#123; value: 8, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }
{ value: 6, done: false }
{ value: 8, done: false }
{ value: undefined, done: true }</code></pre><p>上面代码执行过程：  </p>
<p><img src="http://qiniu.ii6g.com/1562498470.png" alt="img">  </p>
<h3 id="迭代器中触发异常"><a href="#迭代器中触发异常" class="headerlink" title="迭代器中触发异常"></a>迭代器中触发异常</h3><p>由于给 <code>next()</code> 传递的参数不管是什么内容，它都会作为当前 <code>yield</code> 表达式的返回值<br>给返回。  </p>
<p>迭代器对象有一个方法： <code>iterator.throw(Error)</code> 可以给当前的 <code>yield</code> 处抛出一个异<br>常。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> second + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)) <span class="comment">// &#123; value: 6, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom'</span>))) <span class="comment">// 异常</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>: { value: 1, done: false }
: { value: 6, done: false }

/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI/js-script-bSJrfN:4
  let second = yield first + 2;
               ^

Error: Boom
    at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI/js-script-bSJrfN:12:28
    at Object.&lt;anonymous&gt; (/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI/js-script-bSJrfN:14:2)</code></pre><p>代码中，前面两个 <code>next()</code> 会正常执行得到结果，但当 <code>throw()</code> 调用的时候，迭代器<br>会在执行 <code>let second =</code> 之前抛出异常(<code>yield first + 2;</code> 已经返回结果了)。  </p>
<p>如图：  </p>
<p><img src="http://qiniu.ii6g.com/1562499068.png" alt="img">  </p>
<p><strong>捕获异常</strong> :  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> second;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    second = <span class="keyword">yield</span> first + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message)</span><br><span class="line">    second = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> second + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)) <span class="comment">// &#123; value: 6, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom'</span>))) <span class="comment">// &#123; value: 9, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }
{ value: 6, done: false }
Boom
{ value: 9, done: false }</code></pre><p>从结果会惊奇的发现，调用 <code>throw()</code> 之后，返回了下一个 <code>yield</code> 的执行结果。  </p>
<p>原因： <code>iterator.throw()</code> 调用之后，生成器将这个异常捕获到了，并且继续往下执行了，<br>从触发了下一个 <code>yield</code> 的执行。  </p>
<blockquote>
<p><code>next()</code> 和 <code>throw()</code> 都可以让生成器继续往下执行，只不过执行方式不一样，前者会从<br>下一个 <code>yield</code> 位置执行返回结果，后者是在上一个 <code>yield</code> 执行之后的位置触发一个异<br>常，如果这个异常被捕获就继续往下执行异常处理及后面的代码，如果没有被捕获就抛出一<br>个异常中断整个生成器的执行。  </p>
</blockquote>
<h3 id="生成器函数中使用-return-语句"><a href="#生成器函数中使用-return-语句" class="headerlink" title="生成器函数中使用 return 语句"></a>生成器函数中使用 return 语句</h3><p>在生成器中的 return 语句表示该迭代器结束了，后面不会再有值过来了。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// 这里结束迭代器</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>; <span class="comment">// 不会执行</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>; <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }
{ value: undefined, done: true }</code></pre><p>因此 return 语句在生成器中的效果就是终结迭代器，在它后面的 <code>yield</code> 都无效，  </p>
<p>还可以 return 一个值：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 这里结束迭代器</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>; <span class="comment">// 不会执行</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>; <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 42, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }
{ value: 42, done: true }
{ value: undefined, done: true }</code></pre><p>这里有点特殊，之前迭代器结束了，最后一个 <code>done: true</code> 的值是 <code>undefined</code> 这里使<br>用 return 返回了一个值会当做迭代器结束之返回。  </p>
<blockquote>
<p>在使用展开符和 <code>for-of</code> 时候如果有 return 语句，该语句中的 value 会被忽略掉，因<br>为它一旦发现了 <code>done: true</code> 就会结束。  </p>
</blockquote>
<h3 id="委托生成器-Delegating-Generators"><a href="#委托生成器-Delegating-Generators" class="headerlink" title="委托生成器(Delegating Generators)"></a>委托生成器(Delegating Generators)<a id="orgce1f7da"></a></h3><p>在有些情况下，将两个迭代器的值结合成一个通常会很有用。生成器可以通过 <code>yield</code> 和<br><code>*</code> 一起使用来实现代理到其他迭代器，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'red'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombineIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> *createNumIterator();</span><br><span class="line">  <span class="keyword">yield</span> *createColorIterator();</span><br><span class="line">  <span class="keyword">yield</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombineIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 'red', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 'blue', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: true, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }
{ value: 2, done: false }
{ value: &apos;red&apos;, done: false }
{ value: &apos;blue&apos;, done: false }
{ value: true, done: false }
{ value: undefined, done: true }</code></pre><p>结合 <code>return</code> 使用，比如：迭代器 B 依赖迭代器 A 的返回结果：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// #1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'repeat'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// #2</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumIterator();</span><br><span class="line">  <span class="comment">// #2.1</span></span><br><span class="line">  <span class="keyword">yield</span> result;</span><br><span class="line">  <span class="comment">// #3</span></span><br><span class="line">  <span class="comment">// 这里得到 createNumIterator 中 return 3 返回的结果 3</span></span><br><span class="line">  <span class="keyword">yield</span> *createRepeatingIterator(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createCombinedIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 'repeat', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 'repeat', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 'repeat', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: 增加 <strong>#2.1</strong> 将 <strong>#2</strong> 结果输出后：  </p>
<pre><code>{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: &apos;repeat&apos;, done: false }
{ value: &apos;repeat&apos;, done: false }
{ value: &apos;repeat&apos;, done: false }
{ value: undefined, done: true }</code></pre><p>+RESULTS: 有 <code>return 3;</code> 的返回结果  </p>
<pre><code>{ value: 1, done: false }
{ value: 2, done: false }
{ value: &apos;repeat&apos;, done: false }
{ value: &apos;repeat&apos;, done: false }
{ value: &apos;repeat&apos;, done: false }
{ value: undefined, done: true }</code></pre><p>+RESULTS: 没有 <code>return 3;</code> 的返回结果  </p>
<pre><code>{ value: 1, done: false }
{ value: 2, done: false }
{ value: undefined, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }</code></pre><p>因为如果没有 <code>return 3;</code> 那么最后 <strong>#2</strong> 处的的 <code>yield</code> 返回结果会是<br><code>createNumiterator()</code> 执行后返回的结果 <code>undefined</code>  </p>
<p>如果有 <code>return 3;</code> <strong>#2</strong> 处的函数又自己的返回值，作为 <strong>#2</strong> 处 <code>yield</code> 代理完成的<br>结果保存到了 <code>result</code> 中，下一次 <code>next()</code> 会执行 <strong>#3</strong> 处的 <code>yield</code> 进入下一个代<br>理迭代器。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> * <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// &#123; value: 'h', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// &#123; value: 'e', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// &#123; value: 'l', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// &#123; value: 'l', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// &#123; value: 'o', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: 因为字符串本身有自己的默认迭代器，因此 <code>yield * &#39;hello&#39;;</code> 结果会去调用<br>默认迭代器对每个字符进行迭代。  </p>
<pre><code>{ value: &apos;h&apos;, done: false }
{ value: &apos;e&apos;, done: false }
{ value: &apos;l&apos;, done: false }
{ value: &apos;l&apos;, done: false }
{ value: &apos;o&apos;, done: false }
{ value: undefined, done: true }</code></pre><h2 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h2><h3 id="for-await-of2019"><a href="#for-await-of2019" class="headerlink" title="for-await-of2019"></a>for-await-of<sup>2019</sup></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="function">(<span class="params">timeout</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, timeout * <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(time)</span><br><span class="line">  &#125;, time * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>]) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>一般我们使用生成器和迭代器最常用，也用起来最爽的估计就是异步任务了吧!!!  </p>
<p>比如：异步读取一个文件  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line">fs.readFile(__dirname + <span class="string">'/config.json'</span>, (err, cnt) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(cnt);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 通过异步接口取文件内容  </p>
<pre><code>/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI
&lt;Buffer 7b 20 22 6e 61 6d 65 22 3a 20 22 78 78 78 22 20 7d 0a&gt;
Done</code></pre><p>接下来我们将讲述如何使用 <code>generator</code> 来实现异步任务。  </p>
<h3 id="一个简单的任务执行器"><a href="#一个简单的任务执行器" class="headerlink" title="一个简单的任务执行器"></a>一个简单的任务执行器<a id="orgb88e39f"></a></h3><p>这个任务执行器的作用就是：  </p>
<ol>
<li>启动迭代器</li>
<li>循环调用 <code>next()</code> 知道结束</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建迭代器，首先确保 taskDef 是一个 generator 函数</span></span><br><span class="line">  <span class="keyword">let</span> task = taskDef();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动迭代器</span></span><br><span class="line">  <span class="keyword">let</span> result = task.next();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> step = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">      <span class="comment">// #1</span></span><br><span class="line">      <span class="comment">// result = task.next();</span></span><br><span class="line">      <span class="comment">// #2 将上一个 yield 的结果作为下一个 yield 的返回值</span></span><br><span class="line">      result = task.next(result.value);</span><br><span class="line">      step()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动循环递归，知道迭代器结束</span></span><br><span class="line">  step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------- log --------'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">logVal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------- logVal --------'</span>)</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  val = <span class="keyword">yield</span> val + <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(val) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run(log)</span><br><span class="line">run(logVal)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: <strong>#2</strong> 执行结果  </p>
<pre><code>------- log --------
1
2
3
------- logVal --------
1
4
undefined</code></pre><p>+RESULTS: <strong>#1</strong> 的执行结果  </p>
<pre><code>------- log --------
1
2
3</code></pre><p>通过 <strong>#2</strong> 的改造，让每次 <code>yield</code> 的表达式值依赖上一次 <code>next()</code> 的结果值。  </p>
<h3 id="异步任务执行器"><a href="#异步任务执行器" class="headerlink" title="异步任务执行器"></a>异步任务执行器</h3><p>我们可以将上一届<a href="#orgb88e39f">9.8.1</a>中的 <code>run</code> 进行改造让其支持异步任务:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task = taskDef()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 yield 返回的是一个函数，就执行这个函数(异步任务)</span></span><br><span class="line">        <span class="comment">// 结束之后，进行下一次 next() -&gt; yield</span></span><br><span class="line">        result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            result = task.throw(err)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          result = task.next(data)</span><br><span class="line">          step();</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = task.next(result.value);</span><br><span class="line">        step();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fs.readFile(__dirname + filename, callback)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> readFile(<span class="string">'/config.json'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>&lt;Buffer 7b 20 22 6e 61 6d 65 22 3a 20 22 78 78 78 22 20 7d 0a&gt;
Done</code></pre><h2 id="Generator-内部抽象操作-伪码"><a href="#Generator-内部抽象操作-伪码" class="headerlink" title="Generator 内部抽象操作(伪码)"></a><a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/">Generator 内部抽象操作(伪码)</a></h2><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>Symbol.iterator</code> 用来定义对象的默认迭代器</li>
<li><code>for-of</code> 可以用来遍历可迭代的对象，即包含 <code>Symbol.iterator</code> 函数的对象  <ol>
<li><code>entries()</code> 迭代器，取 <code>[key, value]</code> 键值对，如 <code>for-of-map</code> 默认就是用的<br>这个迭代器</li>
<li><code>values()</code> 迭代器，取 <code>value</code> 值，如果是数组 <code>for-of-array</code> 只会去索引为数<br>值的元素，忽略非数值索引的元素，比如： <code>arr.name = &#39;xxx&#39;</code> 这个 <code>name</code> 是不<br>会被遍历到的(默认用 <code>values()</code> 迭代器的有： arrays 和 sets)。</li>
</ol>
</li>
<li><code>...</code> 展开符其实内部实现也是去调用了对象内部的 <code>Symbol.iterator</code> 。</li>
<li><code>Generator</code> 调用会生成一个迭代器，通过 <code>it.next()</code> 触发 <code>yield</code> 语句执行并得到<br>结果  <ol>
<li>多个 generator 的嵌套调用可实现互相之间的代理(内部使用 <code>yield *generatorFn()</code> 调用生成器函数)</li>
<li>generator 内部使用 <code>return 42;</code> 终止迭代并返回 <code>{ value: 42, done: true}</code><br>，返回值由 <code>return</code> 返回值决定，但该值不会被 <code>for-of</code> 遍历到，因为 <code>for-of</code><br>检测到 <code>done: true</code> 了就即刻结束。</li>
<li>可以通过 <code>return</code> 特性灵活运用 generator 代理。</li>
<li>由于字符串本身是有迭代器的，因此可以直接： <code>yield * &#39;hello&#39;;</code> 使用。</li>
<li>generator + iterator 实现同步任务 runner 。</li>
<li>generator + iterator + callback 实现异步任务 runner。</li>
</ol>
</li>
</ul>
<h1 id="类-Classes"><a href="#类-Classes" class="headerlink" title="类(Classes)"></a>类(Classes)</h1><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><h3 id="基本类声明"><a href="#基本类声明" class="headerlink" title="基本类声明"></a>基本类声明</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'xxx'</span>);</span><br><span class="line">person.sayName(); <span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>实际上 <code>class</code> 声明只是个语法糖而已，它最终产生的 PersonClass 依旧是个函数，且这<br>个函数行为和 <code>constructor</code> 一致，这就是为什么上面 <code>typeof PersonClass</code> 输出结果<br>是 ‘function’ 。  </p>
<p>经过 babel 转换之后的代码：  </p>
<p><a id="orgccdd067"></a>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">    descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">    descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor)</span><br><span class="line">      descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (protoProps)</span><br><span class="line">    _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">  <span class="keyword">if</span> (staticProps)</span><br><span class="line">    _defineProperties(Constructor, staticProps); <span class="keyword">return</span> Constructor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">PersonClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, PersonClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(PersonClass, [&#123;</span><br><span class="line">    key: <span class="string">"sayName"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PersonClass;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'xxx'</span>);</span><br><span class="line">person.sayName(); <span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_instanceof(person, PersonClass)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(_instanceof(person, <span class="built_in">Object</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(_typeof(PersonClass)); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(_typeof(PersonClass.prototype.sayName)); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>需要关注的点：  </p>
<ol>
<li><p><code>constructor</code> 中的 <code>this.name</code> 依旧是在 PersonClass 这适用于函数的 <code>new</code> 特性  </p>
<p>最终 <code>name</code> 会被绑定到 <code>new PersonClass()</code> 之后的实例上。</p>
</li>
<li><p><code>sayName()</code> 类中的方法都会被绑定到 <code>PersonClass()</code> 的原型上。  </p>
<p>如： <code>_createClass</code> 里面的 <code>protoProps</code> 。</p>
</li>
<li><p>静态属性会被绑定到函数名(即类名，构造函数上)  </p>
<p>如： <code>_createClass</code> 里面的 <code>staticProps</code> 。</p>
</li>
<li><p>最后将函数 PersonClass 返回。</p>
</li>
</ol>
<h3 id="类语法的好处"><a href="#类语法的好处" class="headerlink" title="类语法的好处"></a>类语法的好处</h3><p>类和其他类型之间，有很多重要的区别：  </p>
<ol>
<li><p>类声明不会被提升(hoisted)，和 <code>let</code> 声明性质一样，也存在 <strong>TDZ</strong> 问题。</p>
</li>
<li><p>所有在类声明里面的代码默认启用 strict mode ，并且无法改变。</p>
</li>
<li><p>所有的方法都是不可枚举的， babel 转换之后 enumerable 默认值就是 <code>false</code>  </p>
<p>如上一节 babel 转换之后的代码 <a href="#orgccdd067">10.1.1</a> 。</p>
</li>
<li><p>所有的方法都没有 <code>[ [Constructor]]</code> 内部属性，因此不能 <code>new</code> ，否则会抛出异常。</p>
</li>
<li><p>不能直接调用类的构造函数。</p>
</li>
<li><p>在类方法里面试图重写类名将抛出异常。</p>
</li>
</ol>
<p>根据上面 6 个重要差异，我们就可以手动去模拟一个类了：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. let 声明，不存在提升，TDZ</span></span><br><span class="line"><span class="keyword">let</span> PersonType = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 必须是严格模式</span></span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. 因为是用 const 声明的类名，因此在类内部不能对类名重新赋值</span></span><br><span class="line">  <span class="keyword">const</span> PersonType = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 不能直接调用，必须使用 new</span></span><br><span class="line">    <span class="comment">// 这里用到了一个新的属性， new.target ，只能在非箭头函数</span></span><br><span class="line">    <span class="comment">// 内部使用，表示：</span></span><br><span class="line">    <span class="comment">// 如果是通过 new 调用的 new.target 就是 PersonType 自身</span></span><br><span class="line">    <span class="comment">// 如果不是通过 new 调用的 new.target 就是 undefined</span></span><br><span class="line">    <span class="comment">// 这也就很好的区分了一个函数是通过什么方式调用的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'类名必须通过 new 调用。'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有方法都挂在原型上</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(PersonType.prototype, <span class="string">'sayName'</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 4. 前面说过了 new.target 作用</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="comment">// 能进这里，表示用 new 调用了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'类方法不能通过 new 调用'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 所有方法都不能枚举</span></span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PersonType;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<p>如上例，类内部是不能对 <code>PersonType</code> 重新复制的，因为它是用 <code>const</code> 方式声明的，<br>但是在外部是可以重写的，因为外部是用的 <code>let</code> 声明的。  </p>
<p>因此：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    Foo = <span class="string">'bar'</span>; <span class="comment">// 错误，非法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo = <span class="string">'bar'</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><p>类也可以使用表达式的方式声明。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 等价于 PersonType 的构造函数</span></span><br><span class="line">  constructro(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名式表达式：跟命名式函数表达式是一样的， <code>class</code> 后面可以跟一个类名：  </p>
<p><code>let PersonClass = class PersonClass2 {...}</code>  </p>
<p>但是 class 后面的类名，只能在类的内部使用，在外部是访问不到的，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 等价于 PersonType 的构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2); <span class="comment">// 'function'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PersonClass(<span class="string">'xxx'</span>).sayName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2); <span class="comment">// 'undefined'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>function
xxx
undefined</code></pre><p><code>PersonClass2</code> 将作为类内部的函数名称。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> PersonClass2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(PersonClass2, ...)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PersonClass2;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<h2 id="类作为一等公民"><a href="#类作为一等公民" class="headerlink" title="类作为一等公民"></a>类作为一等公民</h2><p>当一个对象可以被当做值，意味着可以：  </p>
<ol>
<li>当做参数传递给函数</li>
<li>从一个函数返回</li>
<li>赋值给一个变量</li>
</ol>
<p>比如函数就是 JavaScript 中的一等公民。  </p>
<h3 id="作为参数"><a href="#作为参数" class="headerlink" title="作为参数"></a>作为参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">classDef</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> classDef()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = createObject(<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = createObject(<span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj1.sayHi(); <span class="comment">// 'Hi!'</span></span><br><span class="line">obj2.sayHi(); <span class="comment">// 'Hi!'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Hi!
Hi!</code></pre><p>匿名类和命名类作为参数传递。  </p>
<h3 id="立即执行实现单例"><a href="#立即执行实现单例" class="headerlink" title="立即执行实现单例"></a>立即执行实现单例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'xxx'</span>)</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// 'xxx'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>xxx</code></pre><ol>
<li>匿名类</li>
<li>立即执行</li>
<li>person 为一个单例，声明时就已经决定了是一个类(匿名类，只会在这里使用一次)实例。</li>
</ol>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> html(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="string">'html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get'</span> <span class="keyword">in</span> descriptor); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'set'</span> <span class="keyword">in</span> descriptor); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ get: [Function: get html],
  set: [Function: set html],
  enumerable: false,
  configurable: true }
true
true
false</code></pre><p>注意要从 <code>CustomHTMLElement.prototype</code> 原型上去取 <code>html</code> ，因为类的方法都会被挂<br>到原型上。  </p>
<h2 id="计算成员名称"><a href="#计算成员名称" class="headerlink" title="计算成员名称"></a>计算成员名称</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'sayName'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">'xx'</span>)</span><br><span class="line"></span><br><span class="line">me.sayName(); <span class="comment">// 'xx'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>xx</code></pre><p>计算成员名称，可以让类或对象的成员名动态生成，这赋予了类和对象更加灵活的使用方式。  </p>
<p>且访问器属性名称也可以使用变量。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">'html'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> [propertyName]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> [propertyName](value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成器方法-Generator-Methods"><a href="#生成器方法-Generator-Methods" class="headerlink" title="生成器方法(Generator Methods)"></a>生成器方法(Generator Methods)</h2><p>类内部方法还可以是生成器方法。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  *createIterator() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ins = <span class="keyword">new</span> MyClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = ins.createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: undefined, done: true }</code></pre><p>迭代器和生成器<a href="#orge26ee44">9</a>描述过，一个实现了 <code>Symbol.iterator</code> 或内置它<br>的一个对象都可以被迭代，也就可以使用 <code>for...of</code> 去遍历它，最终调用的都会是<br><code>Symbol.iterator</code> 这个内部或自定义的函数。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Collection()</span><br><span class="line"></span><br><span class="line">c.items.push(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> c) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1
2
3</code></pre><p>回顾<a href="#orgce1f7da"><span class="underline">代理生成器</span></a>和<a href="#org001eece"><span class="underline">集合内置迭代器</span></a>的内容，我们分析这一句：  </p>
<p><code>yield *this.items.values()</code>  </p>
<ol>
<li>首先 <code>values()</code> 为集合内置的值得迭代器</li>
<li><code>yield *iterator()</code> 这种方式为生成器代理，即一个生成器中调用另一个生成器</li>
</ol>
<p>也就是说当我们 <code>for (let x of c) {}</code> 的时候，首先是调用了 <code>Collection</code> 类内部实<br>现的 <code>*[Symbol.iterator]()</code> 迭代器，然后在迭代器内部由调用了类成员的 <code>items</code> 数<br>组的内置迭代器，也就是说这一句最终其实就是去遍历 <code>items</code> 数组，输出每个元素值。  </p>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员，即只属于构造函数的属性，只能通过类名去访问的成员。  </p>
<p>&lt; ECMAScript 6 之前的做法：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = Person.create(<span class="string">'xxx'</span>)</span><br><span class="line">person.sayName(); <span class="comment">// 'xxx'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>xxx</code></pre><p>直接在函数名称上挂一个属性，因为函数也是一个对象，也可以有自己的属性，和对象一样<br>可以通过 <code>obj[attrName]</code> 访问或新增属性。  </p>
<blockquote>
<p>= ECMAScript 6 开始可以使用类静态成员方式：  </p>
</blockquote>
<p>通过 <code>static</code> 关键词声明一个方法，这个方法将成为类的静态属性，只能通过类名访问。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = Person.create(<span class="string">'xx'</span>);</span><br><span class="line">p.sayName(); <span class="comment">// 'xx'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>xx</code></pre><h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><h3 id="lt-ECMAScript-6-之前的类继承"><a href="#lt-ECMAScript-6-之前的类继承" class="headerlink" title="&lt; ECMAScript 6 之前的类继承"></a>&lt; ECMAScript 6 之前的类继承<a id="orga150609"></a></h3><p>一般都是使用原型的方式去实现继承  </p>
<p>构造函数-实例-函数三者之间的关系简图：  </p>
<p><img src="http://qiniu.ii6g.com/function-fn-constructor-prototype.png" alt="img">  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">l, w</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.len = l</span><br><span class="line">  <span class="keyword">this</span>.width = w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.len * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类的构造函数，将实例属性拷贝一份到子类中</span></span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, l, l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line">Square.prototype = <span class="comment">/* Object.create(Rectangle.prototype, &#123;</span></span><br><span class="line"><span class="comment">                      constructor: &#123;</span></span><br><span class="line"><span class="comment">                      value: Square,</span></span><br><span class="line"><span class="comment">                      enumerable: false,</span></span><br><span class="line"><span class="comment">                      writable: true,</span></span><br><span class="line"><span class="comment">                      configurable: true</span></span><br><span class="line"><span class="comment">                      &#125;</span></span><br><span class="line"><span class="comment">                      &#125;) */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.create(Rectangle.prototype)</span><br><span class="line"><span class="comment">// Rectangle.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s.getArea()); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Square); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s.constructor === Square.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Square === Square.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Square.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: #1 被注释，意味着没有重新定义构造函数的输出  </p>
<pre><code>9
true
true
false
[Function: Rectangle]
true</code></pre><p>这里 <code>Square</code> 的构造函数不再是自身了，因为它的原型被重写了，而构造函数对象又是挂<br>在原型对象上的 <code>Square.prototype.constructor</code> 因此使用原型继承的时候尤其要记得重<br>新定义构造函数，才能得到下面的正确继承效果：  </p>
<p>+RESULTS: #1 没有注释，有重新定义构造函数的输出结果  </p>
<pre><code>9
true
true
true
[Function: Square]
true</code></pre><p>上面代码对于初学者来说不太容易明白的一般有两点：  </p>
<ol>
<li><p><code>Rectangle.call(this, l, l)</code> 这一步，这里是拷贝一份是实例属性到子类上  </p>
<p>这里相当于让 <code>Square</code> 也有了自己的 len 和 width 实例属性。</p>
</li>
<li><p><code>Square.prototype</code> 原型赋值的一步构造函数被覆盖了，需要重新定义构造函数</p>
</li>
</ol>
<p>注意点： 重写 Square 的原型，且需要重新定义构造函数，因为构造函数是在原型之上的，<br>如果将原型覆盖了，那么 Square 将没有自己的构造函数了，将没法创建实例，因此在使用<br><code>Object.create()</code> (<a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/#org2f761be">Object.create伪码实现</a>)的时候需要把构造函数属性给加上去。  </p>
<h3 id="gt-ECMAScript-6-之后的-class-类继承"><a href="#gt-ECMAScript-6-之后的-class-类继承" class="headerlink" title="&gt;= ECMAScript 6 之后的 class 类继承"></a>&gt;= ECMAScript 6 之后的 class 类继承</h3><p>在有了 <code>class</code> 语法糖之后，让 JavaScript 中的继承变得简单易懂。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(l, w) &#123;</span><br><span class="line">    <span class="keyword">this</span>.len = l</span><br><span class="line">    <span class="keyword">this</span>.width = w</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.len * <span class="keyword">this</span>.width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(l) &#123;</span><br><span class="line">    <span class="keyword">super</span>(l, l)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s.getArea()); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Square); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>9
true
true</code></pre><p>将上面的代码 babel 转换，删除一些不关心的代码之后：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(</span><br><span class="line">    superClass &amp;&amp; superClass.prototype,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: subClass,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (superClass)</span><br><span class="line">    _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle =</span><br><span class="line">    <span class="comment">/*#__PURE__*/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">l, w</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Rectangle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.len = l;</span><br><span class="line">        <span class="keyword">this</span>.width = w;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _createClass(Rectangle, [&#123;</span><br><span class="line">        key: <span class="string">"getArea"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.len * <span class="keyword">this</span>.width;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Rectangle;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Square =</span><br><span class="line">    <span class="comment">/*#__PURE__*/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">_Rectangle</span>) </span>&#123;</span><br><span class="line">      _inherits(Square, _Rectangle);</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Square);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, _getPrototypeOf(Square).call(<span class="keyword">this</span>, l, l));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Square;</span><br><span class="line">    &#125;(Rectangle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Square(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.getArea()); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_instanceof(s, Square)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_instanceof(s, Rectangle)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们重点关注的应该是 <code>_inherits</code> 这个函数，其实它里面实现的就和我们 ECMAScript6<br>之前的版本<a href="#orga150609">10.8.1</a>一样。  </p>
<h3 id="类-super-使用注意点"><a href="#类-super-使用注意点" class="headerlink" title="类 super() 使用注意点"></a>类 super() 使用注意点</h3><p>在使用 es6 的类的 <code>super()</code> 需要注意几点：  </p>
<ol>
<li>只能在子类的方法中使用 <code>super()</code> ，如果试图在一个非继承的类(不是用 <code>extends</code><br>实现的继承的子类)中使用都会报错。</li>
<li>必须在构造函数中调用 <code>this</code> 之前调用 <code>super()</code> 因为 <code>super()</code> 会对 <code>this</code> 做<br>一些初始化工作，比如拷贝实例属性等等。</li>
<li>唯一一个避免调用 <code>super()</code> 的途径就是在构造函数中返回一个对象。</li>
</ol>
<p><strong>第一点</strong>: 不能非继承调用 <code>super()</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 报错结果，表明不能在非继承的子类中直接调用 <code>super</code> ，因为它被定义指向<br>的是 extends 的父类那个对象。  </p>
<pre><code>/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-la0Zuf/js-script-UZ7NKG:4
    super(name)
    ^^^^^

SyntaxError: &apos;super&apos; keyword unexpected here
    at Module._compile (internal/modules/cjs/loader.js:721:23)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10)</code></pre><p><strong>第二点</strong>: 必须在使用 this 之前调用 <code>super()</code> 初始化 this  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Man(<span class="string">'xxx'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: 直接报错，不能在使用 this 之后调用 super() ,必须在之前调用  </p>
<pre><code>/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-la0Zuf/js-script-c51Wqa:10
    console.log(this.name)
                ^

ReferenceError: Must call super constructor in derived class before accessing &apos;this&apos; or returning from derived constructor
    at new Man (/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-la0Zuf/js-script-c51Wqa:10:17)
    at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-la0Zuf/js-script-c51Wqa:19:11</code></pre><h3 id="重写父类方法-Shadowing-Class-Methods"><a href="#重写父类方法-Shadowing-Class-Methods" class="headerlink" title="重写父类方法(Shadowing Class Methods)"></a>重写父类方法(Shadowing Class Methods)</h3><p>重写父类方法，通过实例调用该方法时候，会先从当前类中查找，如果没找到就会去父类中<br>找。  </p>
<p>因此，如果想子类拥有某种自己的行为，可以通过重写方法来实现。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'human running.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'person running.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">p.run(); <span class="comment">// 'human running.'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: 重写之后  </p>
<pre><code>person running.</code></pre><p>+RESULTS: 重写之前  </p>
<pre><code>human running.</code></pre><p>Babel 编译之后的代码：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Human =</span><br><span class="line">    <span class="comment">/*#__PURE__*/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Human);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _createClass(Human, [&#123;</span><br><span class="line">        key: <span class="string">"run"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'human running.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Human;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person =</span><br><span class="line">    <span class="comment">/*#__PURE__*/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">_Human</span>) </span>&#123;</span><br><span class="line">      _inherits(Person, _Human);</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Person);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, _getPrototypeOf(Person).apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _createClass(Person, [&#123;</span><br><span class="line">        key: <span class="string">"run"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'person running.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Person;</span><br><span class="line">    &#125;(Human);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.run(); <span class="comment">// 'human running.'</span></span><br></pre></td></tr></table></figure>

<p><code>_inherits</code> 让 Person.prototype 指向了 Human.prototype,  </p>
<p>两个 <code>_createClass</code> ，前一个让 <code>run</code> 挂到了 Human 的原型上，后一个又在 Person 的<br>原型上重新挂了一个同名的 run 方法，但由于继承 <code>_inherits</code> 的原型<br>Person.prototype 实际上是指向 Human.prototype 的，因此两个 <code>_createClass</code> 实际上<br>是覆盖了前一个 <code>_createClass</code> 的 run 方法。  </p>
<h3 id="继承静态成员"><a href="#继承静态成员" class="headerlink" title="继承静态成员"></a>继承静态成员</h3><p>静态成员在 <code>extends</code> 继承过程中，也会被继承到子类当中，但是也只能通过构造函数访<br>问。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(l, w) &#123;</span><br><span class="line">    <span class="keyword">this</span>.len = l</span><br><span class="line">    <span class="keyword">this</span>.width = w</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.len * <span class="keyword">this</span>.width</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> create(l, w) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Rectangle(l, w)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(l) &#123;</span><br><span class="line">    <span class="keyword">super</span>(l, l)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = Square.create(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Square); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
12
false</code></pre><h3 id="动态父类"><a href="#动态父类" class="headerlink" title="动态父类"></a>动态父类</h3><p>即 <code>extends</code> 后面的可以是任意类型，只要满足两个条件：  </p>
<ol>
<li>有 <code>[ [Constructor]]</code> 可以构建实例(使用 <code>new</code>)</li>
<li>有自己的原型</li>
</ol>
<p>普通构造函数：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">l, w</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.len = l</span><br><span class="line">  <span class="keyword">this</span>.width = w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.len * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(l) &#123;</span><br><span class="line">    <span class="keyword">super</span>(l, l)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x.getArea()); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>9
true</code></pre><p>函数调用方式：只要返回值满足有构造器和原型  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">l, w</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.len = l</span><br><span class="line">  <span class="keyword">this</span>.width = w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.len * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Rectangle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">getBase</span>() </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(l) &#123;</span><br><span class="line">    <span class="keyword">super</span>(l, l)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x.getArea()); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>9
true</code></pre><p>根据父类可以动态决定的特性，我们可以实现一些比较有用的东西，比如：混合器类型  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> SerializableMixin = &#123;</span><br><span class="line">  serialize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> AreaMixin = &#123;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> base = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.assign(base.prototype, ...mixins)</span><br><span class="line">  <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">mixin</span>(<span class="title">SerializableMixin</span>, <span class="title">AreaMixin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(l) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.length = l</span><br><span class="line">    <span class="keyword">this</span>.width = l</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())</span><br><span class="line"><span class="built_in">console</span>.log(x.serialize())</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>9
{&quot;length&quot;:3,&quot;width&quot;:3}</code></pre><p>让 <code>Square</code> 同时具备多个混合器的能力，使用多个混合器构建一个函数类。  </p>
<blockquote>
<p>记住：只要满足有原型和构造函数都可以放在 extends 右边作为被继承的父类。  </p>
<p>除下面两钟类型不能之外：  </p>
<ul>
<li><code>null</code></li>
<li>生成器函数</li>
</ul>
<p>因为他们没有 <code>[[Constructor] ]</code> 属性。  </p>
</blockquote>
<h3 id="继承内置对象"><a href="#继承内置对象" class="headerlink" title="继承内置对象"></a>继承内置对象</h3><p>可以通过原型继承的方式来基于内置对象定义一个新的对象，该对象将有用内置对象的相同<br>的功能。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 Array 的构造函数，初始化 this</span></span><br><span class="line">  <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>0
red</code></pre><p>结果并非如我们所预期。 <code>length</code> 属性和数值属性并没有像内置数组类型一样发生变化，<br>这是因为这个功能无法通过 <code>Array.apply()</code> 或赋值原型类实现。  </p>
<p>在 ECMAScript5 的类继承中， <code>this</code> 的值会在调用 <code>Array.apply</code> 之前会被新的类型<br>(比如： <code>MyArray</code>)创建好了，然后基础类型的构造函数才会被调用，这就意味着 <code>this</code><br>只是绑定到了 <code>MyArray</code> 的本 身的实例上而已，此时并不具备数组的一些基础特性，而后<br>的基础类型构造函数的调用只不过是对新类型做了一点扩展而已。  </p>
<p>而在 ECMAScript6 的基于类的继承当中， <code>this</code> 会优先被 <code>Array</code> 内置类型的构造函数<br>调用，然后才是被新类型 <code>MyArray</code> 的构造函数修改，修饰新类型的一些内容。结果就是<br><code>this</code> 将拥有基础类型的内置功能。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="comment">// empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1
undefined</code></pre><p>也就是说要继承基础类型，必须“先使用基础类型构造函数去创建 <code>this</code> ，然后对新类型<br>做进一步扩充”，否则，如果相反的话， <code>this</code> 由新类型创建，那只会拥有新类型的一些<br>基本特征，后面才调用基础类型的话只是做了一个粉饰而已。  </p>
<h2 id="Symbol-species-符号属性"><a href="#Symbol-species-符号属性" class="headerlink" title="Symbol.species 符号属性"></a>Symbol.species 符号属性<a id="orga2051c7"></a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">    subItems = items.slice(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subItems <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true</code></pre><p>通过 class-extends 的继承，不仅能让新类型实现原生类型的能力，而且也会改变一些默<br>认行为，比如上面的 <code>subItems instanceof MyArray</code> 的结果会是 <code>true</code> ，这是因为<br><code>Symbol.species</code> 在继承过程中影响了它的默认行为。  </p>
<p>Symbol.species 符号属性用来定义一个静态的访问器属性，返回一个函数。该函数被当做一个<br>构造函数使用，每当一个类的实例必须在一个实例方法中被创建的时候(而不是使用构造函<br>数)。  </p>
<p>以下内置类型定义了 <code>Symbol.species</code> :  </p>
<ul>
<li><code>Array</code></li>
<li><code>ArrayBuffer</code></li>
<li><code>Map</code></li>
<li><code>Promise</code></li>
<li><code>RegExp</code></li>
<li><code>Set</code></li>
<li>Typed Arrays</li>
</ul>
<p>上面每个类型都有一个默认的 <code>Symbol.species</code> 属性，返回 <code>this</code> ，也就是说它总是会<br>返回构造函数。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  getSpecies() &#123;</span><br><span class="line">    <span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(Person, <span class="built_in">Symbol</span>.species)</span><br><span class="line">    <span class="built_in">console</span>.log(descriptor, <span class="string">'11'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Person().getSpecies())</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 上面内置类型的 Symbol.species 默认实现，类似这里的实现</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get spcies'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clone() &#123;</span><br><span class="line">    <span class="comment">// this.constructor[Symbol.species] 会返回 MyClass 构造函数</span></span><br><span class="line">    <span class="comment">// 因此这里也相当于是 new MyClass(this.value)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clone() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="comment">// empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">"foo"</span>),</span><br><span class="line">    a1 = instance1.clone(),</span><br><span class="line">    c = <span class="keyword">new</span> C(<span class="string">"bar"</span>),</span><br><span class="line">    a2 = instance2.clone();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> A); <span class="comment">// #1: true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> B); <span class="comment">// #2: true</span></span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> A); <span class="comment">// #3: true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> C); <span class="comment">// #4: false</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true
true
false</code></pre><p>#1: true 因为 A 是 B 的父类，在 B 实例的原型链之上，因此这里结果为 true。  </p>
<p>#2: true 因为 B 继承 A ，且 B 的实例 <code>b</code> 中并没有重写 <code>Symbol.species</code> 因此他会<br>返回默认的 <code>Symbol.species</code> 实现也就是该类自身的构造函数。  </p>
<p>#3: true 因为 C 继承 A，同 #1 。  </p>
<p>#4: false 这里结果意味着 <code>C</code> 并不在实例 <code>a2</code> 的原型链上，这是因为 C 中重写了<br><code>Symbol.species</code> 改变了继承的默认行为。  </p>
<h2 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h2><p>在类中 <a href="#org52daa00">new.target</a> 永远不会是 <code>undefined</code> 因为类名不能直接被调用。  </p>
<p>利用 <code>new.target</code> 的特性：如果是通过 <code>new</code> 调用它的值就是当前类的构造函数  </p>
<p>我们可以将一个类变成的抽象化，让它不能被用来创建实例，只能被其他类继承：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能被实例化。'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape(); <span class="comment">// 报错，不能被实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rect(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>类声明，支持普通方式，表达式方式，不提升，性质和 <code>let</code> 一样，存在 TDZ。</p>
</li>
<li><p>类可以直接作为表达式的一部分，也可以跟函数一样立即执行，还可以直接当做参数传<br>递，可用来实现单例。</p>
</li>
<li><p>类成员的名称和普通对象一样使用计算属性，动态决定其属性名称。</p>
</li>
<li><p>类方法可以是生成器方法，返回迭代器。</p>
</li>
<li><p>类的静态方法(通过 <code>static</code> 修饰的方法)会被子类继承到构造函数上。</p>
</li>
<li><p><code>super()</code> 只能在继承式的子类构造函数中调用，且必须在使用 <code>this</code> 之前调用，否<br>则会报错。</p>
</li>
<li><p>父类，即 <code>extends</code> 右边可以是动态的，只需要满足它的返回结果必须有<br><code>[[Constructor] ]</code> 和自己的原型对象。</p>
</li>
<li><p>内置对象的继承，ES5的继承有缺陷，因为 <code>this</code> 绑定的先后问题  </p>
<p>es5 先绑定新类型然后是基础类型修饰，es6 是先绑定基础类型，然后是新类型的修饰，<br>这样将是该新类型具备基础类型的功能。</p>
</li>
<li><p><code>Symbol.species</code> 只能在类方法内部使用，不能通过构造函数调用，返回当前类的构造<br>函数。</p>
</li>
<li><p><code>new.target</code> 类的该属性只会是构造函数，因为类本身是不可以直接调用的，通过它<br>的特性可以让一个类抽象化，不能被实例化，只能被其他类继承。</p>
</li>
</ol>
<h1 id="提升数组能力-Array"><a href="#提升数组能力-Array" class="headerlink" title="提升数组能力(Array)"></a>提升数组能力(Array)</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="Array-of-x2026-items"><a href="#Array-of-x2026-items" class="headerlink" title="Array.of(&#x2026;items)"></a>Array.of(&#x2026;items)</h3><p>ECMAScript5 中构建数组：通过 <code>Array()</code> 构造函数，但是使用这种方式很容易产生疑惑，  </p>
<p>比如：  </p>
<p>值传递一个数值： <code>new Array(2)</code> 则会创建一个长度为 2 的数组。  </p>
<p>传递一个字符串数值： <code>new Array(&#39;2&#39;)</code> 则会当做一个数组元素，创建了一个元素的数组。  </p>
<p>传递多个参数的时候： <code>new Array(3, &#39;2&#39;)</code> 则参数列表中的元素都会被当做数组元素。  </p>
<p>这对我们的使用并不是什么好事，有时候你可能只是想创建一个 <code>2</code> 元素的数组而已，但<br>是实际上是一个长度为 2 的空数组。  </p>
<p>ECMAScript6 中则新增了 <code>Array.of()</code> 就不会有这种混淆，它只会将参数当做数组元素来<br>创建数组，比如：  </p>
<p><code>Array.of(1, 2)</code> ：两个元素的数组， arr[0] = 1, arr[1] = 2。  </p>
<p><code>Array.of(2)</code> : 一个元素数组， arr[0] = 2。  </p>
<p><code>Array.of(&#39;2&#39;)</code> ：一个元素的数组，arr[0] = ‘2’。  </p>
<blockquote>
<p><code>Array.of()</code> 不使用 <code>Symbol.species</code> 决定返回值得类型，它使用的是当前构造函数(在<br><code>of()</code> 函数里面的 <code>this</code>)来决定返回的正确数据类型。  </p>
</blockquote>
<h3 id="Array-from-items-mapFn-thisArg"><a href="#Array-from-items-mapFn-thisArg" class="headerlink" title="Array.from(items[, mapFn[, thisArg]])"></a>Array.from(items[, mapFn[, thisArg]])</h3><p><a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/#orgefbba01">Array.from 内部伪码实现-&gt;</a>  </p>
<p>将类数组的对象转换成数组类型，类数组对象：  </p>
<ol>
<li>有长度属性</li>
<li>有数值索引</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objArr = <span class="built_in">Array</span>.from(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objArr.length)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(objArr))</span><br><span class="line"><span class="built_in">console</span>.log(objArr[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2
true
undefined</code></pre><p>对于类数组对象如果想使用数组的方法，以往都是通过 <code>call(arrayLike)</code> 方式来调用的，<br>比如： <code>Array.prototype.slice.call(arrayLike)</code> 相当于 <code>arrayLike.slice()</code> 借用一<br>下数组的 <code>slice</code> 方法因为该方法只要对象有数值索引和长度属性就可以了。  </p>
<p><strong>参数 mapFn</strong> ：让转换过程中可以改变被转换元素的结果值，意思就是如果 <code>mapFn</code> 传递<br>两个合法的函数，遍历过程中元素的值会进过 <code>mapFn</code> 先处理一遍然后在返回到新的数组<br>列表中。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'0'</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(obj, v =&gt; v * v);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr[<span class="number">1</span>]); <span class="comment">// 10000, 40000</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>10000 40000</code></pre><p><strong>参数 thisArg</strong> ：指定 <code>mapFn</code> 的 <code>this</code> 指向：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> helper = &#123;</span><br><span class="line">  add: <span class="function"><span class="params">v</span> =&gt;</span> v * v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'0'</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(obj, helper.add, helper);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr[<span class="number">1</span>]); <span class="comment">// 100, 400</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>100 400</code></pre><p><strong>用于可迭代的对象</strong> :  </p>
<p>在<a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/#orgefbba01">伪码</a>中可以知道 <code>Array.from</code> 可以处理有迭代器的也可以处理无迭代器的，这里也可以<br>使用与自定义迭代器的对象，而不需要具备类数组对象的特征(必须有 <code>length</code> 和数值索<br>引值)  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = &#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nums2 = <span class="built_in">Array</span>.from(nums, v =&gt; v + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nums2[<span class="number">0</span>], nums2[<span class="number">1</span>], nums2[<span class="number">2</span>]); <span class="comment">// 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>2 3 4</code></pre><p>对应伪码中的实现：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列表类型，有自己的迭代器</span></span><br><span class="line"><span class="keyword">if</span> (usingIterator) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出同步迭代器</span></span><br><span class="line">  <span class="keyword">let</span> iteratorRecord = GetIterator(items, sync, usingIterator);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>, error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123; <span class="comment">// 循环启动迭代器，相当于自动调用了 iterator.next()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1 调用 iterator.next() 启动迭代器，取下一个 yield 值</span></span><br><span class="line">    <span class="keyword">let</span> next = IteratorStep(iteratorRecord);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2 取出当前迭代 &#123; value: xxx, done: false &#125; 中的 value 值</span></span><br><span class="line">    <span class="keyword">let</span> nextValue = IteratorValue(next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #3 将迭代出的值，添加到数组 Pk 位置上。</span></span><br><span class="line">    <span class="keyword">let</span> defineStatus = CreateDataPropertyOrThrow(A, Pk, mappedValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #4 进入下一次循环。</span></span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们省略了部分代码，只保留我我们需要关注的地方：  </p>
<ol>
<li><code>GetIterator(items, sync, usingIterator)</code> 会取出 items 对象的迭代器</li>
<li><code>while(1)</code> 一个无限循环，用来触发迭代器，相当于 <code>iterator.next()</code></li>
<li><code>IteratorValue(next)</code> 取出迭代器 <code>{value: xx, done: false}</code> 中 value 的值</li>
<li>最后将值添加到新数组 A 上， <code>k++</code> 进入下一次 <code>iterator.next()</code></li>
</ol>
<p><strong>用于类数组且可迭代的对象</strong> :  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = &#123;</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'0'</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="number">200</span>,</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums2 = <span class="built_in">Array</span>.from(nums);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nums2.length, nums2[<span class="number">0</span>], nums2[<span class="number">1</span>], nums2[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3 1 2 3</code></pre><p>从结果看出使用的是 <code>Symbol.iterator</code> 迭代器优先，这从伪码的处理过程中也可确定优<br>先级。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from = <span class="function"><span class="keyword">function</span>(<span class="params">items[, mapFn[, thisArg]]</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出类数组对象的迭代器，将用来取出有效的数组元素</span></span><br><span class="line">  <span class="keyword">let</span> usingIterator = GetMethod(items, @@iterator);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 列表类型，有自己的迭代器</span></span><br><span class="line">  <span class="keyword">if</span> (usingIterator) &#123;</span><br><span class="line">    <span class="comment">// 迭代器判断在前</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// .... return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非列表类型，没有自己的迭代器，可能是个类数组对象</span></span><br><span class="line">  <span class="keyword">let</span> arrayLike = ToObject(items);</span><br><span class="line">  <span class="comment">// 必须具备长度属性，才能转数组，这也是类数组对象必备条件之一</span></span><br><span class="line">  <span class="keyword">let</span> len = ToLength(Get(arrayLike, <span class="string">'length'</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="comment">// 类数组对象的判断在后</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Set</span>(A, <span class="string">'length'</span>, len, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原型上新增的方法"><a href="#原型上新增的方法" class="headerlink" title="原型上新增的方法"></a>原型上新增的方法</h2><h3 id="flat-depth-2019"><a href="#flat-depth-2019" class="headerlink" title="flat([depth])2019"></a>flat([depth])<sup>2019</sup></h3><p>扁平化数组，降维。 <code>depth</code> 表示降多少次，如果是 <code>Infinity</code> 则把数组降维到一维数<br>组。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nums.flat()) <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="flatMap-2019"><a href="#flatMap-2019" class="headerlink" title="flatMap()2019"></a>flatMap()<sup>2019</sup></h3><h3 id="find-mapFn-thisArg-amp-findIndex-mapFn-thisArg"><a href="#find-mapFn-thisArg-amp-findIndex-mapFn-thisArg" class="headerlink" title="find(mapFn[, thisArg]) &amp; findIndex(mapFn[, thisArg])"></a>find(mapFn[, thisArg]) &amp; findIndex(mapFn[, thisArg])</h3><p>查找元素，<a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/#orgefbba01">内部实现伪码</a>。  </p>
<p>以往并没有什么内置的方法用来查找数组中的元素，一般我们都是使用 <code>indexOf</code> 和<br><code>lastIndexOf</code> 或者利用他们实现自己的自定义方法。  </p>
<p>ECMAScript 6 中新增了两个专门用来查找元素的两个方法：  </p>
<ul>
<li><code>find(mapFn[, thisArg])</code> 返回满足条件的第一个元素值</li>
<li><code>findIndex(mapFn[, thisArg])</code> 返回满足条件的第一个元素值的索引</li>
</ul>
<p>两个方法的 <code>mapFn</code> 接受的参数与 <code>map()</code> 和 <code>forEach()</code> 一样，接收三个参数：  </p>
<ol>
<li><code>value</code> 遍历当前值</li>
<li><code>index</code> 当前索引</li>
<li><code>array</code> 数组本身</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nums.find(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(nums.findIndex(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="fill-value-start-end"><a href="#fill-value-start-end" class="headerlink" title="fill(value[, start[, end]])"></a>fill(value[, start[, end]])</h3><p><a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/#orgefbba01">fill 内部实现伪码</a>。  </p>
<p>从指定起始结束位置将数组元素替换成 <code>value</code> 。  </p>
<p>参数：  </p>
<ul>
<li><code>value</code> <em>required</em> 替换的值</li>
<li><code>start</code> <em>optional</em>, 默认(0)， 起始位置</li>
<li><code>end</code> <em>optional</em>, 默认(length)，结束位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">nums.fill(<span class="number">1</span>); <span class="comment">// 1, 1, 1, 1</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.toString());</span><br><span class="line"></span><br><span class="line">nums.fill(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// 1,2,2,2</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.toString());</span><br><span class="line"></span><br><span class="line">nums.fill(<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 1,2,3,3</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负数，len + (-1) = 3 =&gt; fill(1, 3);</span></span><br><span class="line">nums.fill(<span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// 1,2,3,1</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负数，len + (-2) = 2 =&gt; fill(1, 2);</span></span><br><span class="line">nums.fill(<span class="number">1</span>, <span class="number">-2</span>); <span class="comment">// 1,2,1,1</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负数，start: len + -2 = 2 =&gt; fill(1, 2, 1)</span></span><br><span class="line"><span class="comment">// 2 &lt; 1 =&gt; start &lt; end =&gt; 无效</span></span><br><span class="line">nums.fill(<span class="number">1</span>, <span class="number">-2</span>, <span class="number">1</span>); <span class="comment">// 1,2,1,1</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// start: len + -2 = 2</span></span><br><span class="line"><span class="comment">// end: len + -1 = 3</span></span><br><span class="line"><span class="comment">// =&gt; fill(1, 2, 3)</span></span><br><span class="line">nums.fill(<span class="number">4</span>, <span class="number">-2</span>, <span class="number">-1</span>); <span class="comment">// 1,2,4,1</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.toString());</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1,1,1,1
1,2,2,2
1,2,3,3
1,2,3,1
1,2,1,1
1,2,1,1
1,2,4,1</code></pre><h3 id="copyWithin-target-start-end"><a href="#copyWithin-target-start-end" class="headerlink" title="copyWithin(target, start[, end])"></a>copyWithin(target, start[, end])</h3><p><a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/">copyWithin 内部实现伪码。</a>  </p>
<p>方法功能：拷贝 <code>count = start:0 - end:length</code> 之间的元素，用这些元素从<br>target(<code>num = target:0 - len</code> ) 位置开始替换数组内的元素，实际被替换的元素个数由<br><code>num</code> 决定。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = nums.copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt; 拷贝元素个数 &lt;= len - 起始位置'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res.toString(), <span class="string">'res'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(nums.toString(), <span class="string">'nums'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(nums === res, <span class="string">'res === nums ?'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt; 拷贝元素个数 &gt; len - 起始位置'</span>)</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">res = nums.copyWithin(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.toString(), <span class="string">'res'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(nums.toString(), <span class="string">'nums'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(nums === res, <span class="string">'res === nums ?'</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>&gt;&gt;&gt; 拷贝元素个数 &lt;= len - 起始位置
4,5,3,4,5,6,7,8,9 res
4,5,3,4,5,6,7,8,9 nums
true &apos;res === nums ?&apos;
&gt;&gt;&gt; 拷贝元素个数 &gt; len - 起始位置
1,2,3,4,5,6,4,5,6 res
1,2,3,4,5,6,4,5,6 nums
true &apos;res === nums ?&apos;</code></pre><ol>
<li>如果 <code>end - start</code> &gt; <code>len - target</code> 则只替换 <code>len - target</code> 个元素</li>
<li>如果 <code>end - start</code> &lt; <code>len - target</code> 则只替换 <code>end - start</code> 个元素</li>
</ol>
<p>被替换的元素个数决定因素： <code>Math.min(end - start, len - target)</code> 取最小值得个数。  </p>
<h2 id="TODO-类型化数组-Typed-Arrays"><a href="#TODO-类型化数组-Typed-Arrays" class="headerlink" title="TODO 类型化数组(Typed Arrays)"></a>TODO 类型化数组(Typed Arrays)</h2><h2 id="TODO-类型化数组和普通数组的相似点"><a href="#TODO-类型化数组和普通数组的相似点" class="headerlink" title="TODO 类型化数组和普通数组的相似点"></a>TODO 类型化数组和普通数组的相似点</h2><h2 id="TODO-类型化数组和普通数组的不同点"><a href="#TODO-类型化数组和普通数组的不同点" class="headerlink" title="TODO 类型化数组和普通数组的不同点"></a>TODO 类型化数组和普通数组的不同点</h2><h2 id="TODO-小结"><a href="#TODO-小结" class="headerlink" title="TODO 小结"></a>TODO 小结</h2><h1 id="Promises和异步编程"><a href="#Promises和异步编程" class="headerlink" title="Promises和异步编程"></a>Promises和异步编程</h1><p>Nodejs 异步编程：事件触发 + 回调。  </p>
<p>Promise: 指定一些代码延时执行，并且可知道代码是否执行成功或失败，支持链式调用。  </p>
<p>为了更好的理解 Promise 如何工作，有必要了解一些与异步相关的基本概念。  </p>
<h2 id="Promise-Apis"><a href="#Promise-Apis" class="headerlink" title="Promise Apis"></a>Promise Apis</h2><h3 id="Promise-prototype-finally-onFinally"><a href="#Promise-prototype-finally-onFinally" class="headerlink" title="Promise.prototype.finally(onFinally)"></a>Promise.prototype.finally(onFinally)</h3><p>不管异步任务执行结果如何，都会在任务都完成之后被执行的代码。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p then'</span>)</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p finally'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="异步编程背景"><a href="#异步编程背景" class="headerlink" title="异步编程背景"></a>异步编程背景</h2><p>JavaScript 引擎基于事件循环的单线程，单线程意味着一次只能执行一个代码片段。  </p>
<p>因此 JavaScript 引擎就需要去跟踪和管理这些代码片段，而这些代码片段会被一个叫“任<br>务队列”的东西所持有，无论什么时候如果代码准备执行，它就会被添加到“任务队列”，当<br>代码被执行完成，，事件循环就会开始执行队列中的下一个任务。  </p>
<p>在队列中，任务的执行顺序总是从第一个任务开始执行到最后一个人任务执行结束。  </p>
<h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>比如，用户点击了一个键盘上的按键，触发点击(<code>onclick</code>)事件，那么引擎会通过在任务<br>队列的末尾添加一个新的任务来响应这个事件，这也是 JavaScript 中最基本的异步编程模<br>型，被添加到队列中的事件的回调并不会立即执行直到事件被触发，且被触发执行回调时<br>候会拥有自己合适的上下文执行环境。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"my-btn"</span>);</span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的按钮点击事件，在按钮点击之前是不会被执行，一旦按钮被点击，那么赋值给<br><code>onclick</code> 的代码片段(或叫“任务”)就会立即被添加到“任务队列”的末尾，等待它前面的其<br>他任务执行完成之后再执行(也就是说它不一定点击之后立即执行，前面可能还有其他任务<br>在等待执行)。  </p>
<h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>在 JavaScript 中，我们最常用的异步莫过于回调的使用了，比如在读取一个文件的时候，<br>读取完成之后要做一些处理，这个时候就会用到回调函数，因为读取文件相对来说是一个比<br>较耗时的操作，不太可能使用同步进行处理，因此通过回调来处理异步读取文件是个非常不<br>错的体验。  </p>
<p>比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</span><br></pre></td></tr></table></figure>

<p>在读取 <code>example.txt</code> 文件内容之后将其立即答应出来，这里的回调函数并不会立即执行，<br>而是在文件读取完成之后，会立即被添加到“任务队列”的列尾，在其他在它前面的任务执行<br>完成之后会被立即执行，这和上面讲的“事件模型”是一样的原理。  </p>
<p>这相对来说读取一个文件，然后执行输出这种算是比较简单的应用场景，而现实中往往并不<br>是这样的，现实中往往是多个事情之间有其关联性，也就是说工人在流水线上工作的时候，<br>就必须依赖于上一个人工作的传递才能继续往下执行，这如果体现在代码使用回调完成这将<br>会不可思议(这也就是我们常说的回调地狱问题)：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">method1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  method2(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method3(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      method4(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        method5(result);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>method4 必须等待 method3 执行完成，<br>method3 必须等待 method2 执行完成，<br>&#x2026;<br>一直到 method1 执行完成，这无论是在逻辑还是代码阅读性上都将会让人崩溃。  </p>
<p>一直到 <code>Promise</code> 的出现才比较有效的解决了这回调地狱及代码可读性的问题。  </p>
<h2 id="Promise-基础"><a href="#Promise-基础" class="headerlink" title="Promise 基础"></a>Promise 基础</h2><p>一个 promise 实例作为一个异步操作的结果返回，而不再使用时间绑定或将回调作为参数<br>传递给一个函数的方式，现在一个函数可以直接返回一个 promise ，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'example.txt'</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码中读取文件操作实际上并不会立即执行，而是返回了一个 promise 可以让你决<br>定如何去响应这个读取文件操作。  </p>
<h3 id="Promise-的生命周期"><a href="#Promise-的生命周期" class="headerlink" title="Promise 的生命周期"></a>Promise 的生命周期</h3><ul>
<li><p><em>pending</em>, 表示异步操作尚未完成，也被标记为 <em>unsettled</em> 。  </p>
<p>比如 <code>let promise = readFile(&#39;example.txt&#39;);</code> 执行之后，这个 promise 状态就<br>成为了 <em>pending</em> 一旦文件读取操作完成，该 promise 就会被设置为 <em>settled</em> ，随<br>后进入下面两种状态的一种，且不可逆。</p>
</li>
<li><p><em>Fulfilled</em> : 表示该 promise 代表的异步任务执行成功</p>
</li>
<li><p><em>Rejected</em> : 表示该 promise 代码的异步任务执行失败了或者执行过程中出现异常等其<br>它非正常结果。</p>
</li>
</ul>
<p>且 promise 有个内部属性 <code>[[PromiseState] ]</code> 用来记录了整个 promise 状态的变化，<br>它的值由三个： <em>pending</em>, <em>fulfilled</em>, <em>rejected</em> 对应着 promise 的三种不同状态。<br>该内部属性没有对外的接口，因此是无法直接去访问或操作它的，但是 promise 提供了一<br>个 <code>then()</code> 方法，可以接受处理的结果(<em>fulfilled</em> 或 <em>rejected</em>)。  </p>
<p><code>then(fulfilled, rejected)</code> 接受两个参数，这两个参数为函数类型，第一个会在<br>promise 状态变成 <em>fulfilled</em> 的时候调用，第二个则会在 <em>rejected</em> 状态下调用。  </p>
<p><code>fulfilled(data)</code> :  函数会接受 promise 成功之后传递出来的数据。  </p>
<p><code>rejected(error)</code> : 函数会接受 promise 失败之后触发的异常数据。  </p>
<blockquote>
<p>任意对象只要实现了 <code>then()</code> 方法都可以叫做一个 <em>thenable</em> ，所有的 promises 都是<br><em>thenable</em> 的，但并不是所有的 <em>thenable</em> 都是 promises 。  </p>
</blockquote>
<p>使用：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(__dirname + <span class="string">'/config.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 上面代码我们只是将读取文件操作包装成了一个 promise 但是并没有立即去读<br>取文件，且此刻 promise 的状态显示为 <em>pending</em> 。  </p>
<pre><code>Promise { &lt;pending&gt; }</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(__dirname + <span class="string">'/config.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将触发 promise 状态发生改变</span></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(promise)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(promise)</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: promise 成功之后的输出，状态将成为 <em>fulfilled</em> (这里没输出出来，o(╯□╰)o)。  </p>
<pre><code>Promise { &lt;pending&gt; }
Promise {
  &lt;Buffer 49 27 6d 20 61 20 70 72 6f 6d 69 73 65 20 65 78 61 6d 70 6c 65 2e 2e 2e 2e 2e 2e 0a&gt; }
&lt;Buffer 49 27 6d 20 61 20 70 72 6f 6d 69 73 65 20 65 78 61 6d 70 6c 65 2e 2e 2e 2e 2e 2e 0a&gt;</code></pre><p>+RESULTS: 读取失败之后状态为 <em>rejected</em> 的输出。  </p>
<pre><code>Promise { &lt;pending&gt; }
Promise {
  &lt;rejected&gt; { Error: ENOENT: no such file or directory, open &apos;/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json&apos;
    errno: -2,
    code: &apos;ENOENT&apos;,
    syscall: &apos;open&apos;,
    path:
     &apos;/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json&apos; } }
{ [Error: ENOENT: no such file or directory, open &apos;/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json&apos;]
  errno: -2,
  code: &apos;ENOENT&apos;,
  syscall: &apos;open&apos;,
  path:
   &apos;/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json&apos; }</code></pre><p>promise 也提供了一个 <code>catch()</code> 接口给我们用来捕获异常，比如上面的例子还可以这样：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(__dirname + <span class="string">'/config.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将触发 promise 状态发生改变</span></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(promise)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error in then'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error in catch'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 结果是 <code>then</code> 中和 <code>catch</code> 中都有执行  </p>
<pre><code>Promise { &lt;pending&gt; }
error in then
{ [Error: ENOENT: no such file or directory, open &apos;/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json&apos;]
  errno: -2,
  code: &apos;ENOENT&apos;,
  syscall: &apos;open&apos;,
  path:
   &apos;/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json&apos; }</code></pre><p>使用 promise 有个好处就是，比如上面的遇到执行异常，它会将异常捕获并处暴露出来，<br>一旦出现异常，或执行失败 promise 的状态会立即成为 <em>rejected</em> ，且无法逆转，即该<br>promise 已经彻底完成(无关成功或失败)。  </p>
<p>而事件模型中如果发生错误，该事件就不会被触发，而在回调中你就必须时常记住去检查异<br>常情况的出现可能性，并作出相应的处理。  </p>
<p>而在 promise 中异常会被捕获，如果你想针对异常做处理可以使用 then-reject 或<br><code>catch()</code> 都行，如果不想处理就静默结束 promise 即可，而不用关心是否会导致任务失<br>败而中断业务。  </p>
<p>一个 fufillment 或 rejection 的任务，如果在 promise 状态已经发生改变(<em>settled</em>,<br>成为 <em>fulfilled</em> 或 <em>rejected</em> )的情况下，依然添加了新的任务，那么它依旧会继续执<br>行。其实这也就相当于给其赋予了一个新的任务，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// original fulfillment handler</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(contents);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// #1 now add another</span></span><br><span class="line">  promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>#1 处相当于针对 promise 又在任务队列末尾新增了一个任务，等待被执行。  </p>
<h3 id="创建-unsettled-Promises"><a href="#创建-unsettled-Promises" class="headerlink" title="创建 unsettled Promises"></a>创建 unsettled Promises</h3><p>通过 <code>Promise</code> 构造函数可以创建一个 unsettled 状态的 promise 实例：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'...outer'</span>)</span><br><span class="line">    fs.readFile(__dirname + <span class="string">'/config.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'...inner'</span>)</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到了一个 pending - unsettled 的 promise</span></span><br><span class="line"><span class="keyword">let</span> promise = readFile()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 promise 任务，状态将变成 settled: fulfilled 或 rejected</span></span><br><span class="line"><span class="comment">// #1 promise.then(data =&gt; console.log(data), err =&gt; console.log(err))</span></span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: #1 注释之后的输出结果，Promise 的参数函数会立即执行。  </p>
<pre><code>...outer
Promise { &lt;pending&gt; }
...inner</code></pre><p>+RESULTS: fulfilled 结果  </p>
<pre><code>Promise { &lt;pending&gt; }
&lt;Buffer 49 27 6d 20 61 20 70 72 6f 6d 69 73 65 20 65 78 61 6d 70 6c 65 2e 0a&gt;</code></pre><p>+RESULTS: rejected 结果  </p>
<pre><code>Promise { &lt;pending&gt; }
{ [Error: ENOENT: no such file or directory, open &apos;/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/config.json&apos;]
  errno: -2,
  code: &apos;ENOENT&apos;,
  syscall: &apos;open&apos;,
  path:
   &apos;/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/config.json&apos; }</code></pre><ol>
<li>Promise 需要一个参数作为参数</li>
<li>该函数的参数有两个：1）resolve 任务执行成功之后调用，2）reject 任务失败调用</li>
<li>创建成功之后传递给 Promise 的函数会立即执行，并且将会在任务队列末尾添加一个任<br>务去处理这个 promise，这被称为“任务调度”。</li>
<li>参数函数立即执行，但是 resolve 和 reject 会被当做异步任务添加到任务队列末尾去<br>等待执行。</li>
</ol>
<h3 id="创建-settled-Promises"><a href="#创建-settled-Promises" class="headerlink" title="创建 settled Promises"></a>创建 settled Promises</h3><ol>
<li><code>Promise.resolve()</code> 会创建一个状态必定是 <em>fullfilled</em> 的 promise</li>
<li><code>Promise.reject()</code> 会创建一个状态必定是 <em>rejected</em> 的 promise</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>42</code></pre><p><code>Promise.resolve()</code> 创建的 promise 状态永远只会是 <em>fulfilled</em> 因此， <code>reject</code> 函数<br>是永远不会执行的，同理 =Promise.reject()=。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">'1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(vlaue, <span class="string">'2'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>100 &apos;1&apos;</code></pre><blockquote>
<p>如果给 <code>Promise.resolve()</code> 或 <code>Promise.reject()</code> 传递了一个 promise 那么它什么都<br>不会做，直接原样返回这个 promise 。  </p>
</blockquote>
<h3 id="非-Promise-的-Thenables"><a href="#非-Promise-的-Thenables" class="headerlink" title="非 Promise 的 Thenables"></a>非 Promise 的 Thenables</h3><p>非 Promise 的 Thenable : 对象有自己的 <code>then(resolve,reject)</code> 方法，那么就可以使<br>用 <code>Promise.resolve()</code> 或 <code>Promise.reject()</code> 将该 thenable 转变成一个<br><code>fulfilled</code> 或 <code>rejected</code> 的 promise，至于到底是哪个状态的要取决于 thenable 函数<br>内部是执行了 <code>resolve()</code> 还是 <code>reject()</code> 。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变成了一个 Fulfilled promise</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>42</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">42</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变成了一个 Fulfilled promise</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>42</code></pre><h3 id="执行异常"><a href="#执行异常" class="headerlink" title="执行异常"></a>执行异常</h3><p>Promise 会在其内部将代码的执行过程，使用 <code>try...catch</code> 捕获到异常，然后通过<br><code>then(null, reject)</code> 或 <code>catch(function(error){})</code> 将异常暴露出来。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Error: Explosion!
    at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/js-script-7ANcUx:3:9
    at new Promise (&lt;anonymous&gt;)
    at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/js-script-7ANcUx:2:15</code></pre><p>也可以手动捕获异常调用 <code>reject()</code> :  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion!'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 结果是一样的  </p>
<pre><code>Error: Explosion!
    at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/js-script-oIepKJ:4:11
    at new Promise (&lt;anonymous&gt;)</code></pre><h2 id="全局-Promise-Rejection-处理"><a href="#全局-Promise-Rejection-处理" class="headerlink" title="全局 Promise Rejection 处理"></a>全局 Promise Rejection 处理</h2><p>在之前的章节我们讲过，如果 promise 中的状态变成 <em>rejected</em> ，可能是任务失败，或<br>代码执行异常了，而这些异常实际上被捕获了，可以通过 <code>then(null, reject)</code> 的<br>reject 来接受或使用 <code>catch(function(err){}</code> 捕获。  </p>
<p>正式由于这种灵活性导致我们很难决定这些异常什么时候应该被处理，哪些有被处理，哪些<br>没有被处理，哪些又是什么时候被处理了???  </p>
<p>比如 promise 状态已经 <em>rejected</em> 完成了，但是 <em>rejection</em> 相关的处理却并没有在合<br>适的时候得到处理，因为这完全取决于编程者愿不愿意或什么时候去调用 <code>then(null,
   reject)</code> 或 <code>catch(function(err){}</code> 去处理。  </p>
<p>在 ECMAScript6 版本中并没有涉及到该问题的解决。  </p>
<p>在浏览器端和 Node.js 已经更新解决了该痛点问题，但这并非是 ECMAScript 6 的一部分。  </p>
<h3 id="Node-js-Rejection-处理"><a href="#Node-js-Rejection-处理" class="headerlink" title="Node.js Rejection 处理"></a>Node.js Rejection 处理</h3><p>在 Node.js 中有两个 <code>process</code> 对象上的事件与 promise rejection 处理相关：  </p>
<ul>
<li><code>unhandledRejection</code>: 在一个事件循环中一个 promise 状态已经 <em>rejected</em> 了，但<br>是没有任何 rejection 操作被调用的时候触发。</li>
<li><code>rejectionHandled</code>: 与上面的相反，表示状态 <em>rejected</em> 了，且有相关的 rejection<br>操作被调用。</li>
</ul>
<p><code>unahdnledRejection</code> 事件的回调接受两个参数，一个是 reason 失败原因，一个是该<br>promise 对象本身，如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">  <span class="built_in">console</span>.log(rejected === promise)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion!'</span>))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Explosion!
true</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message, <span class="string">'unhandledrejection'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(rejected === promise, <span class="string">'unhandledrejection'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'rejectionHandled'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(rejected === promise, <span class="string">'rejectionHandled'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion!'</span>))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err.message, <span class="string">'catch'</span>)</span><br><span class="line">&#125;), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>Explosion! unhandledrejection
true &apos;unhandledrejection&apos;
Explosion! catch
true &apos;rejectionHandled&apos;</code></pre><p>如上结果，首先触发的是 unhandledRejection 事件，1 秒之后 rejection 被<br><code>catch()</code> 处理掉了，触发 rejectionHandled 事件。  </p>
<p>有了上面的基础，我们这里就可以实现一个简易的 <strong>unhandled rejections tracker</strong> ，来<br>跟踪哪些 promise 的 rejection 有被处理，哪些没有被处理，如果没有可以针对这些<br>rejection 做些什么事情。  </p>
<ol>
<li>使用 <code>Map</code> 结构保存 <code>promise =&gt; reason</code> 当前 Promise 和它的 rejection 没有被<br>处理的原因。</li>
<li>监听 <code>unhandledRejection</code> 事件，在这里面将 <code>promise=&gt;reason</code> 添加到 map。</li>
<li>监听 <code>rejectionHandled</code> 事件，这里执行删除，因为 rejection 已经被处理，不需要<br>再保留了。</li>
</ol>
<p>这里使用的是强引用类型的 <code>Map</code> ，因为我们需要能够用到的 promise 引用去获取当前的<br>promise 执行设置或删除处理。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 需要使用 Map 强引用类型，因为 unhandledRejection 和 rejectionHandled</span></span><br><span class="line"><span class="comment">// 需要用到同一个 promise</span></span><br><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">  possiblyUnhandledRejections.set(promise, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'rejectionHandled'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  possiblyUnhandledRejections.delete(promise)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRejection</span>(<span class="params">promise, reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... 对每个 promise 的 rejection 进行处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每隔 6 秒检查一次 rejections ，如果有未处理的 rejection 就立即处理掉</span></span><br><span class="line">  possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason.message || reason)</span><br><span class="line"></span><br><span class="line">    handleRejection(promise, reason)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理完成之后清空 rejections</span></span><br><span class="line">  possiblyUnhandledRejections.clear()</span><br><span class="line">&#125;, <span class="number">6000</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码功能：每隔 6 秒监听一次未处理的 promise rejections 的情况，如果有未处<br>理的，就立即将它处理掉，然后清空 <code>map</code> ，这样就不会存在没有被处理的 rejections<br>了。  </p>
<h3 id="浏览器-Rejection-处理"><a href="#浏览器-Rejection-处理" class="headerlink" title="浏览器 Rejection 处理"></a>浏览器 Rejection 处理</h3><p>在浏览器端也是通过监听两个同名的事件来处理这些 rejections ，使用方式基本相同，只<br>需要注意几点：  </p>
<ul>
<li><code>unhandledRejection</code> 和 <code>rejectionHandled</code> 两个事件是在 <code>window</code> 对象上</li>
<li>事件的处理句柄的参数只有一个 <code>event</code> ，指向的是当前事件对象，该对象内包含三个<br>我们感兴趣的内容：  <ol>
<li><code>type</code> : 事件类型， <code>unhandledRejection</code> 或 <code>rejectionHandled</code></li>
<li><code>promise</code> : 当前的 promise 对象</li>
<li><code>reason</code> : 当前的 rejection 产生的原因</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type);                    <span class="comment">// "unhandledrejection"</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.reason.message);          <span class="comment">// "Explosion!"</span></span><br><span class="line">  <span class="built_in">console</span>.log(rejected === event.promise);    <span class="comment">// true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type);                    <span class="comment">// "rejectionhandled"</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.reason.message);          <span class="comment">// "Explosion!"</span></span><br><span class="line">  <span class="built_in">console</span>.log(rejected === event.promise);    <span class="comment">// true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</span><br></pre></td></tr></table></figure>

<p><strong>unhandled rejections tracking</strong> 代码和 Node.js 实现一样：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// when a rejection is unhandled, add it to the map</span></span><br><span class="line"><span class="comment">// 与 nodejs 版本不同点：这里只有一个事件参数，而不是 reason,promise</span></span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  possiblyUnhandledRejections.set(event.promise, event.reason);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 nodejs 版本不同点：这里参数不再是 promise 而是事件对象</span></span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  possiblyUnhandledRejections.delete(event.promise);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason.message ? reason.message : reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something to handle these rejections</span></span><br><span class="line">    handleRejection(promise, reason);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  possiblyUnhandledRejections.clear();</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">60000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="链式-Promises"><a href="#链式-Promises" class="headerlink" title="链式 Promises"></a>链式 Promises</h2><p>实际上，每次调用 <code>then()</code> 或 <code>catch()</code> 都是创建并返回了另一个 promise ，第二个<br>promise 只会在第一个的状态已经 settled 之后(无论是 fulfilled 或 rejected)才会<br>resolved。  </p>
<h3 id="链式-Promise-语法"><a href="#链式-Promise-语法" class="headerlink" title="链式 Promise 语法"></a>链式 Promise 语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finished.'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>42
finished.</code></pre><p>实际上调用第二个 <code>then()</code> 的 promise 是一个全新的 Promise 。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finished.'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false
42
finished.</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">  p3 = <span class="built_in">Promise</span>.resolve(<span class="number">100</span>)</span><br><span class="line">  <span class="keyword">return</span> p3</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val, <span class="string">'p3'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(p3 === p2, <span class="string">'p3 is not p2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2, <span class="string">'p2 is not p1'</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 我们也可以显示的在上一个 <code>then()</code> 里面返回一个 promise，从下面的第三行<br>输出可知，下一个 <code>then()</code> 处理的即上一个 <code>then()</code> 里面返回的 promise，如果没有显<br>式返回一个 promise 默认会创建一个新的 Promise 返回。  </p>
<pre><code>false &apos;p2 is not p1&apos;
42
100 &apos;p3&apos;
false &apos;p3 is not p2&apos;</code></pre><p>效果是一样的，但 p1 和 p2 并非同一个 promise。  </p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>通过链式调用可以使用 <code>catch()</code> 捕获上一个 promise 中的异常。  </p>
<p><a id="org8dd197d"></a>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first then.'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom!'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'third then.'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.message)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'100'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">'four then.'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 在第一个 <code>catch()</code> 中返回一个 <code>Promise.resolve(&#39;100&#39;)</code> 结果，这也说明<br>`four then` 来自 <code>catch()</code> 里面的 promise.resolve。  </p>
<pre><code>first then.
Boom!
100 four then.</code></pre><p>+RESULTS: four then 有输出，这是因为之前的异常已经被上一个 <code>catch()</code> 捕获并处理<br>了， promise 恢复正常状态。  </p>
<pre><code>first then.
Boom!
four then.</code></pre><p>+RESULTS: 新增 first then 结果，异常之后得 thenable 不会被执行，因为该 promise<br>已经终结。  </p>
<pre><code>first then.
Boom!</code></pre><p>+RESULTS: 新增 third then 输出和之前的一样，因为前面的发生了异常后面的就无法再<br>继续了。  </p>
<pre><code>Boom!</code></pre><p>+RESULTS:  </p>
<pre><code>Boom!</code></pre><p>从以上结果，不难看出，如果链式 promise 当中有一处发生异常，会终结这个 promise 链，<br>除非后面有一个 <code>catch()</code> 将该异常捕获并处理掉了，才能继续在链后面追加 <code>then()</code><br>。  </p>
<blockquote>
<p>通常情况下，最好是在链式调用的结束有一个 rejection 处理(<code>reject</code> 或 <code>catch</code>)，确<br>保链式调用中出现的异常能得到适当的处理。  </p>
</blockquote>
<h3 id="Promise-链式调用中返回值"><a href="#Promise-链式调用中返回值" class="headerlink" title="Promise 链式调用中返回值"></a>Promise 链式调用中返回值</h3><p>其实在<a href="#org8dd197d">上一节的实例</a>中，我们就已经用到了在 <code>thenable</code> 中返回一个值，该例中是直接返<br>回了一个 <code>Promise.resolve()</code> 其本身就是返回了一个新的 Promise 对象，其实我们还可<br>以直接返回一个普通的表达式或者其他类型的值，它的结果最终也会被封装成一个新的<br>Promise 实例返回出来。  </p>
<p>返回值：  </p>
<ol>
<li>普通类型值或表达式</li>
<li><code>Promise.resolve()</code> 或 <code>Promise.reject()</code></li>
<li>或者直接 <code>new Promise()</code> 返回一个全新的 promise</li>
<li>还可以返回另一个已经存在的 promise 实例</li>
<li>前面出现的异常即可以用 rejection 来接收，也可以使用 <code>catch()</code> 来接受，实际根<br>据需要作出选择</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// 42</span></span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// 43</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value + <span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 44</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom!'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.message); <span class="comment">// Boom!</span></span><br><span class="line">  <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">100</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 100</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'end here.'</span>)</span><br><span class="line">&#125;).then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 上一个的异常可以使用 rejection 接受</span></span><br><span class="line">  <span class="built_in">console</span>.log(reason); <span class="comment">// end here.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'end end here.'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 也可以用 catch 来接受</span></span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>42
43
44
Boom!
100
end here.
end end here.</code></pre><p>返回值也可以在一个 rejection，比如 <code>catch()</code> 中使用。  </p>
<h2 id="响应多个-Promises"><a href="#响应多个-Promises" class="headerlink" title="响应多个 Promises"></a>响应多个 Promises</h2><p>在之前的章节中，我们所使用的实例都是一次只能接受处理一个 promise，但是，如果你想<br>要同时去接收多个 promise 且下一步的行为由这些多个 promise 共同决定的时候，就需要<br>考虑使用下面这两个方法。  </p>
<ul>
<li><code>Promise.all()</code> 所有的 promise 状态完成了，才会被视为 resolved。</li>
<li><code>Promise.race()</code> 多个 promise 只要有一个状态完成了，那么 <code>race()</code> 就被视为已经<br>完成</li>
</ul>
<h3 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h3><p>参数 iterable 是一个元素为 promise 的列表，该接口的含义是只有 iterable 中所有的<br>promise 状态都为 resolved 了，这个接口返回的 promise 才会是 resolved ，否则只要<br>有一个 rejected 了，返回的 promise 就会是 rejected。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1 , p2, p3])</span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 结果是由 p1, p2, p3 的结果值组成的数组</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value)); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.toString()); <span class="comment">// 42, 43, 44</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
42,43,44</code></pre><blockquote>
<p><code>Promise.all()</code> 是：一荣俱荣(resolved)，一损俱损(rejected)，大家都在一条船上，一根<br>绳上的蚂蚱，谁也别想偷懒。  </p>
</blockquote>
<p>只要有一个 rejected 的了，那么立即 rejected 不会得到其他的 promise 完成：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1 , p2, p3])</span><br><span class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 结果是由 p1, p2, p3 的结果值组成的数组</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value)); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.toString()); <span class="comment">// 42, 43, 44</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 因为只要有一个 rejected 了，就会立即 rejected 因此异常的结果值只会是所<br>有 promises 中的一个。  </p>
<pre><code>false
43</code></pre><h3 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h3><p>iterable 中的所有 promises 属于竞争关系，利己主义者，并且不管第一个状态完成的状<br>态是 fulfilled 或 rejected 只要是 settled 那么 <code>race()</code> 就会立即 settled。  </p>
<p><em>race() 中的每个 promise 都是自私鬼，宁愿自己失败也要赶在第一时间将大伙消灭(主体<br>promise 都结束了)</em>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1 , p2, p3])</span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>42</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> delay = <span class="function">(<span class="params">fn, timeout</span>) =&gt;</span> setTimeout(fn, timeout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  delay(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">42</span>), <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  delay(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">44</span>), <span class="number">50</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1 , p2, p3])</span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>43</code></pre><h3 id="异步任务执行器-1"><a href="#异步任务执行器-1" class="headerlink" title="异步任务执行器"></a>异步任务执行器</h3><p>在之前的章节<a href="#orgb88e39f">9.8.1</a>中我们有使用 iterator + generator 实现一个简易的异<br>步任务执行函数，会在上一个任务完成之后立即启动下一个任务，如此往复直到所有任务都<br>完成为止。  </p>
<p>在这里我们将使用 Promise 来实现它：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task = taskDef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = task.next();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">      <span class="comment">// 这里不用判断值是什么类型，promise.resolve 统统转成 promise</span></span><br><span class="line">      <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(result.value)</span><br><span class="line">      promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        result = task.next(value)</span><br><span class="line">        step()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        result = task.throw(error)</span><br><span class="line">        step();</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(contents)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(__dirname + <span class="string">'/config.json'</span>)</span><br><span class="line">  <span class="comment">// do something with response data</span></span><br><span class="line">  <span class="built_in">console</span>.log(contents)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise 版本需要注意的点：  </p>
<ol>
<li><code>readFile</code> 即任务函数必须返回一个 Promise 对象</li>
<li>在 <code>step()</code> 里面讲迭代器的值无论什么类型，让它变成一个 promise ，通过<br><code>then()</code> 去接受执行结果， <code>catch()</code> 去捕获并处理异常。</li>
</ol>
<p>Promise 版本相对于 iterator + generator 版本有点：  </p>
<ol>
<li>不用关心迭代器中 value 的值是什么类型，只要转成 promise</li>
<li>能有效的处理异常，使用 <code>catch()</code> 捕获异常，不用中断程序</li>
<li>不用使用回调传递(readFile 返回一个带有回调的函数，这个回调会被传递到迭代器的<br>value 值，但实际最后被使用的是 readFile 中的 <code>fs.readFile()</code>)，而使用 Promise<br>就不需要关心回调是如何被传递和执行了。</li>
</ol>
<h3 id="未来异步任务执行器-async-x2026-await"><a href="#未来异步任务执行器-async-x2026-await" class="headerlink" title="未来异步任务执行器(async&#x2026;await)"></a>未来异步任务执行器(async&#x2026;await)</h3><p>在 ECMAScript 2017(es8) 中引入了一个新的语法糖： <code>async...await</code> 这让异步任务变<br>得异常简单，其内部实现也是基于 Promise 来实现的。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">await</span> readFile(__dirname + <span class="string">'/config.json'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(contents)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>&lt;Buffer 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 0a 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 ... &gt;
Done</code></pre><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>Promise 有三个状态： pending(创建之初时), fulfilled(执行成功) 和 rejected(执行<br>失败或异常)，且状态一旦改变就无法逆转。</p>
</li>
<li><p><code>promise.then(resolve, reject)</code> 用回调来接收上一个 promise 执行成功或失败的结<br>果</p>
</li>
<li><p><code>catch(rejection)</code> 失败或异常处理可以用 <code>then(null, reject)</code> 来接受之外也可以<br>使用 <code>catch</code> ，并且建议在每个链式 promise 调用结尾保证总有一个 <code>catch()</code> 来保<br>证异常能被捕获到并得到处理</p>
</li>
<li><p><code>Promise.all(iterable)</code> 所有的 promise resolved 才能 resolved</p>
</li>
<li><p><code>Promise.race(iterable)</code> 所有的 promise 之间处于竞争关系，只要有一个首先<br>settled 之后该 <code>race()</code> 就结束，状态由第一个 settled 的 promise 决定。</p>
</li>
<li><p>Promise 链式调用，中每一个 <code>then()</code> 中都会默认返回一个新的 promise 给后面的<br><code>then()</code> 也可以显示返回，如果显示返回的是一个普通值或表达式则会被封装成一个<br>promise，如果是一个 promise 则会被原样返回。</p>
</li>
<li><p>结合 promise 和 generator 将让异步任务执行器更加容易</p>
</li>
<li><p>es8 中的 async&#x2026;await 语法糖将让异步任务执行更加简易</p>
</li>
</ul>
<h1 id="Proxies-和-Reflection-Api"><a href="#Proxies-和-Reflection-Api" class="headerlink" title="Proxies 和 Reflection Api"></a>Proxies 和 Reflection Api</h1><p>ECMAScript 5 和 ECMAScript 6 出现的目的都是为了简化 JavaScript 的使用，在<br>ECMAScript 5 之前在 JavaScript 环境中包含一些拥有不能枚举(nonenumerable)和不能写<br>入(nonwritable)的对象属性，但是开发者却不能给自己声明的对象添加不能枚举和不能写<br>入的属性，因为并没有任务接口能使用，知道 ECMAScript 5 出现之后增加了<br><code>Object.defineProperty()</code> 方法，可以让开发者为自己的对象属性修改其描述符对象，从<br>而增加不可写或不可枚举的属性等。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: <span class="string">'100'</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="comment">// 不可枚举</span></span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// 不可赋值改变</span></span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.count = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.count, <span class="string">'count'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop, <span class="string">'prop'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>100 count</code></pre><ol>
<li>输出 100 表示 <code>obj.count = 3</code> 并没有生效</li>
<li>for..in 中没有输出，说明 <code>count</code> 不能被枚举</li>
</ol>
<p>ECMAScript 6 中赋予了开发者更多干涉 JavaScript 引擎工作的能力，它通过 <em>proxies</em><br>将一些内部操作暴露出来， <em>proxies</em> 是一些包可以中断或拦截引擎的一些操作包装器。<br>这一章节将开始于 <em>proxies</em> 相关的知识和使用。  </p>
<h2 id="数组问题-Array-Problem"><a href="#数组问题-Array-Problem" class="headerlink" title="数组问题(Array Problem)"></a>数组问题(Array Problem)</h2><p>比如，长度的问题，我们可以通过控制参数组的长度来达到控制数组内容的目的。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">'black'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]) <span class="comment">// 'black'</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">2</span>; <span class="comment">// 相当于截取了数组，后面的元素将被丢弃</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]); <span class="comment">// 'green'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3
4
black
2
undefined
undefined
green</code></pre><blockquote>
<p>这一非标准的行为也是为什么数组在 ECMAScript 6 中被视为异类了。  </p>
</blockquote>
<h2 id="什么是-Proxies-和-Reflection"><a href="#什么是-Proxies-和-Reflection" class="headerlink" title="什么是 Proxies 和 Reflection"></a>什么是 Proxies 和 Reflection<a id="org0c2ba4d"></a></h2><p>我们可以通过 <code>new Proxy()</code> 创建一个 <em>proxy</em> 用来代替另一个对象(假设叫：<br><em>target</em>)使用。这个 proxy 会虚拟化这个 target 以至于 proxy 和 target 能好似一个<br>东西一样被使用。  </p>
<p>就相当于给 target 生了个孪生兄弟，用法功能都差不多，甚至可以当做是一个人。  </p>
<p>Proxies 允许你可以中断低级对象操作(偏底层的操作, low-level object operations)，<br>这些操作可以被 <em>trap</em> 函数(一个可响应特定操作的函数)中断  </p>
<p><code>Relect</code> 对象，是一组方法的集合，为一些低级操作提供了默认行为(这些行为可以通过<br>proxies 重写)。对于每一个 proxy trap 都有一个 <code>Relect</code> 方法与之对应，且这些方法<br>和他们的 proxy traps 有一样的名字且传递了一样的参数。  </p>
<p>下表列出了一些默认行为和 proxy trap 的对应关系：  </p>
<table>
<thead>
<tr>
<th>proxy trap</th>
<th>重写的行为</th>
<th>默认行为</th>
</tr>
</thead>
<tbody><tr>
<td>get <a href="#org38c7be9">13.3.3</a></td>
<td>读取一个对象属性值</td>
<td><code>Reflect.get()</code></td>
</tr>
<tr>
<td>set <a href="#org999196c">13.3.2</a></td>
<td>设置属性值</td>
<td><code>Reflect.set()</code></td>
</tr>
<tr>
<td>has</td>
<td>是否包含</td>
<td><code>Reflect.has()</code></td>
</tr>
<tr>
<td>deleteProperty</td>
<td><code>delete obj.name</code> 删除对象属性操作</td>
<td><code>Reflect.deleteProperty()</code></td>
</tr>
<tr>
<td>getPrototypeOf</td>
<td><code>Object.getPrototypeOf()</code></td>
<td><code>Reflect.getPrototypeOf()</code></td>
</tr>
<tr>
<td>setPrototypeOf</td>
<td><code>Object.setPrototypeOf()</code></td>
<td><code>Reflect.setPrototypeOf()</code></td>
</tr>
<tr>
<td>isExtensible</td>
<td><code>Object.isExtensible()</code></td>
<td><code>Reflect.isExtensible()</code></td>
</tr>
<tr>
<td>preventExtensions</td>
<td><code>Object.preventExtensions()</code></td>
<td><code>Reflect.preventExtensions()</code></td>
</tr>
<tr>
<td>getOwnPropertyDescriptor</td>
<td><code>Object.getOwnPropertyDescriptor()</code></td>
<td><code>Reflect.getOwnPropertyDescriptor()</code></td>
</tr>
<tr>
<td>defineProperty</td>
<td><code>Object.definePropery()</code></td>
<td><code>Reflect.definePropery()</code></td>
</tr>
<tr>
<td>ownKeys</td>
<td><code>Object.keys()</code>, <code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code></td>
<td><code>Reflect.ownKeys()</code></td>
</tr>
<tr>
<td>apply</td>
<td><code>fn.apply(thisArg, argsArr)</code></td>
<td><code>Reflect.apply()</code></td>
</tr>
<tr>
<td>construct</td>
<td><code>new Ctor()</code></td>
<td><code>Reflect.construct()</code></td>
</tr>
</tbody></table>
<p>每一个 trap 重写了 JavaScript 对象的内置行为，允许中断和修改这些行为。如果依然需<br>要用到内置行为，可以使用对应的 reflection api 方法。  </p>
<blockquote>
<p>原来 ECMAScript 6 规范中有一个叫 <code>enumerate</code> 的 trap，被设计用来改变 <code>for...in</code><br>和 <code>Object.keys()</code> 枚举对象属性的行为。但是在 ECMAScript 7 中随即被移除，原因是<br>实现起来比较困难，因此以后都不会有 <code>enumerate</code> 了。  </p>
</blockquote>
<h2 id="使用-Proxies-和-Reflection"><a href="#使用-Proxies-和-Reflection" class="headerlink" title="使用 Proxies 和 Reflection"></a>使用 Proxies 和 Reflection</h2><h3 id="Proxy-简单应用"><a href="#Proxy-简单应用" class="headerlink" title="Proxy 简单应用"></a>Proxy 简单应用</h3><p>使用 <code>new Proxy(target, handler)</code> 创建一个 proxy 时候需要传递两个参数：  </p>
<ul>
<li><code>target</code> 需要被代理的那个对象</li>
<li><code>handler</code> 一个定义了一个或多个 proxy traps 的对象</li>
</ul>
<p>proxy 将使用所有操作的默认行为，除非在 <code>handler</code> 中定义了对应的 proxy trap。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">'proxy'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// 'proxy'</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name); <span class="comment">// 'proxy'</span></span><br><span class="line"></span><br><span class="line">target.name = <span class="string">'target'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// 'target'</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name); <span class="comment">// 'target'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: target 和 proxy 对象之间互相影响  </p>
<pre><code>proxy
proxy
target
target</code></pre><p>在这个例子上， proxy 代理了 target 对象的所有默认行为(因为传入了一个空的 <code>{}</code> 对<br>象给 <code>Proxy()</code> )。也就是说对 target 和 proxy 对象的所有行为都会在两个对象上有所<br>体现，形同操作对方本身一样。  </p>
<p><del>像这个简单的 proxy 例子，代理了 target 但是却没有提供任何 traps，这并没有任何意义</del>  </p>
<h3 id="用-set-trapTarget-key-value-receiver-trap-验证属性"><a href="#用-set-trapTarget-key-value-receiver-trap-验证属性" class="headerlink" title="用 set(trapTarget, key, value, receiver) trap 验证属性"></a>用 <code>set(trapTarget, key, value, receiver)</code> trap 验证属性<a id="org999196c"></a></h3><p>假设你想创建一个属性值必须是数值类型的对象，这意味着每一个新增的属性必须要有一个<br>验证机制去确保它是一个数值类型，否则就要抛出异常。  </p>
<p>为了实现这个功能，我们可以使用 proxy 的 <code>set</code> trap 去重写赋值的默认行为。  </p>
<p><code>set</code> trap 接受四个参数：  </p>
<ol>
<li><code>trapTarget</code> 那个被代理的对象 target，也是即将被新增属性的那个对象</li>
<li><code>key</code> 新增属性的 key 值(字符串或符号类型)</li>
<li><code>value</code> 新增属性的值，将要被检测的内容</li>
<li><code>receiver</code> 该操作的目标对象(一般就是 target 的代理实例 proxy)</li>
</ol>
<p><code>set</code> =&gt; 赋值操作 =&gt; <code>Reflect.set()</code>  </p>
<p>在“<a href="#org0c2ba4d">什么是 Proxies 和 Reflection</a>”一节就将过 proxy trap 和 reflect 对应的操作函数<br>名称和参数都是一模一样的，也就是说 <code>Reflect.set()</code> 也将接受 <code>set</code> trap 一样的四<br>个参数： trapTarget, key, value, receiver 且含义一样。  </p>
<p><code>Reflect.set()</code> 的返回值为 true/false ，成功为 true 失败为 false，且在 <code>set</code><br>trap 中也应该要返回一个 boolean 值表示该 trap 是否成功或失败了，一般直接返回<br><code>Reflect.set()</code> 的返回值即可。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  name: <span class="string">'target'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="keyword">set</span>(trapTarget, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(trapTarget === target, <span class="string">'trapTarget is target'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!trapTarget.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'属性必须是 `number` 类型！'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个属性</span></span><br><span class="line">proxy.count = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.count)</span><br><span class="line"><span class="built_in">console</span>.log(target.count)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">'proxy'</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br><span class="line"><span class="built_in">console</span>.log(target.name)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true &apos;trapTarget is target&apos;
1
1
true &apos;trapTarget is target&apos;
proxy
proxy
undefined</code></pre><p>如上面的例子，操作 proxy 就像直接操作 target 一样，所有的操作都能在 target 上面<br>有所体现，但是使用 proxy &amp; reflect 和直接操作 target 的好处是，允许我们拦截这一<br>底层操作，从而对其进行一些额外的处理。  </p>
<h3 id="get-trapTarget-key-receiver-trap"><a href="#get-trapTarget-key-receiver-trap" class="headerlink" title="get(trapTarget, key, receiver) trap"></a><code>get(trapTarget, key, receiver)</code> trap<a id="org38c7be9"></a></h3><p>获取对象属性值的操作代理。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(trapTarget, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> receiver)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'错误：属性 '</span> + key + <span class="string">' 不存在。'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(trapTarget, key, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy.name = 'proxy'</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(proxy.name)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">'proxy'</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>错误：属性 name 不存在。
proxy</code></pre><h3 id="has-trapTarget-key-trap"><a href="#has-trapTarget-key-trap" class="headerlink" title="has(trapTarget, key) trap "></a><code>has(trapTarget, key)</code> trap <a id="org46d3f0c"></a></h3><ul>
<li><code>trapTarget</code> 被代理的那个对象(比如： <code>target</code>)</li>
<li><code>key</code> 被检测的属性的名称</li>
</ul>
<p><code>in</code> 操作符可以用来检测一个属性是否存在于指定对象或者它的原型上，如果能找到返回 <em>true</em>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  value: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value'</span> <span class="keyword">in</span> target)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> target)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true</code></pre><p><code>in</code> 操作符在 Proxy 中对应的是 <code>has</code> -&gt; <code>Reflect.has(trapTarget, key)</code> 接口。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  name: <span class="string">'target'</span>,</span><br><span class="line">  value: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  has(trapTarget, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> key === <span class="string">'value'</span> ? <span class="literal">false</span> : <span class="built_in">Reflect</span>.has(trapTarget, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value'</span> <span class="keyword">in</span> proxy)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> proxy)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> proxy)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false
true
true</code></pre><h3 id="deleteProperty-trapTarget-key-trap-删除对象属性-delete-关键词的使用"><a href="#deleteProperty-trapTarget-key-trap-删除对象属性-delete-关键词的使用" class="headerlink" title="deleteProperty(trapTarget, key) trap 删除对象属性(delete 关键词的使用) "></a><code>deleteProperty(trapTarget, key)</code> trap 删除对象属性(<em>delete</em> 关键词的使用) <a id="orgb519cd2"></a></h3><p><code>delete</code> 操作符会将对象中的属性从这个对象中移除，如果成功返回 <code>true</code> 否则返回<br><code>false</code> ，在严格模式下试图删除一个 <em>non-configurable</em> 的属性会报错，非严格模式下<br>会返回 <code>false</code> 。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  name: <span class="string">'target'</span>,</span><br><span class="line">  value: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">'name'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value'</span> <span class="keyword">in</span> target) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res1 = <span class="keyword">delete</span> target.value</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value'</span> <span class="keyword">in</span> target) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res2 = <span class="keyword">delete</span> target.name <span class="comment">// error 严格模式</span></span><br><span class="line"><span class="built_in">console</span>.log(res2, <span class="string">"严格模式"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> target, <span class="string">"删除失败"</span>) <span class="comment">// true 删除失败</span></span><br></pre></td></tr></table></figure>

<p>通过 proxy 的 <code>deleteProperty</code> -&gt; <code>deleteProperty(trapTarget, key)</code> 代理 delete<br>行为：  </p>
<ul>
<li><code>trapTarget</code> 被代理的对象</li>
<li><code>key</code> 被删除的属性名称</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  name: <span class="string">'target'</span>,</span><br><span class="line">  value: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  deleteProperty(trapTarget, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> key === <span class="string">'value'</span> ? <span class="literal">false</span> : <span class="built_in">Reflect</span>.deleteProperty(trapTarget, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value'</span> <span class="keyword">in</span> proxy)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res1 = <span class="keyword">delete</span> proxy.value</span><br><span class="line"><span class="built_in">console</span>.log(res1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value'</span> <span class="keyword">in</span> proxy, <span class="string">'删除失败'</span>) <span class="comment">// true, 删除失败</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> proxy) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> proxy.name, <span class="string">'name'</span> <span class="keyword">in</span> proxy) <span class="comment">// true false</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
false
true &apos;删除失败&apos;
true
true false</code></pre><h2 id="原型代理Traps-Prototype-Proxy-Traps"><a href="#原型代理Traps-Prototype-Proxy-Traps" class="headerlink" title="原型代理Traps(Prototype Proxy Traps)"></a>原型代理Traps(Prototype Proxy Traps)<a id="org9c538fc"></a></h2><p>与原型有关的 traps :  </p>
<ol>
<li><code>getPrototypeOf(trapTarget)</code> -&gt; <code>Object.getPrototypeOf(trapTarget)</code> -&gt;<br><code>Reflect.getPrototypeOf(trapTarget)</code></li>
<li><code>setPrototypeOf(trapTarget, proto)</code> -&gt; <code>Object.setPrototypeOf(trapTarget, proto)</code> -&gt;<br><code>Reflect.setPrototypeOf(trapTarget, proto)</code></li>
</ol>
<h3 id="原型代理-Traps-工作原理"><a href="#原型代理-Traps-工作原理" class="headerlink" title="原型代理 Traps 工作原理"></a>原型代理 Traps 工作原理</h3><p>在使用原型 trap 的时候有一些严格的规定：  </p>
<ol>
<li><code>getPrototypeOf</code> trap 必须返回一个对象或者 <code>null</code> ,如果是其他值就会发生运行时<br>错误</li>
<li><code>setPrototypeOf</code> 在失败的时候必须返回 <code>false</code> ，如果不是那么默认会被当做成功<br>处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  getPrototypeOf(trapTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setPrototypeOf(trapTarget, proto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target)</span><br><span class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;) <span class="comment">// succeed</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;) <span class="comment">// error</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
false
null
&apos;setPrototypeOf&apos; on proxy: trap returned falsish</code></pre><p>使用默认行为(<code>Reflect.get/setPrototypeOf()</code>)  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  getPrototypeOf(trapTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.getPrototypeOf(trapTarget)</span><br><span class="line">  &#125;,</span><br><span class="line">  setPrototypeOf(trapTarget, proto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.setPrototypeOf(trapTarget, proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target)</span><br><span class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;) <span class="comment">// succeed</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;) <span class="comment">// error</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true
{}</code></pre><h3 id="为什么有两种方法-Reflect-和-Object-上都有-get-setPrototypeOf"><a href="#为什么有两种方法-Reflect-和-Object-上都有-get-setPrototypeOf" class="headerlink" title="为什么有两种方法?(Reflect 和 Object 上都有 get/setPrototypeOf)"></a>为什么有两种方法?(Reflect 和 Object 上都有 get/setPrototypeOf)</h3><p><strong>相同点</strong> ：  </p>
<p>最终都是操作的内部属性： <code>[[GetPrototypeOf] ]</code> 和 <code>[[setPrototypeOf] ]</code>  </p>
<p><strong>不同点</strong> :  </p>
<table>
<thead>
<tr>
<th></th>
<th><code>getPrototypeOf</code></th>
<th><code>setPrototypeOf</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td>参数会被强转成对应的对象</td>
<td>失败抛异常，成功返回 trapTarget</td>
</tr>
<tr>
<td><code>Reflect</code></td>
<td>参数只能是对象，否则报错</td>
<td>失败返回 <code>false</code> , 成功返回 <code>true</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>参数不同点：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res === <span class="built_in">Number</span>.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
Reflect.getPrototypeOf called on non-object</code></pre><p>返回值不同点：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> res1 = <span class="built_in">Object</span>.setPrototypeOf(target1, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res1 === target1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> res2 = <span class="built_in">Reflect</span>.setPrototypeOf(target2, &#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res2 === target2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
false
true</code></pre><h2 id="对象扩展性-Traps-Object-Extensibility-Traps"><a href="#对象扩展性-Traps-Object-Extensibility-Traps" class="headerlink" title="对象扩展性 Traps(Object Extensibility Traps)"></a>对象扩展性 Traps(Object Extensibility Traps)<a id="orgfd5f8b6"></a></h2><p>在 ECMAScript 5 中新增了两个方法： <code>Object.preventExtensions()</code> 和<br><code>Object.isExtensible()</code> 用来阻止对象被扩展和检测对象的扩展性，这两个 api 都只<br>有一个参数 <code>trapTarget</code> 表示作用的对象，返回值都是 <code>boolean</code> 前者表示阻止是否<br>成功，后者表示对象是否可扩展，在 proxy-reflect 中也有相应的 api 与之对应，且<br>参数和返回值均一样。  </p>
<p><code>Object.preventExtensions()</code> 阻止给对象增加属性：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  value: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Object</span>.isExtensible(target)</span><br><span class="line"></span><br><span class="line">target.name = <span class="string">'xxx'</span></span><br><span class="line"><span class="built_in">console</span>.log(res, target) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(target)</span><br><span class="line"></span><br><span class="line">target.age = <span class="string">'100'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, <span class="string">'height'</span>, &#123;</span><br><span class="line">    value: <span class="string">'166'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">Object</span>.isExtensible(target)</span><br><span class="line"><span class="built_in">console</span>.log(res, target) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: <code>age</code> 并没有被添加, <code>height</code> 添加报错  </p>
<pre><code>true { value: 42, name: &apos;xxx&apos; }
Cannot define property height, object is not extensible
false { value: 42, name: &apos;xxx&apos; }
undefined</code></pre><p>代理：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  isExtensible(trapTarget) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'is extensible ...'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  preventExtensions(trapTarget) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'preventing extension'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.preventExtensions(trapTarget)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target), <span class="string">'before'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy), <span class="string">'before'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target), <span class="string">'after'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy), <span class="string">'after'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: 因为使用了 Reflect.xxx 所以作用在 proxy 上的操作也将体现在 target 上  </p>
<pre><code>true &apos;before&apos;
is extensible ...
true &apos;before&apos;
preventing extension
false &apos;after&apos;
is extensible ...
false &apos;after&apos;</code></pre><p>如果总是允许代理对象能被扩展，只需要在代理的 <code>preventExtensions</code> trap 中直接返回<br><code>false</code> 就行了，但是并不影响 <code>target</code> 除非调用了 <code>reflect</code> 。  </p>
<p>Reflect 和 Object 上的区别：  </p>
<table>
<thead>
<tr>
<th></th>
<th><code>isExtensible</code></th>
<th><code>preventExtensions</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>Reflect</code></td>
<td>参数非对象，触发异常</td>
<td>参数非对象，触发异常</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>参数非对象，总是返回 <code>false</code></td>
<td>参数非对象，会返回该参数自身</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = <span class="built_in">Object</span>.isExtensible(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Reflect</span>.isExtensible(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res2 = <span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Reflect</span>.preventExtensions(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false
Reflect.isExtensible called on non-object
1
Reflect.preventExtensions called on non-object</code></pre><h2 id="属性描述符-Traps-Property-Descriptor-Traps"><a href="#属性描述符-Traps-Property-Descriptor-Traps" class="headerlink" title="属性描述符 Traps(Property Descriptor Traps)"></a>属性描述符 Traps(Property Descriptor Traps)<a id="org4910730"></a></h2><p>ECMAScript 5 更新中包含了可以通过 <code>Object.defineProperty(obj, key, descObj)</code> 自<br>定义属性的功能，这让开发者可以自己定义一些特定功能的对象属性，比如：只读、只写、<br>或不可枚举等等特性，然后可以通过 <code>Object.getOwnPropertyDescriptor()</code> 来获取对象<br>属性的描述符对象。  </p>
<p><a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/">Object.defineProperty() 详细使用</a>  </p>
<h3 id="属性描述符代理"><a href="#属性描述符代理" class="headerlink" title="属性描述符代理"></a>属性描述符代理<a id="orgb70d1c1"></a></h3><p>在 proxy-reflect 中对应着：  </p>
<ul>
<li><code>defineProperty</code> -&gt; <code>Reflect.defineProperty(trapTarget, key, descriptor)</code></li>
<li><code>getOwnPropertyDescriptor</code> -&gt; <code>Reflect.getOwnPropertyDescriptor(trapTarget, key)</code></li>
</ul>
<p>返回值：  </p>
<p><code>defineProperty</code> 成功返回 <code>true</code>, 失败返回 <code>false</code>  </p>
<p><code>getOwnPropertyDescriptor</code> 成功返回描述符  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  definePropery(trapTarget, key, descriptor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getOwnPropertyDescriptor(trapTarget, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(trapTarget, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'proxy'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// 'proxy'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// 'proxy'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>proxy
proxy</code></pre><p>阻止给对象扩展符号属性：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  defineProperty(trapTarget, key, descriptor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'symbol'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'proxy'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// 'proxy'</span></span><br><span class="line"><span class="keyword">let</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(proxy, nameSymbol, &#123;</span><br><span class="line">    value: <span class="string">'symbol-proxy'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>proxy
&apos;defineProperty&apos; on proxy: trap returned falsish for property &apos;Symbol(name)&apos;</code></pre><p>因为 <code>Object.defineProperty()</code> 返回 <code>false</code> 的话会触发异常表示扩展失败。  </p>
<p>如果想要扩展失败隐藏异常，可以在 trap 中不满足条件的时候也让它返回 <code>true</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  defineProperty(trapTarget, key, descriptor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'symbol'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'proxy'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// 'proxy'</span></span><br><span class="line"><span class="keyword">let</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, nameSymbol, &#123;</span><br><span class="line">  value: <span class="string">'symbol-proxy'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 运行结果无错误提示，因为 <code>key === &#39;symbol&#39;</code> 条件中依旧返回了 <code>true</code>  </p>
<pre><code>proxy</code></pre><div class="org-center">
标准中失败抛异常：  

<p><img src="http://qiniu.ii6g.com/1565166438.png" alt="img">  </p>
</div>

<h3 id="描述符对象约束-Descriptor-Object-Restrictions"><a href="#描述符对象约束-Descriptor-Object-Restrictions" class="headerlink" title="描述符对象约束(Descriptor Object Restrictions)"></a>描述符对象约束(Descriptor Object Restrictions)</h3><p>在<a href="#orgb70d1c1">上一节</a>中描述了属性描述符代理的使用，在使用过程中对描述符对象的定义有一定的约束<br>条件，比如 <code>defineProperty(trapTarget, key, descriptor)</code> 第三个参数就并非是完整<br>的传入的描述符对象 <code>Object.defineProperty(obj, key, descObj)</code> 。  </p>
<p>在 trap 的 <code>descriptor</code> 会忽略掉除下面属性以外的属性,  </p>
<ul>
<li><code>enumerable</code></li>
<li><code>configurable</code></li>
<li><code>value</code></li>
<li><code>writable</code></li>
<li><code>get</code></li>
<li><code>set</code></li>
</ul>
<p>除了上面 6 个属性之外，其他的属性都会被忽略掉，即使你调用<br><code>Object.defineProperty</code> 的时候传入了更多的属性。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  defineProperty(trapTarget, key, descriptor) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(descriptor.value) <span class="comment">// 'proxy'</span></span><br><span class="line">    <span class="built_in">console</span>.log(descriptor.name) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'proxy'</span>,</span><br><span class="line">  name: <span class="string">'custom'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: 结果显示实际传入的 <code>{value: &#39;proxy&#39;, name: &#39;custom&#39;}</code> 在 trap 中并没有<br><code>name</code> 。  </p>
<pre><code>proxy
undefined</code></pre><p>这是因为 trap 中的 <code>descriptor</code> 参数并非是 <code>{value: &#39;proxy&#39;, name: &#39;custom&#39;}</code> 对<br>象的引用，而是一个全新的对象，只会包含标准的 6 个属性值，其他的均不会收藏。  </p>
<p>同样， <code>Reflect.defineProperty()</code> 也一样会忽略掉非标准的属性。  </p>
<p>在 <code>getOwnPropertyDescriptor()</code> 方法中也有此类约束，这个方法要求它的返回值必须是<br><code>null</code>, <code>undefined</code> 或一个对象，如果是一个对象的时候，就会遵循这个约束，即返回的<br>对象中只能包含标准的属性(<code>enumerable</code>, <code>configurable</code>, <code>value</code>, <code>writable</code>,<br><code>get</code>, <code>set</code>)  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  getOwnPropertyDescriptor(trapTarget, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'proxy'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'name'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>TypeError: &apos;getOwnPropertyDescriptor&apos; on proxy: trap reported non-configurability for property &apos;name&apos; which is either non-existant or configurable in the proxy target</code></pre><h3 id="重复的描述符方法"><a href="#重复的描述符方法" class="headerlink" title="重复的描述符方法"></a>重复的描述符方法<a id="org8c34cb8"></a></h3><p>与之前描述的一样在 <code>Object</code> 和 <code>Reflect</code> 都同时有 <code>defineProperty()</code> 和<br><code>getOwnPropertyDescriptor()</code> 方法，但双方都有一点差异。  </p>
<ol>
<li><code>Object.defineProperty(target)</code> 返回 <code>target</code> 对象</li>
<li><code>Reflect.defineProperty(trapTarget, key, descriptor)</code> 返回 <code>true</code> 或 <code>false</code><br>表示成功或失败</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res1 = <span class="built_in">Object</span>.defineProperty(target, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'target'</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res1 === target) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res2 = <span class="built_in">Reflect</span>.defineProperty(target, <span class="string">'name'</span>, &#123; <span class="attr">value</span>: <span class="string">'reflect'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true</code></pre><ol>
<li><code>Object.getOwnPropertyDescriptor(obj, key)</code> 如果 <code>obj</code> 是原始类型会强制转换成<br>对象后再获取描述符对象，没有就返回 <code>undefined</code></li>
<li><code>Reflect.getOwnPropertyDescriptor(obj, key)</code> 和上面的不一样，如果为非对象类型<br>则会触发异常。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">'name'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res2 = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">'name'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>undefined
Reflect.getOwnPropertyDescriptor called on non-object</code></pre><h2 id="ownKeys-Trap"><a href="#ownKeys-Trap" class="headerlink" title="ownKeys Trap"></a><code>ownKeys</code> Trap<a id="org59878e2"></a></h2><p>ownKeys -&gt; <code>Reflect.ownKeys(trapTarget)</code>  </p>
<p>这个 trap 的用途是用来中断 <code>[[OwnPropertyKeys] ]</code> 的操作，然后允许在 trap 里面重<br>写“返回一个值的数组”的动作。  </p>
<p>有四个内置方法用到这个数组(<code>ownKeys</code>)  </p>
<ul>
<li><code>Object.keys()</code>  会过滤掉 <code>ownKeys</code> 中的符号类型 key</li>
<li><code>Object.getOwnPropertyNames()</code> 会过滤掉 <code>ownKeys</code> 中的符号类型 key</li>
<li><code>Object.getOwnPropertySymbols()</code> 会过滤掉 <code>ownKeys</code> 中的字符串类型 key</li>
<li><code>Object.assign()</code> 用 <code>ownKeys</code> 来决定哪些属性会被拷贝，字符串和符号 key 都会用<br>到</li>
</ul>
<p>对应默认行为的 trap 是： <code>Reflect.ownKeys()</code> 返回一个所有自身属性的 key，包含符<br>号属性。  </p>
<p>接受一个对象参数，且返回数组或类数组对象否则会报错，使用 ownKeys trap 可以让我们<br>在对该对象使用诸如 <code>Object.keys()</code>, <code>Object.getOwnPropertyNames()</code>, 等等这些方法<br>的时候去过滤一些我们不想让人获取到的一些属性，比如以下划线开头的内部方法(一般使<br>用下划线开头的放表示内部方法)。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  ownKeys(trapTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span></span><br><span class="line">      .ownKeys(trapTarget)</span><br><span class="line">    <span class="comment">// 过滤掉 _xxx() &#123;&#125; 的方法</span></span><br><span class="line">      .filter(<span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">typeof</span> key !== <span class="string">'string'</span> || key[<span class="number">0</span>] !== <span class="string">'_'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)</span><br><span class="line">proxy.name = <span class="string">'proxy'</span></span><br><span class="line">proxy._name = <span class="string">'private'</span></span><br><span class="line">proxy[nameSymbol] = <span class="string">'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(proxy), <span class="comment">// 会过滤符号key</span></span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(proxy), <span class="comment">// 会过滤符号 key</span></span><br><span class="line">    symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(names.length) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(names[<span class="number">0</span>]) <span class="comment">// 'name'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(keys.length) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(keys[<span class="number">0</span>]) <span class="comment">// 'name'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(symbols.length) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(symbols[<span class="number">0</span>]) <span class="comment">// "Symbol(name)"</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS: 前两个为 1 是因为 <code>Object.getOwnPropertyNames()</code> 和 <code>Object.keys()</code> 默<br>认会过滤掉符号属性。  </p>
<pre><code>1
name
1
name
1
Symbol(name)</code></pre><blockquote>
<p><code>ownKeys</code> 对 <code>for-in</code> 循环中也有效，它会调用 ownKeys trap 来决定哪些键可以被遍历。  </p>
</blockquote>
<h2 id="函数代理-apply和construct-traps"><a href="#函数代理-apply和construct-traps" class="headerlink" title="函数代理(apply和construct traps)"></a>函数代理(apply和construct traps)<a id="org3033f8b"></a></h2><p>在所有的 traps 中，只有 <code>apply</code> 和 <code>construct</code> trap 必须要求 <code>trapTarget</code> 是一个<br>函数。  </p>
<p>这两个 trap 分别对应 <code>[[Call] ]</code> 和 <code>[[Construct] ]</code> 低级操作，而这两个内部属性<br>对应的是函数的两种调用方式(1. 函数方式调用，2. 通过 <code>new</code> 调用)，通过 <code>apply</code> 和<br><code>construct</code> 这两个 trap 可以拦截这两种调用操作。  </p>
<p><code>apply</code> -&gt; <code>Reflect.apply(trapTarget, thisArg, argumentsList)</code><br><code>construct</code> -&gt; <code>Reflect.construct(trapTarget, argumentsList[, newTarget])</code>  </p>
<ol>
<li><code>trapTarget</code> 被代理的那个函数对象</li>
<li><code>thisArg</code> 调用 apply 时指定的作用域对象</li>
<li><code>argumentsList</code> 传递给函数的参数列表</li>
<li><code>newTarget</code> 指向函数内部 <code>new.target</code> 的值</li>
</ol>
<p>示例：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  apply(trapTarget, thisArg, argList) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(thisArg, <span class="string">'applied'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argList)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct(trapTarget, argList, newTarget) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newTarget, <span class="string">'newTarget'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argList)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> proxy) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy()) <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> proxy()</span><br><span class="line"><span class="built_in">console</span>.log(ins <span class="keyword">instanceof</span> proxy)</span><br><span class="line"><span class="built_in">console</span>.log(ins <span class="keyword">instanceof</span> target)</span><br><span class="line"></span><br><span class="line">proxy.apply(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;)</span><br><span class="line">target.apply(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>+RESULTS: apply 和 construct 分别代理了函数的两种不用使用方式(<code>apply</code> 和 <code>new</code>)。  </p>
<pre><code>function
undefined &apos;applied&apos;
42
[Function: target] &apos;newTarget&apos;
true
true
{ a: 1 } &apos;applied&apos;
undefined</code></pre><p>从结果可知 <code>newTarget</code> 参数指向的是被代理的那个原始对象 <code>trapTarget</code> 。  </p>
<p>下面将介绍如何使用这两个代理做一些事情，比如验证参数或验证函数调用方式。  </p>
<h3 id="验证函数参数"><a href="#验证函数参数" class="headerlink" title="验证函数参数"></a>验证函数参数</h3><p>检查函数参数的合法性，或限定函数只能以普通方式调用不能通过 <code>new</code> 调用。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev + next, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sumProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, &#123;</span><br><span class="line">  apply(trapTarget, thisArg, argList) &#123;</span><br><span class="line">    argList.forEach(<span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'所有参数必须是数字。'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argList)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct(trapTarget, argList) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'这个函数不能被 new 实例化。'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="string">'2'</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> sumProxy()</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>10
所有参数必须是数字。
这个函数不能被 new 实例化。</code></pre><p>上面例子也可以反过来只允许 <code>new</code> 实例化，不能被直接调用。  </p>
<h3 id="无-new-直接调用构造函数检测"><a href="#无-new-直接调用构造函数检测" class="headerlink" title="无 new 直接调用构造函数检测"></a>无 <code>new</code> 直接调用构造函数检测</h3><p>根据 <code>construct</code> trap 的第三个可选参数 <code>newTarget</code> 这个值指向的是函数的<br><code>new.target</code> 值(<a href="#org52daa00">new.target</a>)。  </p>
<p>这个值由两种值： 1. 函数调用时值为 <code>undefined</code> , 2. <code>new</code> 实例化时为当前构造函数<br>本身。  </p>
<p>使用 apply 和 construct 两个 trap 结合使用，可以做到让一个函数无 <code>new</code> 情况下直<br>接调用构造函数就可以实例化：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Nums</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'该函数必须通过 `new` 调用。'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.values = values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> NumsProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Nums, &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argList</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argList.toString())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argList)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ins = NumsProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ins.values)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1,2,3,4
[ 1, 2, 3, 4 ]</code></pre><h3 id="重写抽象基类-Abstract-Base-Class-构造函数"><a href="#重写抽象基类-Abstract-Base-Class-构造函数" class="headerlink" title="重写抽象基类(Abstract Base Class)构造函数"></a>重写抽象基类(Abstract Base Class)构造函数</h3><p>让一个类智能被继承，不能被实例化，可以通过构造函数内部的 <code>new.target</code> 来检测。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractNums</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...values) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractNums) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'该类不能被实例化，只能被继承。'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.values = values</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nums</span> <span class="keyword">extends</span> <span class="title">AbstractNums</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ins = <span class="keyword">new</span> Nums(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ins.values.toString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> AbstractNums(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1,2,3,4
该类不能被实例化，只能被继承。</code></pre><p>通过代理实现屏蔽这里的异常，即让 <code>AbstractNums</code> 构造函数中的检测失败。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractNums</span> </span>&#123;</span><br><span class="line">  construct(...values) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractNums) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'该类不能被实例化，只能被继承。'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.values = values</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.values.toString(), <span class="string">'this.values'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> AbstractNumsProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(AbstractNums, &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, argList</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argList.toString(), <span class="string">'proxy'</span>);</span><br><span class="line">    <span class="comment">// 因为第三个参数即  new.target 值，这里第三个参数传递个空函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argList, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这里就不会报错了</span></span><br><span class="line"><span class="keyword">let</span> ins = <span class="keyword">new</span> AbstractNumsProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ins.values, <span class="string">'eee'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="可调用的类的构造函数"><a href="#可调用的类的构造函数" class="headerlink" title="可调用的类的构造函数"></a>可调用的类的构造函数</h3><p>类的使用，在代理出现之前是无法直接调用的，因为其内部的 <code>[[Call] ]</code> 属性被绑定到<br>异常上，只要发生调用就会触发异常。  </p>
<p>但是有了代理之后，我们可以通过代理去实现一个可直接调用的类去创建一个实例，实际上<br>还是代理里面去创建了实例。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> PersonProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> trapTarget(...argList)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = PersonProxy(<span class="string">'xxx'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(me.name) <span class="comment">// xxx</span></span><br><span class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> PersonProxy) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>xxx
true
true</code></pre><h2 id="可撤销的代理-Revocable"><a href="#可撤销的代理-Revocable" class="headerlink" title="可撤销的代理(Revocable)"></a>可撤销的代理(Revocable)<a id="org0e4d674"></a></h2><p>通常情况下，代理一旦被创建就无法与 <code>target</code> 解绑，但是有一些特殊情况，比如代理可<br>能不再需要了，需要将其解绑掉。  </p>
<p>在这之前通过 <code>new Proxy()</code> 创建的都是不可撤销的代理，如果需要创建可撤销的代理得<br>使用 <code>Proxy.revocable()</code> 接口。  </p>
<p>参数和 <code>Proxy()</code> 一样，需要一个被代理对象和一个代理 traps 对象：<br><code>Proxy.revocable(target, trapObj)</code>  </p>
<p>调用之后的返回值是一个包含两个属性的对象：  </p>
<ol>
<li><code>proxy</code> 一个可被撤销的代理</li>
<li><code>revoke</code> 用来撤销代理的函数</li>
</ol>
<p>任何时候执行了 <code>revoke()</code> 那就表示 <code>proxy</code> 不再可用，任意试图去通过 proxy trap<br>去中断低级操作的行为都将触发异常，因为 <code>proxy</code> 已经被撤销了没法用了。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  name: <span class="string">'target'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(proxy.name)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>target
Cannot perform &apos;get&apos; on a proxy that has been revoked</code></pre><h2 id="解决数组问题"><a href="#解决数组问题" class="headerlink" title="解决数组问题"></a>解决数组问题</h2><p>proxy-reflect 的出现同样赋予了开发者跟踪数组变化的能力，比如数组长度变化可以做一<br>些特殊处理。  </p>
<p>对数组的访问和设置，可以使用之前讲过的 get-trap(<a href="#org38c7be9">13.3.3</a>) 和 set-trap(<a href="#org999196c">13.3.2</a>)，<br>用来监听数组的访问、长度或内容的变化。  </p>
<h3 id="监听数组长度的变化"><a href="#监听数组长度的变化" class="headerlink" title="监听数组长度的变化"></a>监听数组长度的变化</h3><p>通过数组对象的代理，可以监听数组对象长度或值的变化，从而触发一些自定义的行为。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toUnit32 = <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(v))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line"><span class="keyword">const</span> isArrayIndex = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> numericKey = toUnit32(key)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">length = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; length &#125;, &#123;</span><br><span class="line">    <span class="keyword">set</span>(trapTarget, key, value) &#123;</span><br><span class="line">      <span class="keyword">let</span> currLen = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">'length'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isArrayIndex(key)) &#123;</span><br><span class="line">        <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numericKey &gt;= currLen) &#123;</span><br><span class="line">          <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">'length'</span>, numericKey + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = createArray(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line">colors[<span class="number">1</span>] = <span class="string">'green'</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line"></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">'black'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3
3
4
black
undefined</code></pre><h3 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素<a id="orgab2d3e4"></a></h3><p>在以往，要删除数组元素(缩减数组)，可以通过数组长度的设置来达到目的，数组多余的元素会被抛弃掉。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(nums.toString())</span><br><span class="line">nums.length = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.toString())</span><br><span class="line">nums.length = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.toString())</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>1,2,3
1
1,,</code></pre><p>使用代理也可以达到这个目的，并且可以监听数组的变化：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toUnit32 = <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(v))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line"><span class="keyword">const</span> isArrayIndex = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> numericKey = toUnit32(key)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">length = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; length &#125;, &#123;</span><br><span class="line">    <span class="keyword">set</span>(trapTarget, key, value) &#123;</span><br><span class="line">      <span class="keyword">let</span> currLen = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">'length'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isArrayIndex(key)) &#123;</span><br><span class="line">        <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key)</span><br><span class="line">        <span class="keyword">if</span> (numericKey &gt;= currLen) &#123;</span><br><span class="line">          <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">'length'</span>, numericKey + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">'length'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; currLen) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = currLen - <span class="number">1</span>; i &gt;= value; i--) &#123;</span><br><span class="line">            <span class="built_in">Reflect</span>.deleteProperty(trapTarget, i)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = createArray(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line">colors[<span class="number">1</span>] = <span class="string">'green'</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">'blue'</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">'black'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]) <span class="comment">// 'green'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]) <span class="comment">// 'black'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3
4
2
undefined
undefined
green
red</code></pre><p>上面代码中实现了两种变化：  </p>
<ol>
<li><code>key</code> 为数组下标，即数组元素值的变化，会将长度基于它的索引加 1</li>
<li><code>length</code> 属性值的变化，如果新的长度值小于原有的元素长度，多余的元素会被删除掉</li>
</ol>
<h3 id="实现数组类"><a href="#实现数组类" class="headerlink" title="实现数组类"></a>实现数组类<a id="orgb50f6a3"></a></h3><p>最简单的实现方式是按照普通类定义然后在构造函数中返回一个代理。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">this</span>, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myTh = <span class="keyword">new</span> Thing()</span><br><span class="line"><span class="built_in">console</span>.log(myTh <span class="keyword">instanceof</span> Thing) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>返回的 <code>new Proxy(this, {})</code> 有两个参数：  </p>
<ol>
<li><code>this</code> 为 <code>Thing</code> 类的实例</li>
<li><code>{}</code> 为 <code>Thing</code> 实例的代理 trap 对象</li>
</ol>
<p><code>myTh</code> 是 <code>Thing</code> 实例的代理对象。  </p>
<p>这里的实现和“删除数组元素<a href="#orgab2d3e4">13.10.2</a>”一节中基本一样，不同点在于 <code>new
    Proxy()</code> 在类的构造函数中返回。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toUnit32 = <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(v))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line"><span class="keyword">const</span> isArrayIndex = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> numericKey = toUnit32(key)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length = 0) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; length &#125;, &#123;</span><br><span class="line">      <span class="keyword">set</span>(trapTarget, key, value) &#123;</span><br><span class="line">        <span class="keyword">let</span> currLen = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">'length'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isArrayIndex(key)) &#123;</span><br><span class="line">          <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key)</span><br><span class="line">          <span class="keyword">if</span> (numericKey &gt;= currLen) &#123;</span><br><span class="line">            <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">'length'</span>, numericKey + <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">'length'</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value &lt; currLen) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = currLen - <span class="number">1</span>; i &gt;= value; i--) &#123;</span><br><span class="line">              <span class="built_in">Reflect</span>.deleteProperty(trapTarget, i)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> MyArray(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line">colors[<span class="number">1</span>] = <span class="string">'green'</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">'blue'</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">'black'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]) <span class="comment">// 'green'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]) <span class="comment">// 'black'</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>3
4
2
undefined
undefined
green
red</code></pre><h2 id="Proxy-作为原型使用，从而实例共享代理"><a href="#Proxy-作为原型使用，从而实例共享代理" class="headerlink" title="Proxy 作为原型使用，从而实例共享代理"></a>Proxy 作为原型使用，从而实例共享代理</h2><h3 id="原型-get-trap"><a href="#原型-get-trap" class="headerlink" title="原型 get trap"></a>原型 <code>get</code> trap</h3><p>原型代理在使用上有一定的限制，它只能响应原型至上的操作，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newTarget = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  defineProperty(trapTarget, name, descriptor) &#123;</span><br><span class="line">    <span class="comment">// 正常的话这里返回 false 会触发异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(newTarget, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'newTarget'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newTarget.name) <span class="comment">// 'newTarget'</span></span><br><span class="line"><span class="built_in">console</span>.log(newTarget.hasOwnProperty(<span class="string">'name'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>newTarget
true</code></pre><p>上面的代理并没有响应 <code>name</code> 属性增加操作，因为 <code>new Proxy()</code> 在<br><code>Object.create(proxy)</code> 作为参数传递结果会是新创建对象的原型，也就是说<br><code>newTarget</code> 的原型是 <code>new Proxy()</code> 的代理，而原型代理是没法响应对象本身的变化。  </p>
<p>但是在有些情况下原型代理还是很有用的，比如获取对象属性操作，因为对象的获取遵循原<br>型链查找，如果对象本身找不到该属性就会往上查找原型对象，此时如果原型对象是代理的<br>话就可以监听到该属性值的获取操作，从而做出响应。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="keyword">get</span>(trapTarget, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">thing.name = <span class="string">'thing'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thing.name) <span class="comment">// 'thing'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(thing.unknown) <span class="comment">// error</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>thing
unknown doesn&apos;t exist.</code></pre><p>给 <code>thing</code> 新增了一个 <code>name</code> 属性，获取的时候拿到的是该对象本身的 <code>name</code> 属性，<br>因此正常，但是当获取 <code>thiing.unknown</code> 的时候对象本身没找到会到原型上去找，而原型<br>是一个代理对象， <code>get</code> trap 中阻止了任何原型属性的获取操作，因此报错异常。  </p>
<h3 id="原型-set-trap"><a href="#原型-set-trap" class="headerlink" title="原型 set trap"></a>原型 <code>set</code> trap</h3><p>对象操作的 <code>set</code> 和 <code>get</code> 一样首先查找本身，如果没有就往原型查找，因此这里也可以<br>通过 <code>set</code> trap 去对原型属性的设置操作做一定的响应和拦截。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="keyword">set</span>(trapTarget, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'key: '</span> + key, <span class="string">'value: '</span> + value)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thing.hasOwnProperty(<span class="string">'name'</span>)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">thing.name = <span class="string">'thing'</span> <span class="comment">// 这里会触发 `set` 代理，因为 thing 中没有 `name` 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(thing.name) <span class="comment">// 'thing'</span></span><br><span class="line"><span class="built_in">console</span>.log(thing.hasOwnProperty(<span class="string">'name'</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">thing.name = <span class="string">'boo'</span> <span class="comment">// 这个时候 thing 中已经有 `name` 了，因此不会触发 `set` trap</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thing.name)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false
key: name value: thing
thing
true
boo</code></pre><h3 id="原型-has-trap"><a href="#原型-has-trap" class="headerlink" title="原型 has trap"></a>原型 <code>has</code> trap</h3><p><code>key in obj</code> 对于 <code>in</code> 操作符，它不仅会检测对象本身，还会检查原型链，与其对应的<br>proxy-trap 为 <code>has</code> trap，即我们可以通过这个 trap 来对 <code>in</code> 操作做一定的处理，比<br>如让它针对被代理的对象在原型上的查找都失效。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  has(trapTarget, key) &#123;</span><br><span class="line">    <span class="comment">// return false 让原型的查找失效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(trapTarget, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> thing) <span class="comment">// 触发代理，因为 target 没 name 属性，会去查找原型</span></span><br><span class="line"></span><br><span class="line">thing.name = <span class="string">'thing'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> thing) <span class="comment">// 不会触发</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false
true</code></pre><h3 id="代理作为原型作用域类上面"><a href="#代理作为原型作用域类上面" class="headerlink" title="代理作为原型作用域类上面"></a>代理作为原型作用域类上面</h3><p>类是不能直接使用代理作为原型，因为累的原型属性是 <em>non-writable</em> 的，但是我们可以<br>通过类的继承来变相实现代理原型.  </p>
<p>构造函数风格的原型代理：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NoSuchProperty.prototype = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(trapTarget, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thing = <span class="keyword">new</span> NoSuchProperty()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = thing.name</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>name doesn&apos;t exist</code></pre><p>有了上面的 <code>NoSuchProperty</code> 构造函数之后，就可以让一个类去继承它，从而让类的原型<br>成为代理。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NoSuchProperty.prototype = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(trapTarget, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">NoSuchProperty</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shape = <span class="keyword">new</span> Square(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">let</span> area1 = shape.length * shape.width</span><br><span class="line"><span class="built_in">console</span>.log(area1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// error, no `wdth` property, 会去原型查找</span></span><br><span class="line">  <span class="keyword">let</span> area2 = shape.length * shape.wdth</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>12
wdth doesn&apos;t exist</code></pre><p>上面的实例中 <code>new Proxy()</code> 代理实际上是 <code>NoSuchProperty</code> 的原型，而非 <code>Square</code><br>的，但是依然有效是因为原型链特征的原因，原型链查找不单单是查找父级对象还会往上一<br>直查找原型，直到 <code>Object.prototype</code> 结束查找。  </p>
<p>上例中各对象原型间的关系：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(trapTarget, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">NoSuchProperty.prototype = proxy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">NoSuchProperty</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shape = <span class="keyword">new</span> Square(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">let</span> shapeProto = <span class="built_in">Object</span>.getPrototypeOf(shape)</span><br><span class="line"><span class="built_in">console</span>.log(proxy === shapeProto) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> secondLevelProto = <span class="built_in">Object</span>.getPrototypeOf(shapeProto)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(secondLevelProto === proxy) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false
true</code></pre><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p><code>Proxy</code> : 允许拦截底层操作，给这些操作定义一些非标准的行为，比如监听数组长度变化，<br>对象属性的删除操作。  </p>
<p><code>Reflect</code> : 针对每个 proxy trap 执行它们的默认行为，每一个 proxy trap 都有一个相<br>对应且同名的 <code>Reflect</code> 方法与之对应，如<a href="#org6bf2c25">对应表</a>。  </p>
<p><code>revocable proxy</code> : 允许解绑的 proxy 。  </p>
<p>原型代理：可以让一个代理成为一个对象的原型，从而可以对该对象的原型的操作进行拦<br>截，比如 <code>get</code>, <code>set</code>, <code>has</code> proxy traps。  </p>
<h1 id="代码模块化"><a href="#代码模块化" class="headerlink" title="代码模块化"></a>代码模块化</h1><h2 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a>什么是模块？</h2><p>模块与普通的 <em>scripts</em> 使用有很大的不同：  </p>
<ol>
<li>模块代码默认严格模式运行，并且不能改变</li>
<li>当前模块创建的全局变量只针对于该模块而言，作用域仅限于该模块内</li>
<li>一个模块的 <code>this</code> 值为 <code>undefined</code></li>
<li>模块内的代码不允许包含 html 格式的注释</li>
<li>模块内必须有导出，提供给模块外部使用</li>
<li>模块内通过 <code>import</code> 可以导入其他模块代码</li>
</ol>
<p>模块赋予了指定需要的代码导入导出的能力.  </p>
<h2 id="基本导出-export"><a href="#基本导出-export" class="headerlink" title="基本导出(export)"></a>基本导出(<code>export</code>)</h2><p>你可以使用 <code>export</code> 关键字去将模块内的指定内容导出给其他模块使用，比如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">'red'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">'xx'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> magicNumber = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(len, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.len = len</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 - n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 * n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定义后导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; multiply &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>变量、函数、类的导出都必须明确指定一个名字，因为外部使用的时候需要通过这个名<br>字去使用</li>
<li><code>multiply</code> 并没有在定义的时候导出，也就是说不需要总是导出定义也可以只导出引用</li>
<li><code>subtract</code> 并没有被导出，就意味着模块外无法访问它，但是模块内部只要满足作用域<br>就可以访问</li>
</ol>
<h2 id="基本导入-import"><a href="#基本导入-import" class="headerlink" title="基本导入(import)"></a>基本导入(<code>import</code>)</h2><p>一旦拥有使用 <code>exports</code> 导出的模块了，那么就可以在其他模块通过 <code>import</code> 关键词来<br>导入这些内容，比如：  </p>
<p><code>import { identifier1, identifier2 } from &#39;./example.js&#39;;</code>  </p>
<p>可以从 <em>example.js</em> (一个文件视为一个模块)，将 <code>identifier1</code> 导入。  </p>
<p>模块导入语法导入的变量默认使用的是 <code>const</code> 定义的，也就意味着导入之后不能改变变<br>量的值。  </p>
<p>但是可以通过 <code>import { a as b } from &#39;./c.js&#39;;</code> 语法来重新定义命令名称。  </p>
<p>导入有多种方式，比如：只导入一个，导入多个，导入全部等等。  </p>
<h3 id="导入单个"><a href="#导入单个" class="headerlink" title="导入单个"></a>导入单个</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// import 导入默认 const 不能改变</span></span><br><span class="line">sum = <span class="number">1</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>导入时候的路径必须与使用导入模块的文件路径想匹配，即必须要能找到模块文件的正确路<br>径。  </p>
<h3 id="导入多个"><a href="#导入多个" class="headerlink" title="导入多个"></a>导入多个</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum, multiply, magicNumber &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, magicNumber)) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="导入所有"><a href="#导入所有" class="headerlink" title="导入所有"></a>导入所有</h3><p>可以通过  </p>
<p><code>import * as example from &#39;./example.js&#39;;</code>  </p>
<p>将 <em>example.js</em> 模块导出的所有绑定导出到 <code>example</code> 对象中，然后可以通过<br><code>example.sum()</code> 方式去访问模块中的内容。  </p>
<p>对同一个模块使用多个 <code>import</code> 最终模块都会只执行一次，它会在第一次导入的时候就存<br>在于内存中等待复用，其他后面的使用的 <code>import</code> 语句都只是服用内存中的模块。  </p>
<p>不仅仅一个模块中多次使用 <code>import</code> 导入一个模块多次只会执行一次，就是多个模块同时<br>多次导入同一个模块也只会在内存中保存一份引用，且所有模块对该模块的导入都只会使用<br>这一份引用。  </p>
<p>也就是说在一个应用实例中，单个模块只会有一份，尽管会被多个模块多次导入。  </p>
<blockquote>
<p>模块语法限制：  </p>
<p><code>export</code> 和 <code>import</code> 不能在函数或语句表达式中使用，比如：  </p>
<p><code>if (flag) { export flag; }</code> 语法错误。  </p>
<p>导出只能在模块的顶级作用域才能使用，函数或块级作用域中不允许使用。  </p>
<p>同样， <code>import</code> 只能在文件顶部执行导入。  </p>
</blockquote>
<h2 id="重命名导入导出"><a href="#重命名导入导出" class="headerlink" title="重命名导入导出"></a>重命名导入导出</h2><p>导出重命名：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> add &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>

<p>导入重命名：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum <span class="keyword">as</span> add &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>

<h2 id="模块默认值"><a href="#模块默认值" class="headerlink" title="模块默认值"></a>模块默认值</h2><p>导出默认值：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="comment">// 导出默认值不需要变量名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量名方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  sum <span class="keyword">as</span> <span class="keyword">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导入默认值：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>将 <em>example.js</em> 中 <code>export default</code> 内容导出且赋予名称为 <code>sum</code> 。  </p>
<p>混合使用：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> color = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> sum, &#123; color &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">// 'red'</span></span><br></pre></td></tr></table></figure>

<p>导出默认重命名：  </p>
<p><code>import { default as sum, color } from &#39;./example.js&#39;</code>  </p>
<h2 id="导入之后导出"><a href="#导入之后导出" class="headerlink" title="导入之后导出"></a>导入之后导出</h2><p>即从一个模块导出一个内容，然后在当前模块中又将这个内容导出。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入-导出-重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> add &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入所有导出所有</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br></pre></td></tr></table></figure>

<h2 id="无导出的模块导入"><a href="#无导出的模块导入" class="headerlink" title="无导出的模块导入"></a>无导出的模块导入</h2><p>即被导入的模块中并没有要导出的内容，这个时候只需要导入这个模块并且执行它即可。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.pushAll = <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> items = []</span><br><span class="line"></span><br><span class="line">items.pushAll(colors)</span><br></pre></td></tr></table></figure>

<p>上面的代码会将 <em>a.js</em> 的内容直接在 <em>b.js</em> 中导入执行，这样 <code>Array</code> 上有了<br><code>pushAll</code> 方法。  </p>
<blockquote>
<p>无导出的模块通常用来创建 polyfills 和 shims，模块代码只希望导入时立即执行。  </p>
</blockquote>
<h2 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h2><h3 id="浏览器中使用模块"><a href="#浏览器中使用模块" class="headerlink" title="浏览器中使用模块"></a>浏览器中使用模块</h3><p>ECMAScript 6中虽然定义了模块语法，但并没有定义如何去加载他们。  </p>
<ol>
<li>通过 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性加载一个脚本文件执行里面的代码</li>
<li>通过嵌入 <code>&lt;script&gt;</code> 标签，在标签里面直接书写 js 代码</li>
<li>加载 js 代码放到一个 <code>worker</code> 里面执行</li>
</ol>
<p>为了完全支持模块，浏览器不得不更新这些机制。  </p>
<p><code>script</code>标签中使用模块，<code>script</code> 标签的默认行为是当 <code>type</code> 属性不指定或指定为一个 JavaScript 脚本类型的时<br>候(比如： <code>text/javascript</code>)，会加载一个 JavaScript 作为脚本去执行它而非模块。  </p>
<p>script 标签会执行 <code>src</code> 加载的文件内的代码或者 <code>&lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 之间的<br>代码。  </p>
<p>为了支持模块， <code>type</code> 类型新增了一个 <code>&quot;module&quot;</code> 类型值，通过设置 <code>type=&quot;module&quot;</code><br>告诉浏览器，该脚本包含的是一个模块代码。  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"module.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> result = sum(<span class="number">1</span>,<span class="number">2</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个 <code>&lt;script&gt;</code> 标签加载了一个 <code>src</code> 指定的外部文件，唯一不同的是指定的类型为<br><code>&quot;module&quot;</code> 。  </p>
<p>第二个 <code>&lt;scrpt&gt;</code> 标签直接嵌入了一段代码通过 <code>import</code> 导入了一个外部脚本文件，因<br>此 <code>result</code> 变量不会被加入到 <code>window</code> 对象上去，因为它只在这个 <code>&lt;script&gt;</code> 模块中<br>生效。  </p>
<p>测试实例：  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>a.html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./a.js"</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> globalResult = <span class="number">1000</span>;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> result = sum(<span class="number">1</span>,<span class="number">2</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'module result 1'</span>, result);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'global result'</span>, <span class="built_in">window</span>.globalResult);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'module result 2'</span>, <span class="built_in">window</span>.result); <span class="comment">// undefined</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>chrome 浏览器执行结果：  </p>
<p><img src="http://qiniu.ii6g.com/1565600666.png" alt="img">  </p>
<p>从结果所示：  </p>
<ol>
<li><code>type=&#39;module&#39;</code> 的 <code>script</code> 最后被加载执行，因为其默认应用了 <code>defer</code> 属性</li>
<li>模块内部的变量不会添加到 <code>window</code> 对象上</li>
</ol>
<h3 id="Web浏览器中的模块加载序列"><a href="#Web浏览器中的模块加载序列" class="headerlink" title="Web浏览器中的模块加载序列"></a>Web浏览器中的模块加载序列</h3><p><code>&lt;script type=&quot;module&quot;&gt;</code> 的标签默认应用了 <code>defer</code> 属性，意味着它会被下载但不会被<br>立即执行，只有当 DOM 被完全解析完成之后才会被执行，多个模块的时候会按照它们在<br>DOM 结构中的顺序来执行，不区分是 <code>src</code> 引入模块文件还是直接嵌入代码方式。  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>a.html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./a.js"</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> globalResult = <span class="number">1000</span>;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> result = sum(<span class="number">1</span>,<span class="number">2</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'module result 1'</span>, result);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> testEl1 = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(testEl1, <span class="string">'test el 1'</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'global result'</span>, <span class="built_in">window</span>.globalResult);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'module result 2'</span>, <span class="built_in">window</span>.result); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> testEl2 = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(testEl2, <span class="string">'test el 2'</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<p><img src="http://qiniu.ii6g.com/1565683852.png" alt="img">  </p>
<p>可以看到在普通的 <code>script</code> 标签中 ‘test el 2’ 结果是 <code>undefined</code> 因为这个时候<br><em>div#test</em> 并没有并创建，因为它在所有的 <code>script</code> 之后。  </p>
<p>但是 ‘test el 1’ 得到了正确的结果能获取到 <em>div#test</em> 元素，这恰恰说明了类型为<br>‘module’ 的 <code>script</code> 标签在 DOM 解析完成之后执行。  </p>
<blockquote>
<p>多个 <code>script#module</code> 标签，会同步下载文件以及每个 <code>script</code> 里面的 <code>import</code> 的文<br>件，但是不会立即执行，只有当 document 解析完成之后才会去执行它们，执行顺序为先<br>script 后 script 中的 import, 然后下一个 script 及其里面的 import，如此知道执行<br>完成。  </p>
</blockquote>
<h3 id="浏览器中的异步模块加载"><a href="#浏览器中的异步模块加载" class="headerlink" title="浏览器中的异步模块加载"></a>浏览器中的异步模块加载</h3><p><code>&lt;script type=&quot;module&quot; async src=&quot;module1.js&quot;&gt;&lt;/script&gt;</code>  </p>
<p><code>async</code> 表示 <em>module1.js</em> 一旦下载完成就会被立即执行，且不影响其他脚本的下载和执<br>行，哪个下载完成谁就先执行。  </p>
<h3 id="Worker-加载模块"><a href="#Worker-加载模块" class="headerlink" title="Worker 加载模块"></a>Worker 加载模块</h3><p>我们都知道 JavaScript 是单线程的，但是有时候我们又需要做一些繁琐的工作，却不希望<br>影响到主线程的运行，这个时候就可以用到 <code>Worker</code> 它相当于重新起了一个线程给指定的<br>脚本去执行，并且不会阻塞主线程，还提供了与之通信的接口。  </p>
<p>脚本 Worker : <code>new Worker(&#39;script.js&#39;);</code>  </p>
<p>模块 Worker : <code>new Worker(&#39;module.js&#39;, { type: &#39;module&#39; });</code>  </p>
<p>模块和脚本 <code>Worker</code> 差异：  </p>
<ol>
<li>脚本 Worker 只能加载同源脚本文件，即不支持跨域，但是模块 Worker 没有找个限制</li>
<li>脚本 Worker 可以使用 <code>self.importScripts()</code> 方法去加载其他的脚本，而在模块<br>Worker 中只能使用 <code>import</code> 去加载其他脚本文件</li>
</ol>
<h3 id="加载文件路径限制"><a href="#加载文件路径限制" class="headerlink" title="加载文件路径限制"></a>加载文件路径限制</h3><p>在模块引入的时候的路径只能是 <code>/</code>, <code>./</code>, <code>../</code> 这种相对路径或者直接是包含域名的绝<br>对路径，比如： *<a href="http://x.x.x.x/path/to/file.js" target="_blank" rel="noopener">http://x.x.x.x/path/to/file.js</a>* (需要配置 CORS 允许跨域访问)。  </p>
<p>其他情况不被允许，比如：  </p>
<p><code>import { first } from &#39;a.js&#39;;</code> // error  </p>
<p><code>import { second } from &#39;path/a.js&#39;;</code> // error  </p>
<p>上面两种都不会被浏览器下载，因为模块文件的路径不合法，尽管在 <code>script</code> 的 <code>src</code><br>属性值中可以这么使用，这也是 <code>script</code> 和 <code>import</code> 的一个区别。  </p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="try-x2026-catch-简写2019"><a href="#try-x2026-catch-简写2019" class="headerlink" title="try&#x2026;catch 简写2019"></a>try&#x2026;catch 简写<sup>2019</sup></h2><p><code>try {} catch {}</code> 现在可以省略 <code>catch(e)</code> ，直接将 <code>catch</code> 变成一个关键字。  </p>
<h1 id="附录-A：-更小的变更"><a href="#附录-A：-更小的变更" class="headerlink" title="附录 A： 更小的变更"></a>附录 A： 更小的变更</h1><h2 id="Integers-整型数据"><a href="#Integers-整型数据" class="headerlink" title="Integers 整型数据"></a>Integers 整型数据</h2><p>JavaScript 使用了 IEEE 754 编码系统来表示整型和浮点数，这在以往引起不少困惑。  </p>
<p>ECMAScript 6 中与数值有关的更新让整型的表示和使用更加便利。  </p>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h3><p>判断数值是否是整型数值：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isInt = <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Number</span>.isInteger(v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isInt(<span class="string">'1'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isInt(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isInt(<span class="number">1.0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isInt(<span class="number">1.8</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isInt(<span class="string">''</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isInt(<span class="string">'a'</span>))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>false
true
true
false
false
false</code></pre><p><code>1.0</code> 会被当做整型值 <code>1</code> 存储，因此这里得到的结果是 <code>true</code> ,<br><code>Number.isInteger()</code> 如果遇到数值型数据，在判断的时候会依据这些数值型数据在内存<br>中的存储形式来决定最终结果(浮点、整型存储方式是不一样的)。  </p>
<h3 id="安全整型值"><a href="#安全整型值" class="headerlink" title="安全整型值"></a>安全整型值</h3><p>IEEE754 的安全整型值范围为： -2<sup>53</sup> ~ 2<sup>53</sup>，超出这个范围的值都被视为非安全数<br>值。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>9007199254740992
9007199254740992</code></pre><p>第二个 <code>+1</code> 之后超出了范围，得的结果相当于没有执行加法操作的结果值。  </p>
<p><code>Number.isSafeInteger()</code> 检测是否是安全整型值。  </p>
<p><code>Number.MAX_SAFE_INTEGER</code> 得到当前机器上的最大安全整型值。  </p>
<p><code>Number.MIN_SAFE_INTEGER</code> 得到当前机器上的最小安全整型值。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inside = <span class="built_in">Number</span>.MAX_SAFE_INTEGER,</span><br><span class="line">    outside = inside + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(inside)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(inside)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(outside)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(outside)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>true
true
true
false</code></pre><h2 id="新-Math-方法"><a href="#新-Math-方法" class="headerlink" title="新 Math 方法"></a>新 Math 方法</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>Math.acosh(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>Math.asinh(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>Math.atanh(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>Math.cbrt(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>Math.clz32(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>Math.cosh(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>Math.expm1(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>Math.fround(x)</code></td>
<td>x 最近的单精度浮点数</td>
</tr>
<tr>
<td><code>Math.hypot(...values)</code></td>
<td>参数列表平方和的平方根</td>
</tr>
<tr>
<td><code>Math.imul(x, y)</code></td>
<td></td>
</tr>
<tr>
<td><code>Math.log1p(x)</code></td>
<td>1 + x 的自然对数</td>
</tr>
<tr>
<td><code>Math.log10(x)</code></td>
<td>10 为底 x 的对数</td>
</tr>
<tr>
<td><code>Math.log2(x)</code></td>
<td>2 为底 x 的对数</td>
</tr>
<tr>
<td><code>Math.sign(x)</code></td>
<td>检查数值符号</td>
</tr>
<tr>
<td></td>
<td>-1 : x 负数</td>
</tr>
<tr>
<td></td>
<td>0 : x 为 +0 或 -0</td>
</tr>
<tr>
<td></td>
<td>1 : x 正数</td>
</tr>
<tr>
<td><code>Math.sigh(x)</code></td>
<td>x 的双曲正弦</td>
</tr>
<tr>
<td><code>Math.tanh(x)</code></td>
<td>x 的双曲正切</td>
</tr>
<tr>
<td><code>Math.trunc(x)</code></td>
<td>浮点数取整</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.acosh(<span class="number">30</span>), <span class="string">'cos'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.sinh(<span class="number">1</span>), <span class="string">'sinh'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.tanh(<span class="number">30</span>), <span class="string">'tanh'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">30.112</span>), <span class="string">'trunc'</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h2 id="Unicode-标识符"><a href="#Unicode-标识符" class="headerlink" title="Unicode 标识符"></a>Unicode 标识符</h2><p>用 Unicode 标识符做变量名称：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> \u0061 = <span class="string">'abc'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(\u0061)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>abc
abc</code></pre><h2 id="正规化-proto-属性"><a href="#正规化-proto-属性" class="headerlink" title="正规化 __proto__ 属性"></a>正规化 <code>__proto__</code> 属性</h2><h1 id="附录-B：理解-ECMAScript-7-2016"><a href="#附录-B：理解-ECMAScript-7-2016" class="headerlink" title="附录 B：理解 ECMAScript 7 (2016)"></a>附录 B：理解 ECMAScript 7 (2016)</h1><p>为了更好的记录规范，最终将采用版本号+年份方式来记录，比如  </p>
<p>ECMAScript 6 为 ECMAScript 2015，表示 2015 年发布的标准。  </p>
<p>ECMAScript 7 为 ECMAScript 2016，表示 2016 年发布的标准  </p>
<p>ECMAScript 7 发布与 2016年3月，它值包好了三个新增内容：  </p>
<ol>
<li><code>**</code> 幂运算操作符，等同于 <code>Math.pow(x, y)</code> 方法</li>
<li><code>Array.prototype.includes()</code> 方法，用来检测数组是否包含某个元素，返回<br><code>true/false</code></li>
<li>支持函数域的严格模式</li>
</ol>
<h2 id="幂运算操作符"><a href="#幂运算操作符" class="headerlink" title="** 幂运算操作符"></a><code>**</code> 幂运算操作符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="number">5</span> ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(res === <span class="built_in">Math</span>.pow(<span class="number">5</span>, <span class="number">2</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>25
true</code></pre><p><strong>优先级</strong> : 高于所有的二元元算法，低于一元运算符。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="number">2</span> * <span class="number">5</span> ** <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 高于 *</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> ** <span class="number">-2</span>) <span class="comment">// 0.04</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>50
0.04</code></pre><p>但是不允许一元运算符出现在 <code>**</code> 的左侧，因为这样就没法判定哪个优先级更高，容易造<br>成混淆，如果非要使用就必须使用 <code>()</code> 括起来。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = -(<span class="number">5</span> ** <span class="number">2</span>) <span class="comment">// -25</span></span><br><span class="line"><span class="keyword">let</span> res2 = (<span class="number">-5</span>) ** <span class="number">2</span> <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res1, res2)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>-25 25</code></pre><p><code>++</code> 和 <code>--</code> 在 <code>**</code> 中表达式中的使用：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">2</span>,</span><br><span class="line">    n2 = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(++n1 ** <span class="number">2</span>) <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(n1) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n2-- ** <span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(n2) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>9
3
4
1</code></pre><p>但是不允许直接在数字上使用 <code>++</code> 和 <code>--</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = ++<span class="number">5</span> ** <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>ReferenceError: Invalid left-hand side expression in prefix operation</code></pre><h2 id="Array-prototype-includes-val-startIdx"><a href="#Array-prototype-includes-val-startIdx" class="headerlink" title="Array.prototype.includes(val[, startIdx])"></a><code>Array.prototype.includes(val[, startIdx])</code></h2><p><a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/">includes 内部实现伪码。</a>  </p>
<p>查找 <code>val</code> 是否在数组中， <code>startIdx</code> 指定查找的其实索引，找到返回 <code>true</code> 否则返<br>回 <code>false</code> 。  </p>
<p><code>includes()</code> 会将 <code>NaN</code> 视为同一个值，也就是说在比较的时候 <code>NaN</code> 和 <code>NaN</code> 比较的<br>结果是真值，而 <code>indexOf()</code> 中使用的是 <code>===</code> 判断， <code>NaN === NaN</code> 结果是 <code>false</code>  </p>
<p>所以使用 <code>includes()</code> 更合理更安全，如果不需要被查找元素的索引值的话。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vals = [<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(vals.indexOf(<span class="literal">NaN</span>))</span><br><span class="line"><span class="built_in">console</span>.log(vals.includes(<span class="literal">NaN</span>))</span><br></pre></td></tr></table></figure>

<p>+RESULTS:  </p>
<pre><code>-1
true</code></pre><p>实现内部对于零值的比较实用的是抽象操作 <a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/">SameValueZero</a>内中对 <code>NaN</code> 的判断并非是等<br>式判断而是通过 <code>isNaN()</code> 方式的判断，对于零值有正负零值的判断(<code>1/0 ===
   Infinity</code>, <code>1/-0 === Infinity</code>)，更多详情请查看<a href="https://blog.ii6g.com/2019/07/08/ecma_pseudo_code/">实现伪码</a>。  </p>
<h2 id="函数域的严格模式"><a href="#函数域的严格模式" class="headerlink" title="函数域的严格模式"></a>函数域的严格模式</h2><p>即可以在函数顶部使用 <code>&quot;use strict&quot;;</code> 来指定当前函数执行模式为严格模式，不影响函<br>数外的代码。  </p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/" target="_blank" rel="noopener">new-es2018-features-every-javascript-developer-should-know</a></li>
</ul>
<h1 id="新增内容列表"><a href="#新增内容列表" class="headerlink" title="新增内容列表"></a>新增内容列表</h1><h2 id="Object-和-Reflect-重复函数比较"><a href="#Object-和-Reflect-重复函数比较" class="headerlink" title="Object 和 Reflect 重复函数比较"></a>Object 和 Reflect 重复函数比较</h2><table>
<thead>
<tr>
<th></th>
<th><code>Object</code></th>
<th><code>Reflect</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>getOwnPropertyDescriptor(obj, key)</code></td>
<td>obj 原始类型强转</td>
<td>obj 原始类型会抛异常</td>
</tr>
</tbody></table>
<h2 id="代理和映射"><a href="#代理和映射" class="headerlink" title="代理和映射"></a>代理和映射<a id="org6bf2c25"></a></h2><table>
<thead>
<tr>
<th>Proxy Traps</th>
<th>Reflect Apis</th>
<th>原生功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>get</code> <a href="#org38c7be9">13.3.3</a></td>
<td><code>Reflect.get(trapTarget, key, receiver)</code></td>
<td>对象属性读取</td>
<td>访问对象属性的时候触发</td>
</tr>
<tr>
<td><code>set</code> <a href="#org999196c">13.3.2</a></td>
<td><code>Reflect.set(trapTarget, key, value, receiver)</code></td>
<td>对象属性赋值操作</td>
<td>改变对象属性的值时触发</td>
</tr>
<tr>
<td><code>has</code> <a href="#org46d3f0c">13.3.4</a></td>
<td><code>Reflect.has(trapTarget, key)</code></td>
<td><code>key in obj</code></td>
<td>检测存在性</td>
</tr>
<tr>
<td><code>deleteProperty</code> <a href="#orgb519cd2">13.3.5</a></td>
<td><code>Reflect.deleteProperty(trapTarget, key)</code></td>
<td><code>delete obj.name</code></td>
<td>删除属性</td>
</tr>
<tr>
<td><code>getPrototypeOf</code> <a href="#org9c538fc">13.4</a></td>
<td><code>Reflect.getPrototypeOf(trapTarget)</code></td>
<td>获取对象原型</td>
<td><code>Object.getPrototypeOf()</code></td>
</tr>
<tr>
<td><code>setPrototypeOf</code> <a href="#org9c538fc">13.4</a></td>
<td><code>Reflect.setPrototypeOf(trapTarget, proto)</code></td>
<td>设置对象原型</td>
<td><code>Object.setPrototypeOf()</code></td>
</tr>
<tr>
<td><code>isExtensible</code> <a href="#orgfd5f8b6">13.5</a></td>
<td><code>Reflect.isExtensible(trapTarget)</code></td>
<td>扩展性</td>
<td><code>Object.isExtensible()</code></td>
</tr>
<tr>
<td><code>preventExtensions</code> <a href="#orgfd5f8b6">13.5</a></td>
<td><code>Reflect.preventExtensions(trapTarget)</code></td>
<td>扩展对象</td>
<td><code>Object.preventExtensions()</code></td>
</tr>
<tr>
<td><code>definePropery</code> <a href="#org8c34cb8">13.6.3</a></td>
<td><code>Reflect.definePropery(trapTarget, key, descriptor)</code></td>
<td>属性描述符代理</td>
<td><code>Object.defineProperty(obj, key, desc)</code></td>
</tr>
<tr>
<td><code>getOwnPropertyDescriptor</code>  <a href="#org8c34cb8">13.6.3</a></td>
<td><code>Reflect.getOwnPropertyDescriptor(trapTarget, key)</code></td>
<td>获取属性描述符对象</td>
<td><code>Object.getOwnPropertyDescriptor(trapTarget, key</code></td>
</tr>
<tr>
<td><code>ownKeys</code> <a href="#org59878e2">13.7</a></td>
<td><code>Reflect.ownKeys(trapTarget)</code></td>
<td>返回自身属性</td>
<td><code>Object.keys()</code>, <code>Object.getOwnPropertyNames()</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>Object.keys()</code></td>
<td>不包含符号属性</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>=Object.getOwnPropertyNames()=</code></td>
<td>不包含符号属性</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>Object.getOwnPropertySymbols()</code></td>
<td>不包含符号属性</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>Object.assign()</code></td>
<td>包含符号属性</td>
</tr>
<tr>
<td><code>apply</code>  <a href="#org3033f8b">13.8</a></td>
<td><code>Reflect.apply(trapTarget, thisArg, argumentsList)</code></td>
<td>函数的调用</td>
<td>-</td>
</tr>
<tr>
<td><code>construct</code> <a href="#org3033f8b">13.8</a></td>
<td><code>Reflect.construct(trapTarget, argList[, newTarget]</code></td>
<td>函数实例化(<code>new</code>)</td>
<td>-</td>
</tr>
<tr>
<td><code>Proxy.revocable(target, trapObj)</code> <a href="#org0e4d674">13.9</a></td>
<td>-</td>
<td>可撤销的代理</td>
<td>返回代理实例和 <code>revoke()</code> 撤销函数</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>表中参数说明：  </p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>trapTarget</code></td>
<td><code>Object</code></td>
<td>被代理的对象</td>
</tr>
<tr>
<td><code>key</code></td>
<td>-</td>
<td>要操作的对象属性名</td>
</tr>
<tr>
<td><code>value</code></td>
<td>-</td>
<td>对象属性值</td>
</tr>
<tr>
<td><code>receiver</code></td>
<td><code>Proxy</code></td>
<td>代理对象</td>
</tr>
</tbody></table>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><table>
<thead>
<tr>
<th>符号方法</th>
<th>类型</th>
<th>JavaScript 特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol.hasInstance</code></td>
<td><code>boolean</code></td>
<td><code>instanceof</code></td>
<td><a href="#org7e71710">7.7.1</a> 实例(原型链)检测</td>
</tr>
<tr>
<td><code>Symbol.isConcatSpreadable</code></td>
<td><code>boolean</code></td>
<td><code>Array.prototype.concat</code></td>
<td><a href="#org67eb564">7.7.2</a> 检测参数合法性</td>
</tr>
<tr>
<td><code>Symbol.iterator</code></td>
<td><code>function</code></td>
<td>调用后得到迭代器</td>
<td>遍历对象或数组(等可迭代的对象)的时候会用到</td>
</tr>
<tr>
<td><code>Symbol.asyncIterator</code></td>
<td><code>function</code></td>
<td>调用后得到异步迭代器(返回一个 <code>Promise</code> )</td>
<td>遍历对象或数组(等可迭代的对象)的时候会用到</td>
</tr>
<tr>
<td><code>Symbol.match</code></td>
<td><code>function</code></td>
<td><code>String.prototype.match</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.matchAll</code></td>
<td><code>function</code></td>
<td><code>String.prototype.matchAll</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.replace</code></td>
<td><code>function</code></td>
<td><code>String.prototype.replace</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.search</code></td>
<td><code>function</code></td>
<td><code>String.prototype.search</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.split</code></td>
<td><code>function</code></td>
<td><code>String.prototype.split</code></td>
<td><a href="#org139fb83">7.7.3</a> 正则表达式对象内部属性</td>
</tr>
<tr>
<td><code>Symbol.species</code></td>
<td><code>constructor</code></td>
<td><code>new this.constructor[Symbol.species](value)</code></td>
<td><a href="#orga2051c7">symbol-species</a> 返回构造函数，类内部使用，不能构造函数调用</td>
</tr>
<tr>
<td><code>Symbol.toPrimitive</code></td>
<td><code>function</code></td>
<td>-</td>
<td><a href="#orgae3ed38">7.7.4</a> 返回一个对象的原始值</td>
</tr>
<tr>
<td><code>Symbol.toStringTag</code></td>
<td><code>string</code></td>
<td><code>Object.prototype.toString()</code></td>
<td><a href="#orgc7b5259">7.7.5</a> 返回一个对象的字符串描述</td>
</tr>
<tr>
<td><code>Symbol.unscopables</code></td>
<td><code>object</code></td>
<td><code>with</code></td>
<td><a href="#orgf7af38d">7.7.8</a> 不能出现在 <code>with</code> 语句中的一个对象</td>
</tr>
</tbody></table>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><table>
<thead>
<tr>
<th>分类</th>
<th>函数名</th>
<th>描述</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>Promise</td>
<td><code>Promise.all(iterable)</code></td>
<td>所有的 promise resolved</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Promise.race(iterable)</code></td>
<td>只要有一个 promise settled 那么 race 立即 settled(无论是 rejected 还是 fulfilled)</td>
<td></td>
</tr>
<tr>
<td>Array</td>
<td><code>Array.of(...items)</code></td>
<td>将参数了列表中的值组合成数组</td>
<td>和构造函数不一样，该方法会将参数只当做元素处理，而不会像 <code>Array()</code> 传一个参数当做长度处理。</td>
</tr>
<tr>
<td></td>
<td><code>Array.from(items[, mapFn[, thisArg]])</code></td>
<td>将满足条件的对象转成数组</td>
<td>条件：1. 必须有长度属性，2. 要有数值索引元素。可迭代的对象会直接访问迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>Array.prototype.find(mapFn[, thisArg])</code></td>
<td>查找 mapFn 返回 true 条件的元素，返回该元素值</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td><code>Array.prototype.findIndex(mapFn[, thisArg])</code></td>
<td>查找 mapFn 返回 true 条件的元素，返回该元素索引</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td><code>Array.prototype.fill(value[, start[, end]])</code></td>
<td>用 value 替换区间 [start, end) 之间的元素值</td>
<td>返回值是原数组(元素被替换之后的)</td>
</tr>
<tr>
<td></td>
<td><code>Array.prototype.copyWithin(target, start[, end])</code></td>
<td>拷贝区间 [start, end) 的元素替换 [target, len) 区间的元素</td>
<td>实际替换的区间长度由 min(end - start, len - target) 决定。</td>
</tr>
<tr>
<td>Function</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Object</td>
<td><code>Object.is(v1, v2)</code></td>
<td>v1 是否是 v2</td>
<td>弥补 <code>===</code> 不能判断 +0，-0 和 NaN，NaN</td>
</tr>
<tr>
<td></td>
<td><code>Object.assign(target, ...sources)</code></td>
<td>合并对象，浅拷贝，赋值运算</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Object.getPrototypeOf(obj)</code></td>
<td>取原型对象</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Object.setPrototypeOf(obj, protoObj)</code></td>
<td>设置原型对象</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Object.getOwnPropertySymbols(obj)</code></td>
<td>获取对象所有符号属性</td>
<td><code>Object.keys</code>, <code>Object.getOwnPropertyNames</code> 不能取符号属性</td>
</tr>
<tr>
<td></td>
<td><code>Object.getOwnPropertyDescriptor(obj, key)</code></td>
<td>获取对象的描述符对象</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Object.preventExtensions()</code></td>
<td>阻止对象呗扩展</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td><code>Object.isExtensible()</code></td>
<td>对象是否可被扩展</td>
<td>-</td>
</tr>
<tr>
<td>String</td>
<td><code>str.codePointAt(n)</code></td>
<td>Unicode编码值</td>
<td>str.charCodeAt(n)</td>
</tr>
<tr>
<td></td>
<td><code>str.fromCodePoint(s)</code></td>
<td>根据编码转字符</td>
<td>str.fromCharCode(s)</td>
</tr>
<tr>
<td></td>
<td><code>str.normalize()</code></td>
<td>将字符的不同表示方式统一成一种表示形式</td>
<td>undefined, “NFC”, “NFD”, “NFKC”, or “NFKD”</td>
</tr>
<tr>
<td></td>
<td><code>str.repeat(n)</code></td>
<td>将字符串重复 n 遍，作为新字符串返回</td>
<td>‘x’.repeat(3) =&gt; ‘xxx’</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
